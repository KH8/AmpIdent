#line 1 "C:/Users/H8/Documents/Visual Studio 2012/Projects/AmpIdent/AmpIdentGPUkernel/AmpIdentGPUkernel/kernel.cu"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"


























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"

































































#line 67 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"









#line 77 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"









#line 87 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"







#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"

#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"













#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"




#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"





#line 122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"







#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"





#line 136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"





#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"





#line 148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 





#line 22 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 23 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


















#line 42 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 46 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"










#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"













#pragma once







































































































































#line 151 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"









































#line 193 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"

#line 195 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"





#line 201 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"



#line 205 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






#line 212 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






#line 219 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"




#line 224 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






























































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros




































































































































































































































































































































































































































































                                                




                                                

















































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1549 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






























#line 1580 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"
























#line 1605 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"












#line 1618 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"







































#line 1658 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"


























































































































#line 1781 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






































































































#line 1884 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"








































































































































































#line 2053 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"





































































































#line 2155 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"



















































































































































































































#line 2367 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"
extern "C" {




#line 2373 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"



































































































































































































































#line 2601 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2640 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"


































































































































































































































  

    
    
#line 2871 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






#line 2878 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"
#line 2879 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






#line 2886 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"
#line 2887 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"










#line 2898 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"

































#line 2932 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






















}
#line 2956 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"


















#pragma once


extern "C" {
#line 24 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"
















































































































































































































































#line 265 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"



#line 269 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"


















































































#line 352 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"


}
#line 356 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"

#line 358 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"
#line 2958 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"


#line 57 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#pragma pack(push,8)

#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"












#pragma once






#line 21 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"








#pragma pack(push,8)


extern "C" {
#line 34 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"







#line 42 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"
#line 43 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"





typedef __w64 unsigned int   uintptr_t;
#line 50 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"

#line 52 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"





typedef char *  va_list;
#line 59 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"

#line 61 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"





#line 67 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"







#line 75 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"


#line 78 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"













#line 92 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"












































#line 137 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"


}
#line 141 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"

#pragma pack(pop)

#line 145 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"
#line 64 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


extern "C" {
#line 68 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 74 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 79 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 84 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"







#line 92 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"









#line 102 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 103 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"










#line 114 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


#line 117 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 118 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 124 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"









#line 134 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 136 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"







#line 144 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 145 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 150 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 152 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 153 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 158 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 160 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 161 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


 

#line 166 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
  
 #line 168 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 169 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"










#line 180 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 181 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 188 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 189 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

















#line 207 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 212 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"








#line 221 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 228 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 229 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 235 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 242 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 243 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 250 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 251 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 256 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


#line 259 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 261 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 262 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 263 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 269 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"










#line 280 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 282 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 283 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 284 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"










#line 295 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 302 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 303 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

















#line 321 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 322 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 326 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 333 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 334 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 341 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 348 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 350 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 351 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



 
  
 



#line 361 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 362 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


 
  
  
 



#line 372 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 373 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


 
  
   
  

#line 381 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
 



#line 386 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 387 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


 
  
 



#line 396 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 397 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


 
  
 



#line 406 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 407 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 411 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 417 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 424 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 425 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





typedef __w64 unsigned int   size_t;
#line 432 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 434 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



typedef size_t rsize_t;

#line 440 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 441 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





typedef __w64 int            intptr_t;
#line 448 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 450 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














typedef __w64 int            ptrdiff_t;
#line 466 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 468 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"







typedef unsigned short wint_t;
typedef unsigned short wctype_t;

#line 479 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


















typedef int errno_t;
#line 499 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


typedef __w64 long __time32_t;   

#line 504 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


typedef __int64 __time64_t;     

#line 509 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





typedef __time64_t time_t;      
#line 516 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 518 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"







#line 526 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 527 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 531 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 533 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 538 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 540 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 541 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 547 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 551 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 556 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 558 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 559 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"










 __declspec(dllimport) void __cdecl _invalid_parameter(  const wchar_t *,   const wchar_t *,   const wchar_t *, unsigned int, uintptr_t);



#line 574 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

__declspec(dllimport) __declspec(noreturn)
void __cdecl _invoke_watson(  const wchar_t *,   const wchar_t *,   const wchar_t *, unsigned int, uintptr_t);


 
  
 #line 582 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"












#line 595 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"







#line 603 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


































































































































































#line 766 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 767 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1833 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"















































































































































#line 1977 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 1978 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct
{
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;


typedef struct localerefcount {
        char *locale;
        wchar_t *wlocale;
        int *refcount;
        int *wrefcount;
} locrefcount;

typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned int lc_time_cp;
        locrefcount lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
        wchar_t * locale_name[6];
} threadlocinfo;

#line 2021 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


}
#line 2025 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 2029 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 2031 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 2035 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 2037 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 2041 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 2043 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 2050 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 2054 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#pragma pack(pop)

#line 2058 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"



#line 154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"

#line 156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"

#line 158 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_config.h"
#line 60 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"







#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




















































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"





















































































#line 87 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"








































#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










#line 150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"






#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"




#line 162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










#line 174 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"

















#line 192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"








#line 201 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"


#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 54 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"







enum __declspec(__device_builtin__) cudaRoundMode
{
    cudaRoundNearest,
    cudaRoundZero,
    cudaRoundPosInf,
    cudaRoundMinInf
};

#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"




















































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 54 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
















#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"














#pragma once

#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 18 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"
















#line 35 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"









































#line 77 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"






#line 84 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"
#line 85 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"




#line 90 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"
#line 91 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"
































#line 124 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"
#line 71 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"














#pragma once




#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"


extern "C" {
#line 25 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"







#line 33 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"
#line 34 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"


namespace std { typedef decltype(__nullptr) nullptr_t; }
using ::std::nullptr_t;
#line 39 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"




__declspec(dllimport) extern int * __cdecl _errno(void);


errno_t __cdecl _set_errno(  int _Value);
errno_t __cdecl _get_errno(  int * _Value);
#line 49 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"








#line 58 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"









#line 68 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);


}
#line 76 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"

#line 78 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"
#line 72 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"









































#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










enum __declspec(__device_builtin__) cudaError
{
    




    cudaSuccess                           =      0,
  
    



    cudaErrorMissingConfiguration         =      1,
  
    



    cudaErrorMemoryAllocation             =      2,
  
    



    cudaErrorInitializationError          =      3,
  
    







    cudaErrorLaunchFailure                =      4,
  
    






    cudaErrorPriorLaunchFailure           =      5,
  
    







    cudaErrorLaunchTimeout                =      6,
  
    






    cudaErrorLaunchOutOfResources         =      7,
  
    



    cudaErrorInvalidDeviceFunction        =      8,
  
    






    cudaErrorInvalidConfiguration         =      9,
  
    



    cudaErrorInvalidDevice                =     10,
  
    



    cudaErrorInvalidValue                 =     11,
  
    



    cudaErrorInvalidPitchValue            =     12,
  
    



    cudaErrorInvalidSymbol                =     13,
  
    


    cudaErrorMapBufferObjectFailed        =     14,
  
    


    cudaErrorUnmapBufferObjectFailed      =     15,
  
    



    cudaErrorInvalidHostPointer           =     16,
  
    



    cudaErrorInvalidDevicePointer         =     17,
  
    



    cudaErrorInvalidTexture               =     18,
  
    



    cudaErrorInvalidTextureBinding        =     19,
  
    




    cudaErrorInvalidChannelDescriptor     =     20,
  
    



    cudaErrorInvalidMemcpyDirection       =     21,
  
    







    cudaErrorAddressOfConstant            =     22,
  
    






    cudaErrorTextureFetchFailed           =     23,
  
    






    cudaErrorTextureNotBound              =     24,
  
    






    cudaErrorSynchronizationError         =     25,
  
    



    cudaErrorInvalidFilterSetting         =     26,
  
    



    cudaErrorInvalidNormSetting           =     27,
  
    





    cudaErrorMixedDeviceExecution         =     28,
  
    




    cudaErrorCudartUnloading              =     29,
  
    


    cudaErrorUnknown                      =     30,

    





    cudaErrorNotYetImplemented            =     31,
  
    






    cudaErrorMemoryValueTooLarge          =     32,
  
    




    cudaErrorInvalidResourceHandle        =     33,
  
    





    cudaErrorNotReady                     =     34,
  
    




    cudaErrorInsufficientDriver           =     35,
  
    










    cudaErrorSetOnActiveProcess           =     36,
  
    



    cudaErrorInvalidSurface               =     37,
  
    



    cudaErrorNoDevice                     =     38,
  
    



    cudaErrorECCUncorrectable             =     39,
  
    


    cudaErrorSharedObjectSymbolNotFound   =     40,
  
    


    cudaErrorSharedObjectInitFailed       =     41,
  
    



    cudaErrorUnsupportedLimit             =     42,
  
    



    cudaErrorDuplicateVariableName        =     43,
  
    



    cudaErrorDuplicateTextureName         =     44,
  
    



    cudaErrorDuplicateSurfaceName         =     45,
  
    







    cudaErrorDevicesUnavailable           =     46,
  
    


    cudaErrorInvalidKernelImage           =     47,
  
    





    cudaErrorNoKernelImageForDevice       =     48,
  
    










    cudaErrorIncompatibleDriverContext    =     49,
      
    




    cudaErrorPeerAccessAlreadyEnabled     =     50,
    
    




    cudaErrorPeerAccessNotEnabled         =     51,
    
    



    cudaErrorDeviceAlreadyInUse           =     54,

    




    cudaErrorProfilerDisabled             =     55,

    





    cudaErrorProfilerNotInitialized       =     56,

    




    cudaErrorProfilerAlreadyStarted       =     57,

    




     cudaErrorProfilerAlreadyStopped       =    58,

    





    cudaErrorAssert                        =    59,
  
    




    cudaErrorTooManyPeers                 =     60,
  
    



    cudaErrorHostMemoryAlreadyRegistered  =     61,
        
    



    cudaErrorHostMemoryNotRegistered      =     62,

    


    cudaErrorOperatingSystem              =     63,

    



    cudaErrorPeerAccessUnsupported        =     64,

    




    cudaErrorLaunchMaxDepthExceeded       =     65,

    





    cudaErrorLaunchFileScopedTex          =     66,

    





    cudaErrorLaunchFileScopedSurf         =     67,

    












    cudaErrorSyncDepthExceeded            =     68,

    









    cudaErrorLaunchPendingCountExceeded   =     69,
    
    


    cudaErrorNotPermitted                 =     70,

    



    cudaErrorNotSupported                 =     71,

    


    cudaErrorStartupFailure               =   0x7f,

    





    cudaErrorApiFailureBase               =  10000
};




enum __declspec(__device_builtin__) cudaChannelFormatKind
{
    cudaChannelFormatKindSigned           =   0,      
    cudaChannelFormatKindUnsigned         =   1,      
    cudaChannelFormatKindFloat            =   2,      
    cudaChannelFormatKindNone             =   3       
};




struct __declspec(__device_builtin__) cudaChannelFormatDesc
{
    int                        x; 
    int                        y; 
    int                        z; 
    int                        w; 
    enum cudaChannelFormatKind f; 
};




typedef struct cudaArray *cudaArray_t;




typedef const struct cudaArray *cudaArray_const_t;

struct cudaArray;




typedef struct cudaMipmappedArray *cudaMipmappedArray_t;




typedef const struct cudaMipmappedArray *cudaMipmappedArray_const_t;

struct cudaMipmappedArray;




enum __declspec(__device_builtin__) cudaMemoryType
{
    cudaMemoryTypeHost   = 1, 
    cudaMemoryTypeDevice = 2  
};




enum __declspec(__device_builtin__) cudaMemcpyKind
{
    cudaMemcpyHostToHost          =   0,      
    cudaMemcpyHostToDevice        =   1,      
    cudaMemcpyDeviceToHost        =   2,      
    cudaMemcpyDeviceToDevice      =   3,      
    cudaMemcpyDefault             =   4       
};





struct __declspec(__device_builtin__) cudaPitchedPtr
{
    void   *ptr;      
    size_t  pitch;    
    size_t  xsize;    
    size_t  ysize;    
};





struct __declspec(__device_builtin__) cudaExtent
{
    size_t width;     
    size_t height;    
    size_t depth;     
};





struct __declspec(__device_builtin__) cudaPos
{
    size_t x;     
    size_t y;     
    size_t z;     
};




struct __declspec(__device_builtin__) cudaMemcpy3DParms
{
    cudaArray_t            srcArray;  
    struct cudaPos         srcPos;    
    struct cudaPitchedPtr  srcPtr;    
  
    cudaArray_t            dstArray;  
    struct cudaPos         dstPos;    
    struct cudaPitchedPtr  dstPtr;    
  
    struct cudaExtent      extent;    
    enum cudaMemcpyKind    kind;      
};




struct __declspec(__device_builtin__) cudaMemcpy3DPeerParms
{
    cudaArray_t            srcArray;  
    struct cudaPos         srcPos;    
    struct cudaPitchedPtr  srcPtr;    
    int                    srcDevice; 
  
    cudaArray_t            dstArray;  
    struct cudaPos         dstPos;    
    struct cudaPitchedPtr  dstPtr;    
    int                    dstDevice; 
  
    struct cudaExtent      extent;    
};




struct cudaGraphicsResource;




enum __declspec(__device_builtin__) cudaGraphicsRegisterFlags
{
    cudaGraphicsRegisterFlagsNone             = 0,  
    cudaGraphicsRegisterFlagsReadOnly         = 1,   
    cudaGraphicsRegisterFlagsWriteDiscard     = 2,  
    cudaGraphicsRegisterFlagsSurfaceLoadStore = 4,  
    cudaGraphicsRegisterFlagsTextureGather    = 8   
};




enum __declspec(__device_builtin__) cudaGraphicsMapFlags
{
    cudaGraphicsMapFlagsNone         = 0,  
    cudaGraphicsMapFlagsReadOnly     = 1,  
    cudaGraphicsMapFlagsWriteDiscard = 2   
};




enum __declspec(__device_builtin__) cudaGraphicsCubeFace 
{
    cudaGraphicsCubeFacePositiveX = 0x00, 
    cudaGraphicsCubeFaceNegativeX = 0x01, 
    cudaGraphicsCubeFacePositiveY = 0x02, 
    cudaGraphicsCubeFaceNegativeY = 0x03, 
    cudaGraphicsCubeFacePositiveZ = 0x04, 
    cudaGraphicsCubeFaceNegativeZ = 0x05  
};




enum __declspec(__device_builtin__) cudaResourceType
{
    cudaResourceTypeArray          = 0x00, 
    cudaResourceTypeMipmappedArray = 0x01, 
    cudaResourceTypeLinear         = 0x02, 
    cudaResourceTypePitch2D        = 0x03  
};




enum __declspec(__device_builtin__) cudaResourceViewFormat
{
    cudaResViewFormatNone                      = 0x00, 
    cudaResViewFormatUnsignedChar1             = 0x01, 
    cudaResViewFormatUnsignedChar2             = 0x02, 
    cudaResViewFormatUnsignedChar4             = 0x03, 
    cudaResViewFormatSignedChar1               = 0x04, 
    cudaResViewFormatSignedChar2               = 0x05, 
    cudaResViewFormatSignedChar4               = 0x06, 
    cudaResViewFormatUnsignedShort1            = 0x07, 
    cudaResViewFormatUnsignedShort2            = 0x08, 
    cudaResViewFormatUnsignedShort4            = 0x09, 
    cudaResViewFormatSignedShort1              = 0x0a, 
    cudaResViewFormatSignedShort2              = 0x0b, 
    cudaResViewFormatSignedShort4              = 0x0c, 
    cudaResViewFormatUnsignedInt1              = 0x0d, 
    cudaResViewFormatUnsignedInt2              = 0x0e, 
    cudaResViewFormatUnsignedInt4              = 0x0f, 
    cudaResViewFormatSignedInt1                = 0x10, 
    cudaResViewFormatSignedInt2                = 0x11, 
    cudaResViewFormatSignedInt4                = 0x12, 
    cudaResViewFormatHalf1                     = 0x13, 
    cudaResViewFormatHalf2                     = 0x14, 
    cudaResViewFormatHalf4                     = 0x15, 
    cudaResViewFormatFloat1                    = 0x16, 
    cudaResViewFormatFloat2                    = 0x17, 
    cudaResViewFormatFloat4                    = 0x18, 
    cudaResViewFormatUnsignedBlockCompressed1  = 0x19, 
    cudaResViewFormatUnsignedBlockCompressed2  = 0x1a, 
    cudaResViewFormatUnsignedBlockCompressed3  = 0x1b, 
    cudaResViewFormatUnsignedBlockCompressed4  = 0x1c, 
    cudaResViewFormatSignedBlockCompressed4    = 0x1d, 
    cudaResViewFormatUnsignedBlockCompressed5  = 0x1e, 
    cudaResViewFormatSignedBlockCompressed5    = 0x1f, 
    cudaResViewFormatUnsignedBlockCompressed6H = 0x20, 
    cudaResViewFormatSignedBlockCompressed6H   = 0x21, 
    cudaResViewFormatUnsignedBlockCompressed7  = 0x22  
};




struct __declspec(__device_builtin__) cudaResourceDesc {
	enum cudaResourceType resType;             
	
	union {
		struct {
			cudaArray_t array;                 
		} array;
        struct {
            cudaMipmappedArray_t mipmap;       
        } mipmap;
		struct {
			void *devPtr;                      
			struct cudaChannelFormatDesc desc; 
			size_t sizeInBytes;                
		} linear;
		struct {
			void *devPtr;                      
			struct cudaChannelFormatDesc desc; 
			size_t width;                      
			size_t height;                     
			size_t pitchInBytes;               
		} pitch2D;
	} res;
};




struct __declspec(__device_builtin__) cudaResourceViewDesc
{
    enum cudaResourceViewFormat format;           
    size_t                      width;            
    size_t                      height;           
    size_t                      depth;            
    unsigned int                firstMipmapLevel; 
    unsigned int                lastMipmapLevel;  
    unsigned int                firstLayer;       
    unsigned int                lastLayer;        
};




struct __declspec(__device_builtin__) cudaPointerAttributes
{
    



    enum cudaMemoryType memoryType;

    








    int device;

    



    void *devicePointer;

    



    void *hostPointer;
};




struct __declspec(__device_builtin__) cudaFuncAttributes
{
   




   size_t sharedSizeBytes;

   



   size_t constSizeBytes;

   


   size_t localSizeBytes;

   




   int maxThreadsPerBlock;

   


   int numRegs;

   




   int ptxVersion;

   




   int binaryVersion;
};




enum __declspec(__device_builtin__) cudaFuncCache
{
    cudaFuncCachePreferNone   = 0,    
    cudaFuncCachePreferShared = 1,    
    cudaFuncCachePreferL1     = 2,    
    cudaFuncCachePreferEqual  = 3     
};





enum __declspec(__device_builtin__) cudaSharedMemConfig
{
    cudaSharedMemBankSizeDefault   = 0,
    cudaSharedMemBankSizeFourByte  = 1,
    cudaSharedMemBankSizeEightByte = 2
};




enum __declspec(__device_builtin__) cudaComputeMode
{
    cudaComputeModeDefault          = 0,  
    cudaComputeModeExclusive        = 1,  
    cudaComputeModeProhibited       = 2,  
    cudaComputeModeExclusiveProcess = 3   
};




enum __declspec(__device_builtin__) cudaLimit
{
    cudaLimitStackSize                    = 0x00, 
    cudaLimitPrintfFifoSize               = 0x01, 
    cudaLimitMallocHeapSize               = 0x02, 
    cudaLimitDevRuntimeSyncDepth          = 0x03, 
    cudaLimitDevRuntimePendingLaunchCount = 0x04  
};




enum __declspec(__device_builtin__) cudaOutputMode
{
    cudaKeyValuePair    = 0x00, 
    cudaCSV             = 0x01  
};




enum __declspec(__device_builtin__) cudaDeviceAttr
{
    cudaDevAttrMaxThreadsPerBlock             = 1,  
    cudaDevAttrMaxBlockDimX                   = 2,  
    cudaDevAttrMaxBlockDimY                   = 3,  
    cudaDevAttrMaxBlockDimZ                   = 4,  
    cudaDevAttrMaxGridDimX                    = 5,  
    cudaDevAttrMaxGridDimY                    = 6,  
    cudaDevAttrMaxGridDimZ                    = 7,  
    cudaDevAttrMaxSharedMemoryPerBlock        = 8,  
    cudaDevAttrTotalConstantMemory            = 9,  
    cudaDevAttrWarpSize                       = 10, 
    cudaDevAttrMaxPitch                       = 11, 
    cudaDevAttrMaxRegistersPerBlock           = 12, 
    cudaDevAttrClockRate                      = 13, 
    cudaDevAttrTextureAlignment               = 14, 
    cudaDevAttrGpuOverlap                     = 15, 
    cudaDevAttrMultiProcessorCount            = 16, 
    cudaDevAttrKernelExecTimeout              = 17, 
    cudaDevAttrIntegrated                     = 18, 
    cudaDevAttrCanMapHostMemory               = 19, 
    cudaDevAttrComputeMode                    = 20, 
    cudaDevAttrMaxTexture1DWidth              = 21, 
    cudaDevAttrMaxTexture2DWidth              = 22, 
    cudaDevAttrMaxTexture2DHeight             = 23, 
    cudaDevAttrMaxTexture3DWidth              = 24, 
    cudaDevAttrMaxTexture3DHeight             = 25, 
    cudaDevAttrMaxTexture3DDepth              = 26, 
    cudaDevAttrMaxTexture2DLayeredWidth       = 27, 
    cudaDevAttrMaxTexture2DLayeredHeight      = 28, 
    cudaDevAttrMaxTexture2DLayeredLayers      = 29, 
    cudaDevAttrSurfaceAlignment               = 30, 
    cudaDevAttrConcurrentKernels              = 31, 
    cudaDevAttrEccEnabled                     = 32, 
    cudaDevAttrPciBusId                       = 33, 
    cudaDevAttrPciDeviceId                    = 34, 
    cudaDevAttrTccDriver                      = 35, 
    cudaDevAttrMemoryClockRate                = 36, 
    cudaDevAttrGlobalMemoryBusWidth           = 37, 
    cudaDevAttrL2CacheSize                    = 38, 
    cudaDevAttrMaxThreadsPerMultiProcessor    = 39, 
    cudaDevAttrAsyncEngineCount               = 40, 
    cudaDevAttrUnifiedAddressing              = 41,     
    cudaDevAttrMaxTexture1DLayeredWidth       = 42, 
    cudaDevAttrMaxTexture1DLayeredLayers      = 43, 
    cudaDevAttrMaxTexture2DGatherWidth        = 45, 
    cudaDevAttrMaxTexture2DGatherHeight       = 46, 
    cudaDevAttrMaxTexture3DWidthAlt           = 47, 
    cudaDevAttrMaxTexture3DHeightAlt          = 48, 
    cudaDevAttrMaxTexture3DDepthAlt           = 49, 
    cudaDevAttrPciDomainId                    = 50, 
    cudaDevAttrTexturePitchAlignment          = 51, 
    cudaDevAttrMaxTextureCubemapWidth         = 52, 
    cudaDevAttrMaxTextureCubemapLayeredWidth  = 53, 
    cudaDevAttrMaxTextureCubemapLayeredLayers = 54, 
    cudaDevAttrMaxSurface1DWidth              = 55, 
    cudaDevAttrMaxSurface2DWidth              = 56, 
    cudaDevAttrMaxSurface2DHeight             = 57, 
    cudaDevAttrMaxSurface3DWidth              = 58, 
    cudaDevAttrMaxSurface3DHeight             = 59, 
    cudaDevAttrMaxSurface3DDepth              = 60, 
    cudaDevAttrMaxSurface1DLayeredWidth       = 61, 
    cudaDevAttrMaxSurface1DLayeredLayers      = 62, 
    cudaDevAttrMaxSurface2DLayeredWidth       = 63, 
    cudaDevAttrMaxSurface2DLayeredHeight      = 64, 
    cudaDevAttrMaxSurface2DLayeredLayers      = 65, 
    cudaDevAttrMaxSurfaceCubemapWidth         = 66, 
    cudaDevAttrMaxSurfaceCubemapLayeredWidth  = 67, 
    cudaDevAttrMaxSurfaceCubemapLayeredLayers = 68, 
    cudaDevAttrMaxTexture1DLinearWidth        = 69, 
    cudaDevAttrMaxTexture2DLinearWidth        = 70, 
    cudaDevAttrMaxTexture2DLinearHeight       = 71, 
    cudaDevAttrMaxTexture2DLinearPitch        = 72, 
    cudaDevAttrMaxTexture2DMipmappedWidth     = 73, 
    cudaDevAttrMaxTexture2DMipmappedHeight    = 74, 
    cudaDevAttrComputeCapabilityMajor         = 75,  
    cudaDevAttrComputeCapabilityMinor         = 76, 
    cudaDevAttrMaxTexture1DMipmappedWidth     = 77, 
    cudaDevAttrStreamPrioritiesSupported      = 78  
};




struct __declspec(__device_builtin__) cudaDeviceProp
{
    char   name[256];                  
    size_t totalGlobalMem;             
    size_t sharedMemPerBlock;          
    int    regsPerBlock;               
    int    warpSize;                   
    size_t memPitch;                   
    int    maxThreadsPerBlock;         
    int    maxThreadsDim[3];           
    int    maxGridSize[3];             
    int    clockRate;                  
    size_t totalConstMem;              
    int    major;                      
    int    minor;                      
    size_t textureAlignment;           
    size_t texturePitchAlignment;      
    int    deviceOverlap;              
    int    multiProcessorCount;        
    int    kernelExecTimeoutEnabled;   
    int    integrated;                 
    int    canMapHostMemory;           
    int    computeMode;                
    int    maxTexture1D;               
    int    maxTexture1DMipmap;         
    int    maxTexture1DLinear;         
    int    maxTexture2D[2];            
    int    maxTexture2DMipmap[2];      
    int    maxTexture2DLinear[3];      
    int    maxTexture2DGather[2];      
    int    maxTexture3D[3];            
    int    maxTexture3DAlt[3];         
    int    maxTextureCubemap;          
    int    maxTexture1DLayered[2];     
    int    maxTexture2DLayered[3];     
    int    maxTextureCubemapLayered[2];
    int    maxSurface1D;               
    int    maxSurface2D[2];            
    int    maxSurface3D[3];            
    int    maxSurface1DLayered[2];     
    int    maxSurface2DLayered[3];     
    int    maxSurfaceCubemap;          
    int    maxSurfaceCubemapLayered[2];
    size_t surfaceAlignment;           
    int    concurrentKernels;          
    int    ECCEnabled;                 
    int    pciBusID;                   
    int    pciDeviceID;                
    int    pciDomainID;                
    int    tccDriver;                  
    int    asyncEngineCount;           
    int    unifiedAddressing;          
    int    memoryClockRate;            
    int    memoryBusWidth;             
    int    l2CacheSize;                
    int    maxThreadsPerMultiProcessor;
    int    streamPrioritiesSupported;  
};




































































typedef __declspec(__device_builtin__) struct __declspec(__device_builtin__) cudaIpcEventHandle_st
{
    char reserved[64];
}cudaIpcEventHandle_t;




typedef __declspec(__device_builtin__) struct __declspec(__device_builtin__) cudaIpcMemHandle_st 
{
    char reserved[64];
}cudaIpcMemHandle_t;










typedef __declspec(__device_builtin__) enum cudaError cudaError_t;




typedef __declspec(__device_builtin__) struct CUstream_st *cudaStream_t;




typedef __declspec(__device_builtin__) struct CUevent_st *cudaEvent_t;




typedef __declspec(__device_builtin__) struct cudaGraphicsResource *cudaGraphicsResource_t;




typedef __declspec(__device_builtin__) struct CUuuid_st cudaUUID_t;




typedef __declspec(__device_builtin__) enum cudaOutputMode cudaOutputMode_t;


 

#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"


























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
























enum __declspec(__device_builtin__) cudaSurfaceBoundaryMode
{
    cudaBoundaryModeZero  = 0,    
    cudaBoundaryModeClamp = 1,    
    cudaBoundaryModeTrap  = 2     
};




enum __declspec(__device_builtin__)  cudaSurfaceFormatMode
{
    cudaFormatModeForced = 0,     
    cudaFormatModeAuto = 1        
};




struct __declspec(__device_builtin__) surfaceReference
{
    


    struct cudaChannelFormatDesc channelDesc;
};




typedef __declspec(__device_builtin__) unsigned long long cudaSurfaceObject_t;


 

#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"


























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
























enum __declspec(__device_builtin__) cudaTextureAddressMode
{
    cudaAddressModeWrap   = 0,    
    cudaAddressModeClamp  = 1,    
    cudaAddressModeMirror = 2,    
    cudaAddressModeBorder = 3     
};




enum __declspec(__device_builtin__) cudaTextureFilterMode
{
    cudaFilterModePoint  = 0,     
    cudaFilterModeLinear = 1      
};




enum __declspec(__device_builtin__) cudaTextureReadMode
{
    cudaReadModeElementType     = 0,  
    cudaReadModeNormalizedFloat = 1   
};




struct __declspec(__device_builtin__) textureReference
{
    


    int                          normalized;
    


    enum cudaTextureFilterMode   filterMode;
    


    enum cudaTextureAddressMode  addressMode[3];
    


    struct cudaChannelFormatDesc channelDesc;
    


    int                          sRGB;
    


    unsigned int                 maxAnisotropy;
    


    enum cudaTextureFilterMode   mipmapFilterMode;
    


    float                        mipmapLevelBias;
    


    float                        minMipmapLevelClamp;
    


    float                        maxMipmapLevelClamp;
    int                          __cudaReserved[15];
};




struct __declspec(__device_builtin__) cudaTextureDesc
{
    


    enum cudaTextureAddressMode addressMode[3];
    


    enum cudaTextureFilterMode  filterMode;
    


    enum cudaTextureReadMode    readMode;
    


    int                         sRGB;
    


    int                         normalizedCoords;
    


    unsigned int                maxAnisotropy;
    


    enum cudaTextureFilterMode  mipmapFilterMode;
    


    float                       mipmapLevelBias;
    


    float                       minMipmapLevelClamp;
    


    float                       maxMipmapLevelClamp;
};




typedef __declspec(__device_builtin__) unsigned long long cudaTextureObject_t;


 

#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"



























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"






















#line 87 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"







#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"

struct __declspec(__device_builtin__) char1
{
    signed char x;
};

struct __declspec(__device_builtin__) uchar1
{
    unsigned char x;
};


struct __declspec(__device_builtin__) __declspec(align(2)) char2
{
    signed char x, y;
};

struct __declspec(__device_builtin__) __declspec(align(2)) uchar2
{
    unsigned char x, y;
};

struct __declspec(__device_builtin__) char3
{
    signed char x, y, z;
};

struct __declspec(__device_builtin__) uchar3
{
    unsigned char x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(4)) char4
{
    signed char x, y, z, w;
};

struct __declspec(__device_builtin__) __declspec(align(4)) uchar4
{
    unsigned char x, y, z, w;
};

struct __declspec(__device_builtin__) short1
{
    short x;
};

struct __declspec(__device_builtin__) ushort1
{
    unsigned short x;
};

struct __declspec(__device_builtin__) __declspec(align(4)) short2
{
    short x, y;
};

struct __declspec(__device_builtin__) __declspec(align(4)) ushort2
{
    unsigned short x, y;
};

struct __declspec(__device_builtin__) short3
{
    short x, y, z;
};

struct __declspec(__device_builtin__) ushort3
{
    unsigned short x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(8)) short4 { short x; short y; short z; short w; };
struct __declspec(__device_builtin__) __declspec(align(8)) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; };

struct __declspec(__device_builtin__) int1
{
    int x;
};

struct __declspec(__device_builtin__) uint1
{
    unsigned int x;
};

struct __declspec(__device_builtin__) __declspec(align(8)) int2 { int x; int y; };
struct __declspec(__device_builtin__) __declspec(align(8)) uint2 { unsigned int x; unsigned int y; };

struct __declspec(__device_builtin__) int3
{
    int x, y, z;
};

struct __declspec(__device_builtin__) uint3
{
    unsigned int x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) int4
{
    int x, y, z, w;
};

struct __declspec(__device_builtin__) __declspec(align(16)) uint4
{
    unsigned int x, y, z, w;
};

struct __declspec(__device_builtin__) long1
{
    long int x;
};

struct __declspec(__device_builtin__) ulong1
{
    unsigned long x;
};


struct __declspec(__device_builtin__) __declspec(align(8)) long2 { long int x; long int y; };
struct __declspec(__device_builtin__) __declspec(align(8)) ulong2 { unsigned long int x; unsigned long int y; };












#line 229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"

struct __declspec(__device_builtin__) long3
{
    long int x, y, z;
};

struct __declspec(__device_builtin__) ulong3
{
    unsigned long int x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) long4
{
    long int x, y, z, w;
};

struct __declspec(__device_builtin__) __declspec(align(16)) ulong4
{
    unsigned long int x, y, z, w;
};

struct __declspec(__device_builtin__) float1
{
    float x;
};















#line 271 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"

struct __declspec(__device_builtin__) __declspec(align(8)) float2 { float x; float y; };

#line 275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"


struct __declspec(__device_builtin__) float3
{
    float x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) float4
{
    float x, y, z, w;
};

struct __declspec(__device_builtin__) longlong1
{
    long long int x;
};

struct __declspec(__device_builtin__) ulonglong1
{
    unsigned long long int x;
};

struct __declspec(__device_builtin__) __declspec(align(16)) longlong2
{
    long long int x, y;
};

struct __declspec(__device_builtin__) __declspec(align(16)) ulonglong2
{
    unsigned long long int x, y;
};

struct __declspec(__device_builtin__) longlong3
{
    long long int x, y, z;
};

struct __declspec(__device_builtin__) ulonglong3
{
    unsigned long long int x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) longlong4
{
    long long int x, y, z ,w;
};

struct __declspec(__device_builtin__) __declspec(align(16)) ulonglong4
{
    unsigned long long int x, y, z, w;
};

struct __declspec(__device_builtin__) double1
{
    double x;
};

struct __declspec(__device_builtin__) __declspec(align(16)) double2
{
    double x, y;
};

struct __declspec(__device_builtin__) double3
{
    double x, y, z;
};

struct __declspec(__device_builtin__) __declspec(align(16)) double4
{
    double x, y, z, w;
};





#line 353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"







typedef __declspec(__device_builtin__) struct char1 char1;
typedef __declspec(__device_builtin__) struct uchar1 uchar1;
typedef __declspec(__device_builtin__) struct char2 char2;
typedef __declspec(__device_builtin__) struct uchar2 uchar2;
typedef __declspec(__device_builtin__) struct char3 char3;
typedef __declspec(__device_builtin__) struct uchar3 uchar3;
typedef __declspec(__device_builtin__) struct char4 char4;
typedef __declspec(__device_builtin__) struct uchar4 uchar4;
typedef __declspec(__device_builtin__) struct short1 short1;
typedef __declspec(__device_builtin__) struct ushort1 ushort1;
typedef __declspec(__device_builtin__) struct short2 short2;
typedef __declspec(__device_builtin__) struct ushort2 ushort2;
typedef __declspec(__device_builtin__) struct short3 short3;
typedef __declspec(__device_builtin__) struct ushort3 ushort3;
typedef __declspec(__device_builtin__) struct short4 short4;
typedef __declspec(__device_builtin__) struct ushort4 ushort4;
typedef __declspec(__device_builtin__) struct int1 int1;
typedef __declspec(__device_builtin__) struct uint1 uint1;
typedef __declspec(__device_builtin__) struct int2 int2;
typedef __declspec(__device_builtin__) struct uint2 uint2;
typedef __declspec(__device_builtin__) struct int3 int3;
typedef __declspec(__device_builtin__) struct uint3 uint3;
typedef __declspec(__device_builtin__) struct int4 int4;
typedef __declspec(__device_builtin__) struct uint4 uint4;
typedef __declspec(__device_builtin__) struct long1 long1;
typedef __declspec(__device_builtin__) struct ulong1 ulong1;
typedef __declspec(__device_builtin__) struct long2 long2;
typedef __declspec(__device_builtin__) struct ulong2 ulong2;
typedef __declspec(__device_builtin__) struct long3 long3;
typedef __declspec(__device_builtin__) struct ulong3 ulong3;
typedef __declspec(__device_builtin__) struct long4 long4;
typedef __declspec(__device_builtin__) struct ulong4 ulong4;
typedef __declspec(__device_builtin__) struct float1 float1;
typedef __declspec(__device_builtin__) struct float2 float2;
typedef __declspec(__device_builtin__) struct float3 float3;
typedef __declspec(__device_builtin__) struct float4 float4;
typedef __declspec(__device_builtin__) struct longlong1 longlong1;
typedef __declspec(__device_builtin__) struct ulonglong1 ulonglong1;
typedef __declspec(__device_builtin__) struct longlong2 longlong2;
typedef __declspec(__device_builtin__) struct ulonglong2 ulonglong2;
typedef __declspec(__device_builtin__) struct longlong3 longlong3;
typedef __declspec(__device_builtin__) struct ulonglong3 ulonglong3;
typedef __declspec(__device_builtin__) struct longlong4 longlong4;
typedef __declspec(__device_builtin__) struct ulonglong4 ulonglong4;
typedef __declspec(__device_builtin__) struct double1 double1;
typedef __declspec(__device_builtin__) struct double2 double2;
typedef __declspec(__device_builtin__) struct double3 double3;
typedef __declspec(__device_builtin__) struct double4 double4;







struct __declspec(__device_builtin__) dim3
{
    unsigned int x, y, z;

    __declspec(__host__) __declspec(__device__) dim3(unsigned int vx = 1, unsigned int vy = 1, unsigned int vz = 1) : x(vx), y(vy), z(vz) {}
    __declspec(__host__) __declspec(__device__) dim3(uint3 v) : x(v.x), y(v.y), z(v.z) {}
    __declspec(__host__) __declspec(__device__) operator uint3(void) { uint3 t; t.x = x; t.y = y; t.z = z; return t; }
#line 423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
};

typedef __declspec(__device_builtin__) struct dim3 dim3;



#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 68 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"













































































































































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_device_runtime_api.h"











































































#line 77 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_device_runtime_api.h"




#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 82 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_device_runtime_api.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 83 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_device_runtime_api.h"

extern "C"
{
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetAttribute(int *value, enum cudaDeviceAttr attr, int device);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetLimit(size_t *pValue, enum cudaLimit limit);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetCacheConfig(enum cudaFuncCache *pCacheConfig);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetSharedMemConfig(enum cudaSharedMemConfig *pConfig);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceSynchronize(void);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetLastError(void);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaPeekAtLastError(void);
extern __declspec(__device__) __declspec(__cudart_builtin__) const char* __stdcall cudaGetErrorString(cudaError_t error);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDeviceCount(int *count);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDevice(int *device);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t *pStream, unsigned int flags);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned int flags);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t *event, unsigned int flags);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const void *func);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaFree(void *devPtr);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMalloc(void **devPtr, size_t size);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemsetAsync(void *devPtr, int value, size_t count, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemset2DAsync(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemset3DAsync(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaRuntimeGetVersion(int *runtimeVersion);

extern __declspec(__device__) __declspec(__cudart_builtin__) void * __stdcall cudaGetParameterBuffer(size_t alignment, size_t size);
extern __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaLaunchDevice(void *func, void *parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize, cudaStream_t stream);
}
namespace {
template <typename T> __inline __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t cudaMalloc(T **devPtr, size_t size);
template <typename T> __inline __declspec(__device__) __declspec(__cudart_builtin__) cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes *attr, T *entry);
}

#line 122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_device_runtime_api.h"
#line 123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_device_runtime_api.h"

#line 125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_device_runtime_api.h"

#line 127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_device_runtime_api.h"
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"













#line 159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"

#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"



extern "C" {
#line 166 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"



























extern __declspec(__host__) cudaError_t __stdcall cudaDeviceReset(void);
















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceSynchronize(void);




















































































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceSetLimit(enum cudaLimit limit, size_t value);




























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetLimit(size_t *pValue, enum cudaLimit limit);






























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetCacheConfig(enum cudaFuncCache *pCacheConfig);


































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetStreamPriorityRange(int *leastPriority, int *greatestPriority);









































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceSetCacheConfig(enum cudaFuncCache cacheConfig);




























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetSharedMemConfig(enum cudaSharedMemConfig *pConfig);









































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceSetSharedMemConfig(enum cudaSharedMemConfig config);






















extern __declspec(__host__) cudaError_t __stdcall cudaDeviceGetByPCIBusId(int *device, char *pciBusId);


























extern __declspec(__host__) cudaError_t __stdcall cudaDeviceGetPCIBusId(char *pciBusId, int len, int device);









































extern __declspec(__host__) cudaError_t __stdcall cudaIpcGetEventHandle(cudaIpcEventHandle_t *handle, cudaEvent_t event);


































extern __declspec(__host__) cudaError_t __stdcall cudaIpcOpenEventHandle(cudaEvent_t *event, cudaIpcEventHandle_t handle);





































extern __declspec(__host__) cudaError_t __stdcall cudaIpcGetMemHandle(cudaIpcMemHandle_t *handle, void *devPtr);

















































extern __declspec(__host__) cudaError_t __stdcall cudaIpcOpenMemHandle(void **devPtr, cudaIpcMemHandle_t handle, unsigned int flags);





























extern __declspec(__host__) cudaError_t __stdcall cudaIpcCloseMemHandle(void *devPtr);

 

































extern __declspec(__host__) cudaError_t __stdcall cudaThreadExit(void);























extern __declspec(__host__) cudaError_t __stdcall cudaThreadSynchronize(void);


























































extern __declspec(__host__) cudaError_t __stdcall cudaThreadSetLimit(enum cudaLimit limit, size_t value);






























extern __declspec(__host__) cudaError_t __stdcall cudaThreadGetLimit(size_t *pValue, enum cudaLimit limit);


































extern __declspec(__host__) cudaError_t __stdcall cudaThreadGetCacheConfig(enum cudaFuncCache *pCacheConfig);













































extern __declspec(__host__) cudaError_t __stdcall cudaThreadSetCacheConfig(enum cudaFuncCache cacheConfig);

 















































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetLastError(void);








































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaPeekAtLastError(void);













extern __declspec(__host__) __declspec(__cudart_builtin__) const char* __stdcall cudaGetErrorString(cudaError_t error);
 




























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDeviceCount(int *count);






















































































































































































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDeviceProperties(struct cudaDeviceProp *prop, int device);


















































































































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaDeviceGetAttribute(int *value, enum cudaDeviceAttr attr, int device);


















extern __declspec(__host__) cudaError_t __stdcall cudaChooseDevice(int *device, const struct cudaDeviceProp *prop);

































extern __declspec(__host__) cudaError_t __stdcall cudaSetDevice(int device);
















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaGetDevice(int *device);




























extern __declspec(__host__) cudaError_t __stdcall cudaSetValidDevices(int *device_arr, int len);



























































extern __declspec(__host__) cudaError_t __stdcall cudaSetDeviceFlags( unsigned int flags );

 































extern __declspec(__host__) cudaError_t __stdcall cudaStreamCreate(cudaStream_t *pStream);




























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t *pStream, unsigned int flags);










































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamCreateWithPriority(cudaStream_t *pStream, unsigned int flags, int priority);























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamGetPriority(cudaStream_t hStream, int *priority);




















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamGetFlags(cudaStream_t hStream, unsigned int *flags);




















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream);


































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned int flags);





#line 1849 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"







typedef void (__stdcall *cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void *userData);





































extern __declspec(__host__) cudaError_t __stdcall cudaStreamAddCallback(cudaStream_t stream,
        cudaStreamCallback_t callback, void *userData, unsigned int flags);


















extern __declspec(__host__) cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t stream);

















extern __declspec(__host__) cudaError_t __stdcall cudaStreamQuery(cudaStream_t stream);

 





























extern __declspec(__host__) cudaError_t __stdcall cudaEventCreate(cudaEvent_t *event);

































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t *event, unsigned int flags);
































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0);




























extern __declspec(__host__) cudaError_t __stdcall cudaEventQuery(cudaEvent_t event);































extern __declspec(__host__) cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t event);
























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event);








































extern __declspec(__host__) cudaError_t __stdcall cudaEventElapsedTime(float *ms, cudaEvent_t start, cudaEvent_t end);

 







































extern __declspec(__host__) cudaError_t __stdcall cudaConfigureCall(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, cudaStream_t stream = 0);


























extern __declspec(__host__) cudaError_t __stdcall cudaSetupArgument(const void *arg, size_t size, size_t offset);













































extern __declspec(__host__) cudaError_t __stdcall cudaFuncSetCacheConfig(const void *func, enum cudaFuncCache cacheConfig);


















































extern __declspec(__host__) cudaError_t __stdcall cudaFuncSetSharedMemConfig(const void *func, enum cudaSharedMemConfig config);


































extern __declspec(__host__) cudaError_t __stdcall cudaLaunch(const void *func);
































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const void *func);





















extern __declspec(__host__) cudaError_t __stdcall cudaSetDoubleForDevice(double *d);





















extern __declspec(__host__) cudaError_t __stdcall cudaSetDoubleForHost(double *d);

 
































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMalloc(void **devPtr, size_t size);




























extern __declspec(__host__) cudaError_t __stdcall cudaMallocHost(void **ptr, size_t size);






































extern __declspec(__host__) cudaError_t __stdcall cudaMallocPitch(void **devPtr, size_t *pitch, size_t width, size_t height);









































extern __declspec(__host__) cudaError_t __stdcall cudaMallocArray(cudaArray_t *array, const struct cudaChannelFormatDesc *desc, size_t width, size_t height = 0, unsigned int flags = 0);























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaFree(void *devPtr);



















extern __declspec(__host__) cudaError_t __stdcall cudaFreeHost(void *ptr);





















extern __declspec(__host__) cudaError_t __stdcall cudaFreeArray(cudaArray_t array);





















extern __declspec(__host__) cudaError_t __stdcall cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray);


























































extern __declspec(__host__) cudaError_t __stdcall cudaHostAlloc(void **pHost, size_t size, unsigned int flags);




















































extern __declspec(__host__) cudaError_t __stdcall cudaHostRegister(void *ptr, size_t size, unsigned int flags);


















extern __declspec(__host__) cudaError_t __stdcall cudaHostUnregister(void *ptr);


























extern __declspec(__host__) cudaError_t __stdcall cudaHostGetDevicePointer(void **pDevice, void *pHost, unsigned int flags);


















extern __declspec(__host__) cudaError_t __stdcall cudaHostGetFlags(unsigned int *pFlags, void *pHost);


































extern __declspec(__host__) cudaError_t __stdcall cudaMalloc3D(struct cudaPitchedPtr* pitchedDevPtr, struct cudaExtent extent);






































































































































extern __declspec(__host__) cudaError_t __stdcall cudaMalloc3DArray(cudaArray_t *array, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int flags = 0);
























































































































extern __declspec(__host__) cudaError_t __stdcall cudaMallocMipmappedArray(cudaMipmappedArray_t *mipmappedArray, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int numLevels, unsigned int flags = 0);

























extern __declspec(__host__) cudaError_t __stdcall cudaGetMipmappedArrayLevel(cudaArray_t *levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned int level);
































































































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy3D(const struct cudaMemcpy3DParms *p);



























extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy3DPeer(const struct cudaMemcpy3DPeerParms *p);







































































































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream = 0);





















extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy3DPeerAsync(const struct cudaMemcpy3DPeerParms *p, cudaStream_t stream = 0);


















extern __declspec(__host__) cudaError_t __stdcall cudaMemGetInfo(size_t *free, size_t *total);




















extern __declspec(__host__) cudaError_t __stdcall cudaArrayGetInfo(struct cudaChannelFormatDesc *desc, struct cudaExtent *extent, unsigned int *flags, cudaArray_t array);


































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind);































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyPeer(void *dst, int dstDevice, const void *src, int srcDevice, size_t count);

































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind);

































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromArray(void *dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind);


































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);









































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2D(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);









































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);









































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DFromArray(void *dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind);







































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);


































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToSymbol(const void *symbol, const void *src, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyHostToDevice);


































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromSymbol(void *dst, const void *symbol, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost);









































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);






























extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyPeerAsync(void *dst, int dstDevice, const void *src, int srcDevice, size_t count, cudaStream_t stream = 0);








































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);








































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromArrayAsync(void *dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);


















































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);

















































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
















































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void *dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);









































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToSymbolAsync(const void *symbol, const void *src, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);









































extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void *dst, const void *symbol, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);

























extern __declspec(__host__) cudaError_t __stdcall cudaMemset(void *devPtr, int value, size_t count);





























extern __declspec(__host__) cudaError_t __stdcall cudaMemset2D(void *devPtr, size_t pitch, int value, size_t width, size_t height);










































extern __declspec(__host__) cudaError_t __stdcall cudaMemset3D(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent);



























extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemsetAsync(void *devPtr, int value, size_t count, cudaStream_t stream = 0);
































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemset2DAsync(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0);













































extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaMemset3DAsync(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream = 0);






















extern __declspec(__host__) cudaError_t __stdcall cudaGetSymbolAddress(void **devPtr, const void *symbol);





















extern __declspec(__host__) cudaError_t __stdcall cudaGetSymbolSize(size_t *size, const void *symbol);

 













































































































































extern __declspec(__host__) cudaError_t __stdcall cudaPointerGetAttributes(struct cudaPointerAttributes *attributes, const void *ptr);

 































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceCanAccessPeer(int *canAccessPeer, int device, int peerDevice);




































extern __declspec(__host__) cudaError_t __stdcall cudaDeviceEnablePeerAccess(int peerDevice, unsigned int flags);


















extern __declspec(__host__) cudaError_t __stdcall cudaDeviceDisablePeerAccess(int peerDevice);

 



















































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource);































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned int flags);


































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsMapResources(int count, cudaGraphicsResource_t *resources, cudaStream_t stream = 0);






























extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t *resources, cudaStream_t stream = 0);




























extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsResourceGetMappedPointer(void **devPtr, size_t *size, cudaGraphicsResource_t resource);

































extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsSubResourceGetMappedArray(cudaArray_t *array, cudaGraphicsResource_t resource, unsigned int arrayIndex, unsigned int mipLevel);
























extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t *mipmappedArray, cudaGraphicsResource_t resource);

 

































extern __declspec(__host__) cudaError_t __stdcall cudaGetChannelDesc(struct cudaChannelFormatDesc *desc, cudaArray_const_t array);


































extern __declspec(__host__) struct cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int x, int y, int z, int w, enum cudaChannelFormatKind f);














































extern __declspec(__host__) cudaError_t __stdcall cudaBindTexture(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t size = 0xffffffff);


















































extern __declspec(__host__) cudaError_t __stdcall cudaBindTexture2D(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t width, size_t height, size_t pitch);



























extern __declspec(__host__) cudaError_t __stdcall cudaBindTextureToArray(const struct textureReference *texref, cudaArray_const_t array, const struct cudaChannelFormatDesc *desc);



























extern __declspec(__host__) cudaError_t __stdcall cudaBindTextureToMipmappedArray(const struct textureReference *texref, cudaMipmappedArray_const_t mipmappedArray, const struct cudaChannelFormatDesc *desc);




















extern __declspec(__host__) cudaError_t __stdcall cudaUnbindTexture(const struct textureReference *texref);
























extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureAlignmentOffset(size_t *offset, const struct textureReference *texref);
























extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureReference(const struct textureReference **texref, const void *symbol);

 

































extern __declspec(__host__) cudaError_t __stdcall cudaBindSurfaceToArray(const struct surfaceReference *surfref, cudaArray_const_t array, const struct cudaChannelFormatDesc *desc);


















extern __declspec(__host__) cudaError_t __stdcall cudaGetSurfaceReference(const struct surfaceReference **surfref, const void *symbol);

 
















































































































































































































extern __declspec(__host__) cudaError_t __stdcall cudaCreateTextureObject(cudaTextureObject_t *pTexObject, const struct cudaResourceDesc *pResDesc, const struct cudaTextureDesc *pTexDesc, const struct cudaResourceViewDesc *pResViewDesc);














extern __declspec(__host__) cudaError_t __stdcall cudaDestroyTextureObject(cudaTextureObject_t texObject);















extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureObjectResourceDesc(struct cudaResourceDesc *pResDesc, cudaTextureObject_t texObject);















extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureObjectTextureDesc(struct cudaTextureDesc *pTexDesc, cudaTextureObject_t texObject);
















extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureObjectResourceViewDesc(struct cudaResourceViewDesc *pResViewDesc, cudaTextureObject_t texObject);

 






























extern __declspec(__host__) cudaError_t __stdcall cudaCreateSurfaceObject(cudaSurfaceObject_t *pSurfObject, const struct cudaResourceDesc *pResDesc);














extern __declspec(__host__) cudaError_t __stdcall cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject);














extern __declspec(__host__) cudaError_t __stdcall cudaGetSurfaceObjectResourceDesc(struct cudaResourceDesc *pResDesc, cudaSurfaceObject_t surfObject);

 
























extern __declspec(__host__) cudaError_t __stdcall cudaDriverGetVersion(int *driverVersion);
















extern __declspec(__host__) __declspec(__cudart_builtin__) cudaError_t __stdcall cudaRuntimeGetVersion(int *runtimeVersion);

 


extern __declspec(__host__) cudaError_t __stdcall cudaGetExportTable(const void **ppExportTable, const cudaUUID_t *pExportTableId);































































































































}
#line 5842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"



#line 5846 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"

#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"










































template<class T> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc(void)
{
  return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf1(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf2(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf4(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char>(void)
{
  int e = (int)sizeof(char) * 8;



#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"
  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<signed char>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned char>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char1>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uchar1>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char2>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uchar2>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char4>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uchar4>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned short>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short1>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ushort1>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short2>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ushort2>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short4>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ushort4>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned int>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int1>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uint1>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int2>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uint2>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int4>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uint4>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}



template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned long>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long1>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ulong1>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long2>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ulong2>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long4>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ulong4>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

#line 378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float1>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float2>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float4>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}

#line 408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"


 

#line 413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"
#line 69 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 5846 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"

#line 70 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_functions.h"




















































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 54 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 55 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 56 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_functions.h"























static __inline __declspec(__host__) struct cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
{
  struct cudaPitchedPtr s;

  s.ptr   = d;
  s.pitch = p;
  s.xsize = xsz;
  s.ysize = ysz;

  return s;
}
















static __inline __declspec(__host__) struct cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
{
  struct cudaPos p;

  p.x = x;
  p.y = y;
  p.z = z;

  return p;
}
















static __inline __declspec(__host__) struct cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
{
  struct cudaExtent e;

  e.width  = w;
  e.height = h;
  e.depth  = d;

  return e;
}

 

#line 146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_functions.h"
#line 71 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 72 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"


























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"







static __inline __declspec(__host__) __declspec(__device__) char1 make_char1(signed char x)
{
  char1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar1 make_uchar1(unsigned char x)
{
  uchar1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) char2 make_char2(signed char x, signed char y)
{
  char2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar2 make_uchar2(unsigned char x, unsigned char y)
{
  uchar2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) char3 make_char3(signed char x, signed char y, signed char z)
{
  char3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z)
{
  uchar3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) char4 make_char4(signed char x, signed char y, signed char z, signed char w)
{
  char4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w)
{
  uchar4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short1 make_short1(short x)
{
  short1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort1 make_ushort1(unsigned short x)
{
  ushort1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short2 make_short2(short x, short y)
{
  short2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort2 make_ushort2(unsigned short x, unsigned short y)
{
  ushort2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short3 make_short3(short x,short y, short z)
{ 
  short3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z)
{
  ushort3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short4 make_short4(short x, short y, short z, short w)
{
  short4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w)
{
  ushort4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int1 make_int1(int x)
{
  int1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint1 make_uint1(unsigned int x)
{
  uint1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int2 make_int2(int x, int y)
{
  int2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint2 make_uint2(unsigned int x, unsigned int y)
{
  uint2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int3 make_int3(int x, int y, int z)
{
  int3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint3 make_uint3(unsigned int x, unsigned int y, unsigned int z)
{
  uint3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int4 make_int4(int x, int y, int z, int w)
{
  int4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint4 make_uint4(unsigned int x, unsigned int y, unsigned int z, unsigned int w)
{
  uint4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long1 make_long1(long int x)
{
  long1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong1 make_ulong1(unsigned long int x)
{
  ulong1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long2 make_long2(long int x, long int y)
{
  long2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong2 make_ulong2(unsigned long int x, unsigned long int y)
{
  ulong2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long3 make_long3(long int x, long int y, long int z)
{
  long3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong3 make_ulong3(unsigned long int x, unsigned long int y, unsigned long int z)
{
  ulong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long4 make_long4(long int x, long int y, long int z, long int w)
{
  long4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong4 make_ulong4(unsigned long int x, unsigned long int y, unsigned long int z, unsigned long int w)
{
  ulong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float1 make_float1(float x)
{
  float1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float2 make_float2(float x, float y)
{
  float2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float3 make_float3(float x, float y, float z)
{
  float3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float4 make_float4(float x, float y, float z, float w)
{
  float4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong1 make_longlong1(long long int x)
{
  longlong1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong1 make_ulonglong1(unsigned long long int x)
{
  ulonglong1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong2 make_longlong2(long long int x, long long int y)
{
  longlong2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong2 make_ulonglong2(unsigned long long int x, unsigned long long int y)
{
  ulonglong2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong3 make_longlong3(long long int x, long long int y, long long int z)
{
  longlong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong3 make_ulonglong3(unsigned long long int x, unsigned long long int y, unsigned long long int z)
{
  ulonglong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong4 make_longlong4(long long int x, long long int y, long long int z, long long int w)
{
  longlong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong4 make_ulonglong4(unsigned long long int x, unsigned long long int y, unsigned long long int z, unsigned long long int w)
{
  ulonglong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double1 make_double1(double x)
{
  double1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double2 make_double2(double x, double y)
{
  double2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double3 make_double3(double x, double y, double z)
{
  double3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double4 make_double4(double x, double y, double z, double w)
{
  double4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"
#line 73 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"



#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\common_functions.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\common_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\common_functions.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"














#pragma once




#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"


extern "C" {
#line 25 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"




#line 30 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
















__declspec(dllimport) void *  __cdecl _memccpy(   void * _Dst,   const void * _Src,   int _Val,   size_t _MaxCount);
  __declspec(dllimport) const void *  __cdecl memchr(   const void * _Buf ,   int _Val,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _memicmp(  const void * _Buf1,   const void * _Buf2,   size_t _Size);
  __declspec(dllimport) int     __cdecl _memicmp_l(  const void * _Buf1,   const void * _Buf2,   size_t _Size,   _locale_t _Locale);
  int     __cdecl memcmp(  const void * _Buf1,   const void * _Buf2,   size_t _Size);

 

void *  __cdecl memcpy(  void * _Dst,   const void * _Src,   size_t _Size);

__declspec(dllimport) errno_t  __cdecl memcpy_s(  void * _Dst,   rsize_t _DstSize,   const void * _Src,   rsize_t _MaxCount);





















#line 79 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"










#line 90 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
#line 91 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
         
        
        void *  __cdecl memset(  void * _Dst,   int _Val,   size_t _Size);



 __declspec(dllimport) void * __cdecl memccpy(  void * _Dst,   const void * _Src,   int _Val,   size_t _Size);
   __declspec(dllimport) int __cdecl memicmp(  const void * _Buf1,   const void * _Buf2,   size_t _Size);
#line 100 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

#line 102 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

 __declspec(dllimport) errno_t __cdecl _strset_s(  char * _Dst,   size_t _DstSize,   int _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Dest)[_Size],   int _Value) throw() { return _strset_s(_Dest, _Size, _Value); } }
  char * __cdecl _strset( char *_Dest,  int _Value);

 __declspec(dllimport) errno_t __cdecl strcpy_s(  char * _Dst,   rsize_t _SizeInBytes,   const char * _Src);
#line 109 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Dest)[_Size],   const char * _Source) throw() { return strcpy_s(_Dest, _Size, _Source); } }
  char * __cdecl strcpy( char *_Dest,  const char * _Source);

 __declspec(dllimport) errno_t __cdecl strcat_s(  char * _Dst,   rsize_t _SizeInBytes,   const char * _Src);
#line 114 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Dest)[_Size],   const char * _Source) throw() { return strcat_s(_Dest, _Size, _Source); } }
  char * __cdecl strcat( char *_Dest,  const char * _Source);
          int     __cdecl strcmp(  const char * _Str1,   const char * _Str2);
          size_t  __cdecl strlen(  const char * _Str);
  __declspec(dllimport)


size_t  __cdecl strnlen(  const char * _Str,   size_t _MaxCount);

  static __inline


size_t  __cdecl strnlen_s(  const char * _Str,   size_t _MaxCount)
{
    return (_Str==0) ? 0 : strnlen(_Str, _MaxCount);
}
#line 131 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

 __declspec(dllimport) errno_t __cdecl memmove_s(  void * _Dst,   rsize_t _DstSize,   const void * _Src,   rsize_t _MaxCount);
#line 134 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

__declspec(dllimport)  void *  __cdecl memmove(  void * _Dst,   const void * _Src,   size_t _Size);




#line 141 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

  __declspec(dllimport) char *  __cdecl _strdup(  const char * _Src);



#line 147 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

  __declspec(dllimport) const char *  __cdecl strchr(  const char * _Str,   int _Val);
  __declspec(dllimport) int     __cdecl _stricmp(   const char * _Str1,    const char * _Str2);
  __declspec(dllimport) int     __cdecl _strcmpi(   const char * _Str1,    const char * _Str2);
  __declspec(dllimport) int     __cdecl _stricmp_l(   const char * _Str1,    const char * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int     __cdecl strcoll(   const char * _Str1,    const  char * _Str2);
  __declspec(dllimport) int     __cdecl _strcoll_l(   const char * _Str1,    const char * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int     __cdecl _stricoll(   const char * _Str1,    const char * _Str2);
  __declspec(dllimport) int     __cdecl _stricoll_l(   const char * _Str1,    const char * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int     __cdecl _strncoll  (  const char * _Str1,   const char * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _strncoll_l(  const char * _Str1,   const char * _Str2,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) int     __cdecl _strnicoll (  const char * _Str1,   const char * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _strnicoll_l(  const char * _Str1,   const char * _Str2,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) size_t  __cdecl strcspn(   const char * _Str,    const char * _Control);
   __declspec(dllimport) char *  __cdecl _strerror(  const char * _ErrMsg);
 __declspec(dllimport) errno_t __cdecl _strerror_s(  char * _Buf,   size_t _SizeInBytes,   const char * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   const char * _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
   __declspec(dllimport) char *  __cdecl strerror(  int);

 __declspec(dllimport) errno_t __cdecl strerror_s(  char * _Buf,   size_t _SizeInBytes,   int _ErrNum);
#line 168 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
 __declspec(dllimport) errno_t __cdecl _strlwr_s(  char * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
 __declspec(dllimport) char * __cdecl _strlwr( char *_String);
 __declspec(dllimport) errno_t __cdecl _strlwr_s_l(  char * _Str,   size_t _Size,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
 __declspec(dllimport) char * __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl strncat_s(  char * _Dst,   rsize_t _SizeInBytes,   const char * _Src,   rsize_t _MaxCount);
#line 178 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Dest)[_Size],   const char * _Source,   size_t _Count) throw() { return strncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable:6059)

 __declspec(dllimport) char * __cdecl strncat(  char *_Dest,   const char * _Source,   size_t _Count);
#pragma warning(pop)
  __declspec(dllimport) int     __cdecl strncmp(  const char * _Str1,   const char * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _strnicmp(  const char * _Str1,   const char * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _strnicmp_l(  const char * _Str1,   const char * _Str2,   size_t _MaxCount,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl strncpy_s(  char * _Dst,   rsize_t _SizeInBytes,   const char * _Src,   rsize_t _MaxCount);
#line 190 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Dest)[_Size],   const char * _Source,   size_t _Count) throw() { return strncpy_s(_Dest, _Size, _Source, _Count); } }
 __declspec(dllimport) char * __cdecl strncpy(    char *_Dest,   const char * _Source,   size_t _Count);
 __declspec(dllimport) errno_t __cdecl _strnset_s(  char * _Str,   size_t _SizeInBytes,   int _Val,   size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Dest)[_Size],   int _Val,   size_t _Count) throw() { return _strnset_s(_Dest, _Size, _Val, _Count); } }
 __declspec(dllimport) char * __cdecl _strnset(  char *_Dest,   int _Val,   size_t _Count);
  __declspec(dllimport) const char *  __cdecl strpbrk(  const char * _Str,   const char * _Control);
  __declspec(dllimport) const char *  __cdecl strrchr(  const char * _Str,   int _Ch);
__declspec(dllimport) char *  __cdecl _strrev(  char * _Str);
  __declspec(dllimport) size_t  __cdecl strspn(  const char * _Str,   const char * _Control);
    __declspec(dllimport) const char *  __cdecl strstr(  const char * _Str,   const char * _SubStr);
   __declspec(dllimport) char *  __cdecl strtok(  char * _Str,   const char * _Delim);

  __declspec(dllimport) char *  __cdecl strtok_s(  char * _Str,   const char * _Delim,     char ** _Context);
#line 204 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
 __declspec(dllimport) errno_t __cdecl _strupr_s(  char * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
 __declspec(dllimport) char * __cdecl _strupr( char *_String);
 __declspec(dllimport) errno_t __cdecl _strupr_s_l(  char * _Str,   size_t _Size, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size], _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
 __declspec(dllimport) char * __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
 __declspec(dllimport) size_t  __cdecl strxfrm (    char * _Dst,   const char * _Src,   size_t _MaxCount);
 __declspec(dllimport) size_t  __cdecl _strxfrm_l(    char * _Dst,   const char * _Src,   size_t _MaxCount,   _locale_t _Locale);


extern "C++" {


  inline char * __cdecl strchr(  char * _Str,   int _Ch)
	{ return (char*)strchr((const char*)_Str, _Ch); }
  inline char * __cdecl strpbrk(  char * _Str,   const char * _Control)
	{ return (char*)strpbrk((const char*)_Str, _Control); }
  inline char * __cdecl strrchr(  char * _Str,   int _Ch)
	{ return (char*)strrchr((const char*)_Str, _Ch); }
    inline char * __cdecl strstr(  char * _Str,   const char * _SubStr)
	{ return (char*)strstr((const char*)_Str, _SubStr); }
#line 226 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"


  inline void * __cdecl memchr(  void * _Pv,   int _C,   size_t _N)
	{ return (void*)memchr((const void*)_Pv, _C, _N); }
#line 231 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
}
#line 233 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"






#line 240 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

   __declspec(dllimport) char * __cdecl strdup(  const char * _Src);



#line 246 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"


   __declspec(dllimport) int __cdecl strcmpi(  const char * _Str1,   const char * _Str2);
   __declspec(dllimport) int __cdecl stricmp(  const char * _Str1,   const char * _Str2);
 __declspec(dllimport) char * __cdecl strlwr(  char * _Str);
   __declspec(dllimport) int __cdecl strnicmp(  const char * _Str1,   const char * _Str,   size_t _MaxCount);
 __declspec(dllimport) char * __cdecl strnset(  char * _Str,   int _Val,   size_t _MaxCount);
 __declspec(dllimport) char * __cdecl strrev(  char * _Str);
         char * __cdecl strset(  char * _Str,   int _Val);
 __declspec(dllimport) char * __cdecl strupr(  char * _Str);

#line 258 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"









#line 268 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

  __declspec(dllimport) wchar_t * __cdecl _wcsdup(  const wchar_t * _Str);



#line 274 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"


 __declspec(dllimport) errno_t __cdecl wcscat_s(  wchar_t * _Dst,   rsize_t _SizeInWords,   const wchar_t * _Src);
#line 278 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Dest)[_Size],   const wchar_t * _Source) throw() { return wcscat_s(_Dest, _Size, _Source); } }
 __declspec(dllimport) wchar_t * __cdecl wcscat( wchar_t *_Dest,  const wchar_t * _Source);
 

__declspec(dllimport) const wchar_t * __cdecl wcschr(  const wchar_t * _Str, wchar_t _Ch);
  __declspec(dllimport) int __cdecl wcscmp(  const wchar_t * _Str1,   const wchar_t * _Str2);

 __declspec(dllimport) errno_t __cdecl wcscpy_s(  wchar_t * _Dst,   rsize_t _SizeInWords,   const wchar_t * _Src);
#line 287 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Dest)[_Size],   const wchar_t * _Source) throw() { return wcscpy_s(_Dest, _Size, _Source); } }
 __declspec(dllimport) wchar_t * __cdecl wcscpy( wchar_t *_Dest,  const wchar_t * _Source);
  __declspec(dllimport) size_t __cdecl wcscspn(  const wchar_t * _Str,   const wchar_t * _Control);
  __declspec(dllimport) size_t __cdecl wcslen(  const wchar_t * _Str);
  __declspec(dllimport)


size_t __cdecl wcsnlen(  const wchar_t * _Src,   size_t _MaxCount);

  static __inline


size_t __cdecl wcsnlen_s(  const wchar_t * _Src,   size_t _MaxCount)
{
    return (_Src == 0) ? 0 : wcsnlen(_Src, _MaxCount);
}
#line 304 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

 __declspec(dllimport) errno_t __cdecl wcsncat_s(  wchar_t * _Dst,   rsize_t _SizeInWords,   const wchar_t * _Src,   rsize_t _MaxCount);
#line 307 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Dest)[_Size],   const wchar_t * _Source,   size_t _Count) throw() { return wcsncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable:6059)
 __declspec(dllimport) wchar_t * __cdecl wcsncat(  wchar_t *_Dest,   const wchar_t * _Source,   size_t _Count);
#pragma warning(pop)
  __declspec(dllimport) int __cdecl wcsncmp(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);

 __declspec(dllimport) errno_t __cdecl wcsncpy_s(  wchar_t * _Dst,   rsize_t _SizeInWords,   const wchar_t * _Src,   rsize_t _MaxCount);
#line 316 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Dest)[_Size],   const wchar_t * _Source,   size_t _Count) throw() { return wcsncpy_s(_Dest, _Size, _Source, _Count); } }
 __declspec(dllimport) wchar_t * __cdecl wcsncpy(    wchar_t *_Dest,   const wchar_t * _Source,   size_t _Count);
  __declspec(dllimport) const wchar_t * __cdecl wcspbrk(  const wchar_t * _Str,   const wchar_t * _Control);
  __declspec(dllimport) const wchar_t * __cdecl wcsrchr(  const wchar_t * _Str,   wchar_t _Ch);
  __declspec(dllimport) size_t __cdecl wcsspn(  const wchar_t * _Str,   const wchar_t * _Control);
   

__declspec(dllimport) const wchar_t * __cdecl wcsstr(  const wchar_t * _Str,   const wchar_t * _SubStr);
   __declspec(dllimport) wchar_t * __cdecl wcstok(  wchar_t * _Str,   const wchar_t * _Delim);

  __declspec(dllimport) wchar_t * __cdecl wcstok_s(  wchar_t * _Str,   const wchar_t * _Delim,     wchar_t ** _Context);
#line 328 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
   __declspec(dllimport) wchar_t * __cdecl _wcserror(  int _ErrNum);
 __declspec(dllimport) errno_t __cdecl _wcserror_s(  wchar_t * _Buf,   size_t _SizeInWords,   int _ErrNum);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
   __declspec(dllimport) wchar_t * __cdecl __wcserror(  const wchar_t * _Str);
 __declspec(dllimport) errno_t __cdecl __wcserror_s(  wchar_t * _Buffer,   size_t _SizeInWords,   const wchar_t * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   const wchar_t * _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }

  __declspec(dllimport) int __cdecl _wcsicmp(  const wchar_t * _Str1,   const wchar_t * _Str2);
  __declspec(dllimport) int __cdecl _wcsicmp_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wcsnicmp(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int __cdecl _wcsnicmp_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount,   _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl _wcsnset_s(  wchar_t * _Dst,   size_t _SizeInWords,   wchar_t _Val,   size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Dst)[_Size], wchar_t _Val,   size_t _MaxCount) throw() { return _wcsnset_s(_Dst, _Size, _Val, _MaxCount); } }
 __declspec(dllimport) wchar_t * __cdecl _wcsnset(  wchar_t *_Str, wchar_t _Val,   size_t _MaxCount);
__declspec(dllimport) wchar_t * __cdecl _wcsrev(  wchar_t * _Str);
 __declspec(dllimport) errno_t __cdecl _wcsset_s(  wchar_t * _Dst,   size_t _SizeInWords,   wchar_t _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_Str)[_Size], wchar_t _Val) throw() { return _wcsset_s(_Str, _Size, _Val); } }
 __declspec(dllimport) wchar_t * __cdecl _wcsset(  wchar_t *_Str, wchar_t _Val);

 __declspec(dllimport) errno_t __cdecl _wcslwr_s(  wchar_t * _Str,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
 __declspec(dllimport) wchar_t * __cdecl _wcslwr( wchar_t *_String);
 __declspec(dllimport) errno_t __cdecl _wcslwr_s_l(  wchar_t * _Str,   size_t _SizeInWords,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
 __declspec(dllimport) wchar_t * __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl _wcsupr_s(  wchar_t * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
 __declspec(dllimport) wchar_t * __cdecl _wcsupr( wchar_t *_String);
 __declspec(dllimport) errno_t __cdecl _wcsupr_s_l(  wchar_t * _Str,   size_t _Size,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
 __declspec(dllimport) wchar_t * __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
 __declspec(dllimport) size_t __cdecl wcsxfrm(    wchar_t * _Dst,   const wchar_t * _Src,   size_t _MaxCount);
 __declspec(dllimport) size_t __cdecl _wcsxfrm_l(    wchar_t * _Dst,   const wchar_t *_Src,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl wcscoll(  const wchar_t * _Str1,   const wchar_t * _Str2);
  __declspec(dllimport) int __cdecl _wcscoll_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wcsicoll(  const wchar_t * _Str1,   const wchar_t * _Str2);
  __declspec(dllimport) int __cdecl _wcsicoll_l(  const wchar_t * _Str1,   const wchar_t *_Str2,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wcsncoll(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int __cdecl _wcsncoll_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wcsnicoll(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int __cdecl _wcsnicoll_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount,   _locale_t _Locale);




extern "C++" {
 

        inline wchar_t * __cdecl wcschr(  wchar_t *_Str, wchar_t _Ch)
        {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch)); }
  inline wchar_t * __cdecl wcspbrk(  wchar_t *_Str,   const wchar_t *_Control)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_Str, _Control)); }
  inline wchar_t * __cdecl wcsrchr(  wchar_t *_Str,   wchar_t _Ch)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch)); }
   

        inline wchar_t * __cdecl wcsstr(  wchar_t *_Str,   const wchar_t *_SubStr)
        {return ((wchar_t *)wcsstr((const wchar_t *)_Str, _SubStr)); }
}
#line 388 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
#line 389 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"






#line 396 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

   __declspec(dllimport) wchar_t * __cdecl wcsdup(  const wchar_t * _Str);



#line 402 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"





   __declspec(dllimport) int __cdecl wcsicmp(  const wchar_t * _Str1,   const wchar_t * _Str2);
   __declspec(dllimport) int __cdecl wcsnicmp(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);
 __declspec(dllimport) wchar_t * __cdecl wcsnset(  wchar_t * _Str,   wchar_t _Val,   size_t _MaxCount);
 __declspec(dllimport) wchar_t * __cdecl wcsrev(  wchar_t * _Str);
 __declspec(dllimport) wchar_t * __cdecl wcsset(  wchar_t * _Str, wchar_t _Val);
 __declspec(dllimport) wchar_t * __cdecl wcslwr(  wchar_t * _Str);
 __declspec(dllimport) wchar_t * __cdecl wcsupr(  wchar_t * _Str);
   __declspec(dllimport) int __cdecl wcsicoll(  const wchar_t * _Str1,   const wchar_t * _Str2);

#line 417 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"


#line 420 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"



}
#line 425 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

#line 427 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\common_functions.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"















#pragma once




#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"



#line 26 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"






#pragma pack(push,8)


extern "C" {
#line 37 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"








#line 46 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"




































typedef long clock_t;

#line 85 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"





















struct tm {
        int tm_sec;     
        int tm_min;     
        int tm_hour;    
        int tm_mday;    
        int tm_mon;     
        int tm_year;    
        int tm_wday;    
        int tm_yday;    
        int tm_isdst;   
        };

#line 119 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"












   __declspec(dllimport) int* __cdecl __daylight(void);



   __declspec(dllimport) long* __cdecl __dstbias(void);



   __declspec(dllimport) long* __cdecl __timezone(void);



     __declspec(dllimport) char ** __cdecl __tzname(void);


__declspec(dllimport) errno_t __cdecl _get_daylight(  int * _Daylight);
__declspec(dllimport) errno_t __cdecl _get_dstbias(  long * _Daylight_savings_bias);
__declspec(dllimport) errno_t __cdecl _get_timezone(  long * _Timezone);
__declspec(dllimport) errno_t __cdecl _get_tzname(  size_t *_ReturnValue,   char *_Buffer,   size_t _SizeInBytes,   int _Index);



   __declspec(dllimport) char * __cdecl asctime(  const struct tm * _Tm);

 __declspec(dllimport) errno_t __cdecl asctime_s(    char *_Buf,   size_t _SizeInBytes,   const struct tm * _Tm);
#line 157 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(  char (&_Buffer)[_Size],   const struct tm * _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }

 __declspec(dllimport) char * __cdecl _ctime32(  const __time32_t * _Time);
__declspec(dllimport) errno_t __cdecl _ctime32_s(    char *_Buf,   size_t _SizeInBytes,   const __time32_t *_Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(  char (&_Buffer)[_Size],   const __time32_t * _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }

  __declspec(dllimport) clock_t __cdecl clock(void);
__declspec(dllimport) double __cdecl _difftime32(  __time32_t _Time1,   __time32_t _Time2);

   __declspec(dllimport) struct tm * __cdecl _gmtime32(  const __time32_t * _Time);
 __declspec(dllimport) errno_t __cdecl _gmtime32_s(  struct tm *_Tm,   const __time32_t * _Time);

 __declspec(dllimport) struct tm * __cdecl _localtime32(  const __time32_t * _Time);
__declspec(dllimport) errno_t __cdecl _localtime32_s(  struct tm *_Tm,   const __time32_t * _Time);

__declspec(dllimport) size_t __cdecl strftime(  char * _Buf,   size_t _SizeInBytes,     const char * _Format,   const struct tm * _Tm);
__declspec(dllimport) size_t __cdecl _strftime_l(    char *_Buf,   size_t _Max_size,     const char * _Format,   const struct tm *_Tm,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl _strdate_s(    char *_Buf,   size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(  char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }
 __declspec(dllimport) char * __cdecl _strdate( char *_Buffer);

 __declspec(dllimport) errno_t __cdecl _strtime_s(    char *_Buf ,   size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(  char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }
 __declspec(dllimport) char * __cdecl _strtime( char *_Buffer);

__declspec(dllimport) __time32_t __cdecl _time32(  __time32_t * _Time);
__declspec(dllimport) __time32_t __cdecl _mktime32(  struct tm * _Tm);
__declspec(dllimport) __time32_t __cdecl _mkgmtime32(  struct tm * _Tm);






__declspec(dllimport) void __cdecl _tzset(void);
#line 194 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"

#line 196 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"

  __declspec(dllimport) double __cdecl _difftime64(  __time64_t _Time1,   __time64_t _Time2);
 __declspec(dllimport) char * __cdecl _ctime64(  const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _ctime64_s(  char *_Buf,   size_t _SizeInBytes,   const __time64_t * _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(char (&_Buffer)[_Size],   const __time64_t * _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }

 __declspec(dllimport) struct tm * __cdecl _gmtime64(  const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _gmtime64_s(  struct tm *_Tm,   const __time64_t *_Time);

 __declspec(dllimport) struct tm * __cdecl _localtime64(  const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _localtime64_s(  struct tm *_Tm,   const __time64_t *_Time);

__declspec(dllimport) __time64_t __cdecl _mktime64(  struct tm * _Tm);
__declspec(dllimport) __time64_t __cdecl _mkgmtime64(  struct tm * _Tm);
__declspec(dllimport) __time64_t __cdecl _time64(  __time64_t * _Time);



__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetLocalTime" " instead. See online help for details.")) unsigned __cdecl _getsystime(  struct tm * _Tm);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetLocalTime" " instead. See online help for details.")) unsigned __cdecl _setsystime(  struct tm * _Tm, unsigned _MilliSec);
#line 217 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"










 
 __declspec(dllimport) wchar_t * __cdecl _wasctime(  const struct tm * _Tm);
__declspec(dllimport) errno_t __cdecl _wasctime_s(    wchar_t *_Buf,   size_t _SizeInWords,   const struct tm * _Tm);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   const struct tm * _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }

 __declspec(dllimport) wchar_t * __cdecl _wctime32(  const __time32_t *_Time);
__declspec(dllimport) errno_t __cdecl _wctime32_s(    wchar_t* _Buf,   size_t _SizeInWords,   const __time32_t * _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   const __time32_t * _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }

__declspec(dllimport) size_t __cdecl wcsftime(  wchar_t * _Buf,   size_t _SizeInWords,     const wchar_t * _Format,    const struct tm * _Tm);
__declspec(dllimport) size_t __cdecl _wcsftime_l(  wchar_t * _Buf,   size_t _SizeInWords,     const wchar_t *_Format,   const struct tm *_Tm,   _locale_t _Locale);

__declspec(dllimport) errno_t __cdecl _wstrdate_s(    wchar_t * _Buf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
 __declspec(dllimport) wchar_t * __cdecl _wstrdate( wchar_t *_Buffer);

__declspec(dllimport) errno_t __cdecl _wstrtime_s(    wchar_t * _Buf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
 __declspec(dllimport) wchar_t * __cdecl _wstrtime( wchar_t *_Buffer);

 __declspec(dllimport) wchar_t * __cdecl _wctime64(  const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _wctime64_s(    wchar_t* _Buf,   size_t _SizeInWords,   const __time64_t *_Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   const __time64_t * _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }


#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\wtime.inl"












#pragma once







#line 22 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\wtime.inl"





#pragma warning(push)
#pragma warning(disable:4996)















static __inline wchar_t * __cdecl _wctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _wctime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __cdecl _wctime_s(wchar_t *_Buffer, size_t _SizeInWords, const time_t * _Time)
{
    return _wctime64_s(_Buffer, _SizeInWords, _Time);
}
#line 57 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\wtime.inl"

#pragma warning(pop)

#line 61 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\wtime.inl"
#line 62 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\wtime.inl"
#line 253 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
#line 254 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"


#line 257 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"


#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.inl"












#pragma once







#line 22 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.inl"




























































static __inline double __cdecl difftime(time_t _Time1, time_t _Time2)
{
    return _difftime64(_Time1,_Time2);
}
 static __inline char * __cdecl ctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _ctime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __cdecl ctime_s(char *_Buffer, size_t _SizeInBytes, const time_t * _Time)
{
    return _ctime64_s(_Buffer, _SizeInBytes, _Time);
}
#line 99 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.inl"
 static __inline struct tm * __cdecl gmtime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _gmtime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __cdecl gmtime_s(struct tm * _Tm, const time_t * _Time)
{
    return _gmtime64_s(_Tm, _Time);
}
#line 112 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.inl"
 static __inline struct tm * __cdecl localtime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _localtime64(_Time);
#pragma warning( pop )
}
static __inline errno_t __cdecl localtime_s(struct tm * _Tm, const time_t * _Time)
{
    return _localtime64_s(_Tm, _Time);
}
static __inline time_t __cdecl mktime(struct tm * _Tm)
{
    return _mktime64(_Tm);
}
static __inline time_t __cdecl _mkgmtime(struct tm * _Tm)
{
    return _mkgmtime64(_Tm);
}
static __inline time_t __cdecl time(time_t * _Time)
{
    return _time64(_Time);
}
#line 136 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.inl"


#line 139 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.inl"
#line 140 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.inl"
#line 260 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
#line 261 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"













 __declspec(dllimport) extern int daylight;
 __declspec(dllimport) extern long timezone;
 __declspec(dllimport) extern char * tzname[2];
#line 278 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"


 __declspec(dllimport) void __cdecl tzset(void);
#line 282 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"

#line 284 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"



}
#line 289 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"

#pragma pack(pop)

#line 293 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\common_functions.h"

extern "C"
{
extern __declspec(dllimport) __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) clock_t __cdecl clock(void) ;
extern         __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) void*   __cdecl memset(void*, int, size_t) ;
extern         __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) void*   __cdecl memcpy(void*, const void*, size_t) ;
}

















































































#line 155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\common_functions.h"

#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\common_functions.h"








#line 166 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\common_functions.h"

#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"


















































































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 85 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"







extern "C"
{














































#line 141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) int            __cdecl abs(int) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) long int       __cdecl labs(long int) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) long long int          llabs(long long int) ;
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"









































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl fabs(double x) ;








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fabsf(float x) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    min(int, int);
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) unsigned int           umin(unsigned int, unsigned int);
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llmin(long long int, long long int);
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) unsigned long long int ullmin(unsigned long long int, unsigned long long int);















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fminf(float x, float y) ;















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 fmin(double x, double y) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    max(int, int);
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) unsigned int           umax(unsigned int, unsigned int);
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llmax(long long int, long long int);
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) unsigned long long int ullmax(unsigned long long int, unsigned long long int);















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fmaxf(float x, float y) ;















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 fmax(double, double) ;








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl sin(double x) ;
































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl cos(double x) ;














extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) void                   sincos(double x, double *sptr, double *cptr) ;















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) void                   sincosf(float x, float *sptr, float *cptr) ;








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl tan(double x) ;




































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl sqrt(double x) ;




































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 rsqrt(double x);




































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  rsqrtf(float x);


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 log2(double x) ;




















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 exp2(double x) ;




















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  exp2f(float x) ;



















         
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 exp10(double x) ;





















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  exp10f(float x) ;








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 expm1(double x) ;








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  expm1f(float x) ;        


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  log2f(float x) ;         


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl log10(double x) ;






































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl log(double x) ;




























































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 log1p(double x) ;




























































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  log1pf(float x) ;







































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl floor(double x) ;






































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl exp(double x) ;






























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl cosh(double x) ;





























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl sinh(double x) ;





























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl tanh(double x) ;

































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 acosh(double x) ;

































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  acoshf(float x) ;











extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 asinh(double x) ;











extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  asinhf(float x) ;

















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 atanh(double x) ;

















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  atanhf(float x) ;























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl ldexp(double x, int exp) ;























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  ldexpf(float x, int exp) ;


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 logb(double x) ;


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  logbf(float x) ;

























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    ilogb(double x) ;

























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    ilogbf(float x) ;







































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 scalbn(double x, int n) ;







































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  scalbnf(float x, int n) ;







































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 scalbln(double x, long int n) ;







































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  scalblnf(float x, long int n) ;










































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl frexp(double x, int *nptr) ;










































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  frexpf(float x, int *nptr) ;












extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 round(double x) ;












extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  roundf(float x) ;













extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long int               lround(double x) ;













extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long int               lroundf(float x) ;













extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llround(double x) ;













extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llroundf(float x) ;










extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 rint(double x) ;










extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  rintf(float x) ;











extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long int               lrint(double x) ;











extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long int               lrintf(float x) ;











extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llrint(double x) ;











extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) long long int          llrintf(float x) ;
















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 nearbyint(double x) ;
















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  nearbyintf(float x) ;


























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl ceil(double x) ;










extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 trunc(double x) ;










extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  truncf(float x) ;





















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 fdim(double x, double y) ;





















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fdimf(float x, float y) ;
































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl atan2(double x, double y) ;






























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl atan(double x) ;






















extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl acos(double x) ;































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl asin(double x) ;








































#line 2863 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
static __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double       __cdecl hypot(double x, double y) ;
#line 2865 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"








































#line 2906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
static __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float        __cdecl hypotf(float x, float y) ;
#line 2908 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"

















































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 cbrt(double x) ;

















































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  cbrtf(float x) ;
















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 rcbrt(double x);
















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  rcbrtf(float x);



























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 sinpi(double x);



























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  sinpif(float x);



















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 cospi(double x);



















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  cospif(float x);





























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) void                   sincospi(double x, double *sptr, double *cptr);





























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) void                   sincospif(float x, float *sptr, float *cptr);



















































































































































































































































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl pow(double x, double y) ;























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl modf(double x, double *iptr) ;


























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double         __cdecl fmod(double x, double y) ;




















































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 remainder(double x, double y) ;





















































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  remainderf(float x, float y) ;

















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 remquo(double x, double y, int *quo) ;

















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  remquof(float x, float y, int *quo) ;





































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl j0(double x) ;





































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  j0f(float x) ;
























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl j1(double x) ;
























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  j1f(float x) ;






































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl jn(int n, double x) ;






































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  jnf(int n, float x) ;















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl y0(double x) ;















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  y0f(float x) ;















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl y1(double x) ;















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  y1f(float x) ;
















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) __declspec(dllimport) double __cdecl yn(int n, double x) ;
















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  ynf(int n, float x) ;













































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erf(double x) ;













































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erff(float x) ;
























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erfinv(double y);
























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erfinvf(float y);

































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erfc(double x) ;

































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erfcf(float x) ;



























































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 lgamma(double x) ;























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erfcinv(double y);























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erfcinvf(float y);

























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 normcdfinv(double y);

























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  normcdfinvf(float y);










































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 normcdf(double y);










































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  normcdff(float y);










































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 erfcx(double x);










































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  erfcxf(float x);
































































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  lgammaf(float x) ;








































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 tgamma(double x) ;








































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  tgammaf(float x) ;








extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 copysign(double x, double y) ;








extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  copysignf(float x, float y) ;
































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 nextafter(double x, double y) ;
































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  nextafterf(float x, float y) ;











extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 nan(const char *tagp) ;











extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  nanf(const char *tagp) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isinff(float) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isnanf(float) ;







#line 6089 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __finite(double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __finitef(float) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __signbit(double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isnan(double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isinf(double) ;
#line 6095 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"

extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __signbitf(float) ;

























































































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) double                 fma(double x, double y, double z) ;

























































































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fmaf(float x, float y, float z) ;




extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __signbitl(long double) ;




#line 6415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __finitel(long double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isinfl(long double) ;
extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) int                    __isnanl(long double) ;
#line 6419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"





















#line 6441 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  acosf(float x) ;







































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  asinf(float x) ;







































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  atanf(float x) ;
































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  atan2f(float x, float y) ;























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  cosf(float x) ;









































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  sinf(float x) ;









































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  tanf(float x) ;























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  coshf(float x) ;








































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  sinhf(float x) ;





























extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  tanhf(float x) ;


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  logf(float x) ;

















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  expf(float x) ;


















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  log10f(float x) ;






















































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  modff(float x, float *iptr) ;



















































































































































































































































































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  powf(float x, float y) ;




































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  sqrtf(float x) ;         


























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  ceilf(float x) ;







































































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  floorf(float x) ;


























































extern __declspec(__host__) __declspec(__device__) __declspec(__device_builtin__) float                  fmodf(float x, float y) ;
#line 7556 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"

}

#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

















#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 19 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"





#pragma pack(push,8)


extern "C" {
#line 29 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"








struct _exception {
        int type;       
        char *name;     
        double arg1;    
        double arg2;    
        double retval;  
        } ;


#line 47 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"







struct _complex {
        double x,y; 
        } ;




#line 62 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"


#line 65 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
#line 66 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"






















__declspec(dllimport) extern double _HUGE;


#line 92 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
#line 93 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"








        int     __cdecl abs(  int _X);
        long    __cdecl labs(  long _X);
        long long __cdecl llabs(  long long _X);
#line 105 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

        double  __cdecl acos(  double _X);
        double  __cdecl asin(  double _X);
        double  __cdecl atan(  double _X);
        double  __cdecl atan2(  double _Y,   double _X);

  __declspec(dllimport) double __cdecl _copysign (  double _Number,   double _Sign);
  __declspec(dllimport) double __cdecl _chgsign (  double _X);

#line 115 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
        double  __cdecl cos(  double _X);
        double  __cdecl cosh(  double _X);
        double  __cdecl exp(  double _X);
 double  __cdecl fabs(  double _X);
        double  __cdecl fmod(  double _X,   double _Y);
        double  __cdecl log(  double _X);
        double  __cdecl log10(  double _X);
        double  __cdecl pow(  double _X,   double _Y);
        double  __cdecl sin(  double _X);
        double  __cdecl sinh(  double _X);
        double  __cdecl tan(  double _X);
        double  __cdecl tanh(  double _X);
  double  __cdecl sqrt(  double _X);


  __declspec(dllimport) double  __cdecl atof(  const char *_String);
  __declspec(dllimport) double  __cdecl _atof_l(  const char *_String,   _locale_t _Locale);
#line 133 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

__declspec(dllimport) double  __cdecl _cabs(  struct _complex _Complex_value);
__declspec(dllimport) double  __cdecl ceil(  double _X);
__declspec(dllimport) double  __cdecl floor(  double _X);
__declspec(dllimport) double  __cdecl frexp(  double _X,   int * _Y);
__declspec(dllimport) double  __cdecl _hypot(  double _X,   double _Y);
__declspec(dllimport) float   __cdecl _hypotf(  float _X,   float _Y);
__declspec(dllimport) double  __cdecl _j0(  double _X );
__declspec(dllimport) double  __cdecl _j1(  double _X );
__declspec(dllimport) double  __cdecl _jn(int _X,   double _Y);
__declspec(dllimport) double  __cdecl ldexp(  double _X,   int _Y);




#line 149 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
        int     __cdecl _matherr(  struct _exception * _Except);
#line 151 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
#line 152 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
__declspec(dllimport) double  __cdecl modf(  double _X,   double * _Y);

__declspec(dllimport) double  __cdecl _y0(  double _X);
__declspec(dllimport) double  __cdecl _y1(  double _X);
__declspec(dllimport) double  __cdecl _yn(  int _X,   double _Y);




static __inline double __cdecl hypot(  double _X,   double _Y)
{
    return _hypot(_X, _Y);
}

static __inline float __cdecl hypotf(  float _X,   float _Y)
{
    return _hypotf(_X, _Y);
}

#line 172 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"



__declspec(dllimport) int     __cdecl _set_SSE2_enable(  int _Flag);

#line 178 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"











































#line 222 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"








































#line 263 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"


































































inline long double acosl(  long double _X)
        {return (acos((double)_X)); }
inline long double asinl(  long double _X)
        {return (asin((double)_X)); }
inline long double atanl(  long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(  long double _Y,   long double _X)
        {return (atan2((double)_Y, (double)_X)); }
inline long double ceill(  long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(  long double _X)
        {return (cos((double)_X)); }
inline long double coshl(  long double _X)
        {return (cosh((double)_X)); }
inline long double expl(  long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(  long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(  long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(  long double _X,   long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(  long double _X,   int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(  long double _X,   int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(  long double _X)
        {return (log((double)_X)); }
inline long double log10l(  long double _X)
        {return (log10((double)_X)); }
inline long double modfl(  long double _X,   long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(  long double _X,   long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(  long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(  long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(  long double _X)
        {return (sqrt((double)_X)); }
inline long double tanl(  long double _X)
        {return (tan((double)_X)); }

inline long double tanhl(  long double _X)
        {return (tanh((double)_X)); }

inline long double _chgsignl(  long double _Number)
{
    return _chgsign(static_cast<double>(_Number)); 
}

inline long double _copysignl(  long double _Number,   long double _Sign)
{
    return _copysign(static_cast<double>(_Number), static_cast<double>(_Sign)); 
}

inline float frexpf(  float _X,   int *_Y)
        {return ((float)frexp((double)_X, _Y)); }


inline float fabsf(  float _X)
        {return ((float)fabs((double)_X)); }
#line 394 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

inline float ldexpf(  float _X,   int _Y)
        {return ((float)ldexp((double)_X, _Y)); }


inline float acosf(  float _X)
        {return ((float)acos((double)_X)); }
inline float asinf(  float _X)
        {return ((float)asin((double)_X)); }
inline float atanf(  float _X)
        {return ((float)atan((double)_X)); }
inline float atan2f(  float _Y,   float _X)
        {return ((float)atan2((double)_Y, (double)_X)); }
inline float ceilf(  float _X)
        {return ((float)ceil((double)_X)); }
inline float cosf(  float _X)
        {return ((float)cos((double)_X)); }
inline float coshf(  float _X)
        {return ((float)cosh((double)_X)); }
inline float expf(  float _X)
        {return ((float)exp((double)_X)); }
inline float floorf(  float _X)
        {return ((float)floor((double)_X)); }
inline float fmodf(  float _X,   float _Y)
        {return ((float)fmod((double)_X, (double)_Y)); }
inline float logf(  float _X)
        {return ((float)log((double)_X)); }
inline float log10f(  float _X)
        {return ((float)log10((double)_X)); }
inline float modff(  float _X,   float *_Y)
        { double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (float)_Di;
        return ((float)_Df); }
inline float powf(  float _X,   float _Y)
        {return ((float)pow((double)_X, (double)_Y)); }
inline float sinf(  float _X)
        {return ((float)sin((double)_X)); }
inline float sinhf(  float _X)
        {return ((float)sinh((double)_X)); }
inline float sqrtf(  float _X)
        {return ((float)sqrt((double)_X)); }
inline float tanf(  float _X)
        {return ((float)tan((double)_X)); }
inline float tanhf(  float _X)
        {return ((float)tanh((double)_X)); }
#line 440 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
#line 441 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
#line 442 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

















__declspec(dllimport) extern double HUGE;


#line 463 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

 __declspec(dllimport) double  __cdecl cabs(  struct _complex _X);
 __declspec(dllimport) double  __cdecl j0(  double _X);
 __declspec(dllimport) double  __cdecl j1(  double _X);
 __declspec(dllimport) double  __cdecl jn(  int _X,   double _Y);
 __declspec(dllimport) double  __cdecl y0(  double _X);
 __declspec(dllimport) double  __cdecl y1(  double _X);
 __declspec(dllimport) double  __cdecl yn(  int _X,   double _Y);

#line 473 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

#line 475 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"


}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = (unsigned int)_Y;
        else
                _N = (unsigned int)(-_Y);
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

inline double __cdecl abs(  double _X)
        {return (fabs(_X)); }
inline double __cdecl pow(  double _X,   int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs(  float _X)
        {return (fabsf(_X)); }
inline float __cdecl acos(  float _X)
        {return (acosf(_X)); }
inline float __cdecl asin(  float _X)
        {return (asinf(_X)); }
inline float __cdecl atan(  float _X)
        {return (atanf(_X)); }
inline float __cdecl atan2(  float _Y,   float _X)
        {return (atan2f(_Y, _X)); }
inline float __cdecl ceil(  float _X)
        {return (ceilf(_X)); }
inline float __cdecl cos(  float _X)
        {return (cosf(_X)); }
inline float __cdecl cosh(  float _X)
        {return (coshf(_X)); }
inline float __cdecl exp(  float _X)
        {return (expf(_X)); }
inline float __cdecl fabs(  float _X)
        {return (fabsf(_X)); }
inline float __cdecl floor(  float _X)
        {return (floorf(_X)); }
inline float __cdecl fmod(  float _X,   float _Y)
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp(  float _X,   int * _Y)
        {return (frexpf(_X, _Y)); }
inline float __cdecl ldexp(  float _X,   int _Y)
        {return (ldexpf(_X, _Y)); }
inline float __cdecl log(  float _X)
        {return (logf(_X)); }
inline float __cdecl log10(  float _X)
        {return (log10f(_X)); }
inline float __cdecl modf(  float _X,   float * _Y)
        {return (modff(_X, _Y)); }
inline float __cdecl pow(  float _X,   float _Y)
        {return (powf(_X, _Y)); }
inline float __cdecl pow(  float _X,   int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl sin(  float _X)
        {return (sinf(_X)); }
inline float __cdecl sinh(  float _X)
        {return (sinhf(_X)); }
inline float __cdecl sqrt(  float _X)
        {return (sqrtf(_X)); }
inline float __cdecl tan(  float _X)
        {return (tanf(_X)); }
inline float __cdecl tanh(  float _X)
        {return (tanhf(_X)); }
inline long double __cdecl abs(  long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl acos(  long double _X)
        {return (acosl(_X)); }
inline long double __cdecl asin(  long double _X)
        {return (asinl(_X)); }
inline long double __cdecl atan(  long double _X)
        {return (atanl(_X)); }
inline long double __cdecl atan2(  long double _Y,   long double _X)
        {return (atan2l(_Y, _X)); }
inline long double __cdecl ceil(  long double _X)
        {return (ceill(_X)); }
inline long double __cdecl cos(  long double _X)
        {return (cosl(_X)); }
inline long double __cdecl cosh(  long double _X)
        {return (coshl(_X)); }
inline long double __cdecl exp(  long double _X)
        {return (expl(_X)); }
inline long double __cdecl fabs(  long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl floor(  long double _X)
        {return (floorl(_X)); }
inline long double __cdecl fmod(  long double _X,   long double _Y)
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp(  long double _X,   int * _Y)
        {return (frexpl(_X, _Y)); }
inline long double __cdecl ldexp(  long double _X,   int _Y)
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl log(  long double _X)
        {return (logl(_X)); }
inline long double __cdecl log10(  long double _X)
        {return (log10l(_X)); }
inline long double __cdecl modf(  long double _X,   long double * _Y)
        {return (modfl(_X, _Y)); }
inline long double __cdecl pow(  long double _X,   long double _Y)
        {return (powl(_X, _Y)); }
inline long double __cdecl pow(  long double _X,   int _Y)
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl sin(  long double _X)
        {return (sinl(_X)); }
inline long double __cdecl sinh(  long double _X)
        {return (sinhl(_X)); }
inline long double __cdecl sqrt(  long double _X)
        {return (sqrtl(_X)); }
inline long double __cdecl tan(  long double _X)
        {return (tanl(_X)); }
inline long double __cdecl tanh(  long double _X)
        {return (tanhl(_X)); }

}
#line 597 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

#pragma pack(pop)

#line 601 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"







































#line 641 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

#line 7560 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"















#pragma once




#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"






#pragma pack(push,8)


extern "C" {
#line 33 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"



















typedef int (__cdecl * _onexit_t)(void);



#line 57 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"



#line 61 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"




#line 66 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"


#line 69 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"






typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

typedef struct _lldiv_t {
        long long quot;
        long long rem;
} lldiv_t;


#line 92 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"










#pragma pack(4)
typedef struct {
    unsigned char ld[10];
} _LDOUBLE;
#pragma pack()













#line 121 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

typedef struct {
        double x;
} _CRT_DOUBLE;

typedef struct {
    float f;
} _CRT_FLOAT;





typedef struct {
        


        long double x;
} _LONGDOUBLE;



#pragma pack(4)
typedef struct {
    unsigned char ld12[12];
} _LDBL12;
#pragma pack()


#line 151 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"












__declspec(dllimport) extern int __mb_cur_max;



#line 168 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
__declspec(dllimport) int __cdecl ___mb_cur_max_func(void);
__declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t);
#line 171 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"





































typedef void (__cdecl *_purecall_handler)(void); 


__declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(  _purecall_handler _Handler);
__declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(void);
#line 214 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"


extern "C++"
{




#line 223 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
}
#line 225 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"



typedef void (__cdecl *_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); 


__declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(  _invalid_parameter_handler _Handler);
__declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);
#line 234 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"











__declspec(dllimport) unsigned long * __cdecl __doserrno(void);


errno_t __cdecl _set_doserrno(  unsigned long _Value);
errno_t __cdecl _get_doserrno(  unsigned long * _Value);


__declspec(dllimport)  char ** __cdecl __sys_errlist(void);


__declspec(dllimport)  int * __cdecl __sys_nerr(void);





__declspec(dllimport) int *          __cdecl __p___argc(void);
__declspec(dllimport) char ***       __cdecl __p___argv(void);
__declspec(dllimport) wchar_t ***    __cdecl __p___wargv(void);
__declspec(dllimport) char ***       __cdecl __p__environ(void);
__declspec(dllimport) wchar_t ***    __cdecl __p__wenviron(void);
#line 267 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

__declspec(dllimport) char **        __cdecl __p__pgmptr(void);
__declspec(dllimport) wchar_t **     __cdecl __p__wpgmptr(void);


#line 273 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"




__declspec(dllimport) extern int __argc;          
__declspec(dllimport) extern char ** __argv;      
__declspec(dllimport) extern wchar_t ** __wargv;  







#line 288 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 290 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"








__declspec(dllimport) extern char ** _environ;    
__declspec(dllimport) extern wchar_t ** _wenviron;    
#line 301 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 303 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) extern char * _pgmptr;      
 __declspec(dllimport) extern wchar_t * _wpgmptr;  




















#line 327 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

errno_t __cdecl _get_pgmptr(  char ** _Value);
errno_t __cdecl _get_wpgmptr(  wchar_t ** _Value);



 __declspec(dllimport) extern int _fmode;          



#line 338 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

__declspec(dllimport) errno_t __cdecl _set_fmode(  int _Mode);
__declspec(dllimport) errno_t __cdecl _get_fmode(  int * _PMode);





#line 347 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

}
#line 354 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
#line 355 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"





__declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
#line 364 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(  unsigned int _Flags,   unsigned int _Mask);








        __int64    __cdecl _abs64(__int64);




















#line 396 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"















#line 412 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
        int    __cdecl atexit(void (__cdecl *)(void));
#line 414 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"





  __declspec(dllimport)  int    __cdecl atoi(  const char *_Str);
  __declspec(dllimport) int    __cdecl _atoi_l(  const char *_Str,   _locale_t _Locale);
  __declspec(dllimport) long   __cdecl atol(  const char *_Str);
  __declspec(dllimport) long   __cdecl _atol_l(  const char *_Str,   _locale_t _Locale);



  __declspec(dllimport) void * __cdecl bsearch_s(  const void * _Key,   const void * _Base, 
          rsize_t _NumOfElements,   rsize_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#line 430 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
  __declspec(dllimport) void * __cdecl bsearch(  const void * _Key,   const void * _Base, 
          size_t _NumOfElements,   size_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(const void *, const void *));


__declspec(dllimport) void __cdecl qsort_s(  void * _Base, 
          rsize_t _NumOfElements,   rsize_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void *_Context);
#line 439 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
__declspec(dllimport) void __cdecl qsort(  void * _Base, 
	  size_t _NumOfElements,   size_t _SizeOfElements, 
          int (__cdecl * _PtFuncCompare)(const void *, const void *));
#line 443 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
          unsigned short __cdecl _byteswap_ushort(  unsigned short _Short);
          unsigned long  __cdecl _byteswap_ulong (  unsigned long _Long);
          unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Int64);
  __declspec(dllimport) div_t  __cdecl div(  int _Numerator,   int _Denominator);


  __declspec(dllimport)  char * __cdecl getenv(  const char * _VarName);

 __declspec(dllimport) errno_t __cdecl getenv_s(  size_t * _ReturnSize,   char * _DstBuf,   rsize_t _DstSize,   const char * _VarName);
#line 453 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t * _ReturnSize, char (&_Dest)[_Size],   const char * _VarName) throw() { return getenv_s(_ReturnSize, _Dest, _Size, _VarName); } }



#line 458 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _dupenv_s(    char **_PBuffer,   size_t * _PBufferSizeInBytes,   const char * _VarName);



#line 464 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
#line 465 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _itoa_s(  int _Value,   char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(  int _Value, char (&_Dest)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Dest, _Size, _Radix); } }
 __declspec(dllimport) char * __cdecl _itoa( int _Value,   char *_Dest,  int _Radix);
 __declspec(dllimport) errno_t __cdecl _i64toa_s(  __int64 _Val,   char * _DstBuf,   size_t _Size,   int _Radix);
__declspec(dllimport)  char * __cdecl _i64toa(  __int64 _Val,     char * _DstBuf,   int _Radix);
 __declspec(dllimport) errno_t __cdecl _ui64toa_s(  unsigned __int64 _Val,   char * _DstBuf,   size_t _Size,   int _Radix);
__declspec(dllimport)  char * __cdecl _ui64toa(  unsigned __int64 _Val,     char * _DstBuf,   int _Radix);
  __declspec(dllimport) __int64 __cdecl _atoi64(  const char * _String);
  __declspec(dllimport) __int64 __cdecl _atoi64_l(  const char * _String,   _locale_t _Locale);
  __declspec(dllimport) __int64 __cdecl _strtoi64(  const char * _String,     char ** _EndPtr,   int _Radix);
  __declspec(dllimport) __int64 __cdecl _strtoi64_l(  const char * _String,     char ** _EndPtr,   int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned __int64 __cdecl _strtoui64(  const char * _String,     char ** _EndPtr,   int _Radix);
  __declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(  const char * _String,     char ** _EndPtr,   int  _Radix,   _locale_t _Locale);
  __declspec(dllimport) ldiv_t __cdecl ldiv(  long _Numerator,   long _Denominator);
  __declspec(dllimport) lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);

extern "C++"
{
    inline long abs(long _X)
    {
        return labs(_X);
    }
    inline long long abs(long long _X)
    {
        return llabs(_X);
    }
    inline ldiv_t div(long _A1, long _A2)
    {
        return ldiv(_A1, _A2);
    }
    inline lldiv_t div(long long _A1, long long _A2)
    {
        return lldiv(_A1, _A2);
    }
}
#line 502 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
 __declspec(dllimport) errno_t __cdecl _ltoa_s(  long _Val,   char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Dest)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Dest, _Size, _Radix); } }
 __declspec(dllimport) char * __cdecl _ltoa( long _Value,   char *_Dest,  int _Radix);
  __declspec(dllimport) int    __cdecl mblen(    const char * _Ch,   size_t _MaxCount);
  __declspec(dllimport) int    __cdecl _mblen_l(    const char * _Ch,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) size_t __cdecl _mbstrlen(  const char * _Str);
  __declspec(dllimport) size_t __cdecl _mbstrlen_l(  const char *_Str,   _locale_t _Locale);
  __declspec(dllimport) size_t __cdecl _mbstrnlen(  const char *_Str,   size_t _MaxCount);
  __declspec(dllimport) size_t __cdecl _mbstrnlen_l(  const char *_Str,   size_t _MaxCount,   _locale_t _Locale);
__declspec(dllimport) int    __cdecl mbtowc(    wchar_t * _DstCh,     const char * _SrcCh,   size_t _SrcSizeInBytes);
__declspec(dllimport) int    __cdecl _mbtowc_l(    wchar_t * _DstCh,     const char * _SrcCh,   size_t _SrcSizeInBytes,   _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl mbstowcs_s(  size_t * _PtNumOfCharConverted,   wchar_t * _DstBuf,   size_t _SizeInWords,   const char * _SrcBuf,   size_t _MaxCount );
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t * _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   const char * _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
 __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest,  const char * _Source,  size_t _MaxCount);

 __declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(  size_t * _PtNumOfCharConverted,   wchar_t * _DstBuf,   size_t _SizeInWords,   const char * _SrcBuf,   size_t _MaxCount,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t * _PtNumOfCharConverted, wchar_t (&_Dest)[_Size],   const char * _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
 __declspec(dllimport) size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   const char * _Source,   size_t _MaxCount,   _locale_t _Locale);

  __declspec(dllimport) int    __cdecl rand(void);


#line 525 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) int    __cdecl _set_error_mode(  int _Mode);

__declspec(dllimport) void   __cdecl srand(  unsigned int _Seed);
  __declspec(dllimport) double __cdecl strtod(  const char * _Str,     char ** _EndPtr);
  __declspec(dllimport) double __cdecl _strtod_l(  const char * _Str,     char ** _EndPtr,   _locale_t _Locale);
  __declspec(dllimport) long   __cdecl strtol(  const char * _Str,     char ** _EndPtr,   int _Radix );
  __declspec(dllimport) long   __cdecl _strtol_l(  const char *_Str,     char **_EndPtr,   int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned long __cdecl strtoul(  const char * _Str,     char ** _EndPtr,   int _Radix);
  __declspec(dllimport) unsigned long __cdecl _strtoul_l(const char * _Str,     char **_EndPtr,   int _Radix,   _locale_t _Locale);




__declspec(dllimport) int __cdecl system(  const char * _Command);
#line 541 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
#line 542 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _ultoa_s(  unsigned long _Val,   char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Dest)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Dest, _Size, _Radix); } }
 __declspec(dllimport) char * __cdecl _ultoa( unsigned long _Value,   char *_Dest,  int _Radix);
__declspec(dllimport)  int    __cdecl wctomb(  char * _MbCh,   wchar_t _WCh);
__declspec(dllimport)  int    __cdecl _wctomb_l(    char * _MbCh,   wchar_t _WCh,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl wctomb_s(  int * _SizeConverted,   char * _MbCh,   rsize_t _SizeInBytes,   wchar_t _WCh);
#line 551 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
 __declspec(dllimport) errno_t __cdecl _wctomb_s_l(  int * _SizeConverted,   char * _MbCh,   size_t _SizeInBytes,   wchar_t _WCh,   _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl wcstombs_s(  size_t * _PtNumOfCharConverted,   char * _Dst,   size_t _DstSizeInBytes,   const wchar_t * _Src,   size_t _MaxCountInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t * _PtNumOfCharConverted,   char (&_Dest)[_Size],   const wchar_t * _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
 __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest,  const wchar_t * _Source,  size_t _MaxCount);
 __declspec(dllimport) errno_t __cdecl _wcstombs_s_l(  size_t * _PtNumOfCharConverted,   char * _Dst,   size_t _DstSizeInBytes,   const wchar_t * _Src,   size_t _MaxCountInBytes,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t * _PtNumOfCharConverted,   char (&_Dest)[_Size],   const wchar_t * _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
 __declspec(dllimport) size_t __cdecl _wcstombs_l(  char *_Dest,   const wchar_t * _Source,   size_t _MaxCount,   _locale_t _Locale);

























#line 584 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"


































#line 619 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
      __declspec(dllimport)  __declspec(noalias) __declspec(restrict)    void * __cdecl calloc(  size_t _Count,   size_t _Size);
__declspec(dllimport)                     __declspec(noalias)                                                                             void   __cdecl free(    void * _Memory);
      __declspec(dllimport)  __declspec(noalias) __declspec(restrict)                              void * __cdecl malloc(  size_t _Size);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                           void * __cdecl realloc(    void * _Memory,   size_t _NewSize);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _recalloc(    void * _Memory,   size_t _Count,   size_t _Size);
__declspec(dllimport)                     __declspec(noalias)                                                                             void   __cdecl _aligned_free(    void * _Memory);
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_malloc(  size_t _Size,   size_t _Alignment);
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_offset_malloc(  size_t _Size,   size_t _Alignment,   size_t _Offset);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_realloc(    void * _Memory,   size_t _NewSize,   size_t _Alignment);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _aligned_recalloc(    void * _Memory,   size_t _Count,   size_t _Size,   size_t _Alignment);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_offset_realloc(    void * _Memory,   size_t _NewSize,   size_t _Alignment,   size_t _Offset);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _aligned_offset_recalloc(    void * _Memory,   size_t _Count,   size_t _Size,   size_t _Alignment,   size_t _Offset);
  __declspec(dllimport)                                                  size_t __cdecl _aligned_msize(  void * _Memory,   size_t _Alignment,   size_t _Offset);


















#line 657 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 659 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"





 __declspec(dllimport) errno_t __cdecl _itow_s (  int _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Dest)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Dest, _Size, _Radix); } }
 __declspec(dllimport) wchar_t * __cdecl _itow( int _Value,   wchar_t *_Dest,  int _Radix);
 __declspec(dllimport) errno_t __cdecl _ltow_s (  long _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Dest)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Dest, _Size, _Radix); } }
 __declspec(dllimport) wchar_t * __cdecl _ltow( long _Value,   wchar_t *_Dest,  int _Radix);
 __declspec(dllimport) errno_t __cdecl _ultow_s (  unsigned long _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Dest)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Dest, _Size, _Radix); } }
 __declspec(dllimport) wchar_t * __cdecl _ultow( unsigned long _Value,   wchar_t *_Dest,  int _Radix);
  __declspec(dllimport) double __cdecl wcstod(  const wchar_t * _Str,     wchar_t ** _EndPtr);
  __declspec(dllimport) double __cdecl _wcstod_l(  const wchar_t *_Str,     wchar_t ** _EndPtr,   _locale_t _Locale);
  __declspec(dllimport) long   __cdecl wcstol(  const wchar_t *_Str,     wchar_t ** _EndPtr, int _Radix);
  __declspec(dllimport) long   __cdecl _wcstol_l(  const wchar_t *_Str,     wchar_t **_EndPtr, int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned long __cdecl wcstoul(  const wchar_t *_Str,     wchar_t ** _EndPtr, int _Radix);
  __declspec(dllimport) unsigned long __cdecl _wcstoul_l(  const wchar_t *_Str,     wchar_t **_EndPtr, int _Radix,   _locale_t _Locale);



  __declspec(dllimport)  wchar_t * __cdecl _wgetenv(  const wchar_t * _VarName);
 __declspec(dllimport) errno_t __cdecl _wgetenv_s(  size_t * _ReturnSize,   wchar_t * _DstBuf,   size_t _DstSizeInWords,   const wchar_t * _VarName);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(  size_t * _ReturnSize, wchar_t (&_Dest)[_Size],   const wchar_t * _VarName) throw() { return _wgetenv_s(_ReturnSize, _Dest, _Size, _VarName); } }




#line 690 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _wdupenv_s(    wchar_t **_Buffer,   size_t *_BufferSizeInWords,   const wchar_t *_VarName);



#line 696 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"



__declspec(dllimport) int __cdecl _wsystem(  const wchar_t * _Command);
#line 701 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 703 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

  __declspec(dllimport) double __cdecl _wtof(  const wchar_t *_Str);
  __declspec(dllimport) double __cdecl _wtof_l(  const wchar_t *_Str,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wtoi(  const wchar_t *_Str);
  __declspec(dllimport) int __cdecl _wtoi_l(  const wchar_t *_Str,   _locale_t _Locale);
  __declspec(dllimport) long __cdecl _wtol(  const wchar_t *_Str);
  __declspec(dllimport) long __cdecl _wtol_l(  const wchar_t *_Str,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl _i64tow_s(  __int64 _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
__declspec(dllimport)  wchar_t * __cdecl _i64tow(  __int64 _Val,     wchar_t * _DstBuf,   int _Radix);
 __declspec(dllimport) errno_t __cdecl _ui64tow_s(  unsigned __int64 _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
__declspec(dllimport)  wchar_t * __cdecl _ui64tow(  unsigned __int64 _Val,     wchar_t * _DstBuf,   int _Radix);
  __declspec(dllimport) __int64   __cdecl _wtoi64(  const wchar_t *_Str);
  __declspec(dllimport) __int64   __cdecl _wtoi64_l(  const wchar_t *_Str,   _locale_t _Locale);
  __declspec(dllimport) __int64   __cdecl _wcstoi64(  const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix);
  __declspec(dllimport) __int64   __cdecl _wcstoi64_l(  const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned __int64  __cdecl _wcstoui64(  const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix);
  __declspec(dllimport) unsigned __int64  __cdecl _wcstoui64_l(  const wchar_t *_Str ,     wchar_t ** _EndPtr,   int _Radix,   _locale_t _Locale);


#line 724 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"














#line 739 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

  __declspec(dllimport) char * __cdecl _fullpath(  char * _FullPath,   const char * _Path,   size_t _SizeInBytes);





#line 747 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _ecvt_s(  char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDights,   int * _PtDec,   int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits,   int * _PtDec,   int * _PtSign) throw() { return _ecvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
  __declspec(dllimport)  char * __cdecl _ecvt(  double _Val,   int _NumOfDigits,   int * _PtDec,   int * _PtSign);
 __declspec(dllimport) errno_t __cdecl _fcvt_s(  char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits,   int * _PtDec,   int * _PtSign) throw() { return _fcvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
  __declspec(dllimport)  char * __cdecl _fcvt(  double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
__declspec(dllimport) errno_t __cdecl _gcvt_s(  char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDigits);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits) throw() { return _gcvt_s(_Dest, _Size, _Value, _NumOfDigits); } }
__declspec(dllimport)  char * __cdecl _gcvt(  double _Val,   int _NumOfDigits,     char * _DstBuf);

  __declspec(dllimport) int __cdecl _atodbl(  _CRT_DOUBLE * _Result,   char * _Str);
  __declspec(dllimport) int __cdecl _atoldbl(  _LDOUBLE * _Result,   char * _Str);
  __declspec(dllimport) int __cdecl _atoflt(  _CRT_FLOAT * _Result,   char * _Str);
  __declspec(dllimport) int __cdecl _atodbl_l(  _CRT_DOUBLE * _Result,   char * _Str,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _atoldbl_l(  _LDOUBLE * _Result,   char * _Str,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _atoflt_l(  _CRT_FLOAT * _Result,   char * _Str,   _locale_t _Locale);
          unsigned long __cdecl _lrotl(  unsigned long _Val,   int _Shift);
          unsigned long __cdecl _lrotr(  unsigned long _Val,   int _Shift);
 __declspec(dllimport) errno_t   __cdecl _makepath_s(  char * _PathResult,   size_t _SizeInWords,   const char * _Drive,   const char * _Dir,   const char * _Filename,
          const char * _Ext);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Path)[_Size],   const char * _Drive,   const char * _Dir,   const char * _Filename,   const char * _Ext) throw() { return _makepath_s(_Path, _Size, _Drive, _Dir, _Filename, _Ext); } }
 __declspec(dllimport) void __cdecl _makepath(  char *_Path,  const char * _Drive,  const char * _Dir,  const char * _Filename,  const char * _Ext);












#line 783 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"












#line 796 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
        _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 798 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
        


__declspec(dllimport) void __cdecl perror(  const char * _ErrMsg);
#line 803 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#pragma warning (push)
#pragma warning (disable:6540) 


  __declspec(dllimport) int    __cdecl _putenv(  const char * _EnvString);
 __declspec(dllimport) errno_t __cdecl _putenv_s(  const char * _Name,   const char * _Value);
#line 811 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

        unsigned int __cdecl _rotl(  unsigned int _Val,   int _Shift);
        unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Val,   int _Shift);
        unsigned int __cdecl _rotr(  unsigned int _Val,   int _Shift);
        unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Val,   int _Shift);
#pragma warning (pop)


__declspec(dllimport) errno_t __cdecl _searchenv_s(  const char * _Filename,   const char * _EnvVar,   char * _ResultPath,   size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  const char * _Filename,   const char * _EnvVar, char (&_ResultPath)[_Size]) throw() { return _searchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
 __declspec(dllimport) void __cdecl _searchenv( const char * _Filename,  const char * _EnvVar,   char *_ResultPath);
#line 823 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) void   __cdecl _splitpath(  const char * _FullPath,     char * _Drive,     char * _Dir,     char * _Filename,     char * _Ext);
 __declspec(dllimport) errno_t  __cdecl _splitpath_s(  const char * _FullPath, 
		  char * _Drive,   size_t _DriveSize, 
		  char * _Dir,   size_t _DirSize, 
		  char * _Filename,   size_t _FilenameSize, 
		  char * _Ext,   size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(  const char *_Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize]) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }

__declspec(dllimport) void   __cdecl _swab(    char * _Buf1,     char * _Buf2, int _SizeInBytes);








#line 842 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

  __declspec(dllimport) wchar_t * __cdecl _wfullpath(  wchar_t * _FullPath,   const wchar_t * _Path,   size_t _SizeInWords);



#line 848 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _wmakepath_s(  wchar_t * _PathResult,   size_t _SIZE,   const wchar_t * _Drive,   const wchar_t * _Dir,   const wchar_t * _Filename,
          const wchar_t * _Ext);        
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_ResultPath)[_Size],   const wchar_t * _Drive,   const wchar_t * _Dir,   const wchar_t * _Filename,   const wchar_t * _Ext) throw() { return _wmakepath_s(_ResultPath, _Size, _Drive, _Dir, _Filename, _Ext); } }
 __declspec(dllimport) void __cdecl _wmakepath(  wchar_t *_ResultPath,  const wchar_t * _Drive,  const wchar_t * _Dir,  const wchar_t * _Filename,  const wchar_t * _Ext);


__declspec(dllimport) void __cdecl _wperror(  const wchar_t * _ErrMsg);
#line 857 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"


  __declspec(dllimport) int    __cdecl _wputenv(  const wchar_t * _EnvString);
 __declspec(dllimport) errno_t __cdecl _wputenv_s(  const wchar_t * _Name,   const wchar_t * _Value);
__declspec(dllimport) errno_t __cdecl _wsearchenv_s(  const wchar_t * _Filename,   const wchar_t * _EnvVar,   wchar_t * _ResultPath,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  const wchar_t * _Filename,   const wchar_t * _EnvVar, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
 __declspec(dllimport) void __cdecl _wsearchenv( const wchar_t * _Filename,  const wchar_t * _EnvVar,   wchar_t *_ResultPath);
#line 865 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) void   __cdecl _wsplitpath(  const wchar_t * _FullPath,     wchar_t * _Drive,     wchar_t * _Dir,     wchar_t * _Filename,     wchar_t * _Ext);
__declspec(dllimport) errno_t __cdecl _wsplitpath_s(  const wchar_t * _FullPath, 
		  wchar_t * _Drive,   size_t _DriveSize, 
		  wchar_t * _Dir,   size_t _DirSize, 
		  wchar_t * _Filename,   size_t _FilenameSize, 
		  wchar_t * _Ext,   size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(  const wchar_t *_Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize]) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }


#line 876 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"



__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetErrorMode" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode(  int _Mode);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Beep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _beep(  unsigned _Frequency,   unsigned _Duration);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Sleep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _sleep(  unsigned long _Duration);
#line 883 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 885 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

















#line 903 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 4141)  
    __declspec(dllimport) char * __cdecl ecvt(  double _Val,   int _NumOfDigits,   int * _PtDec,   int * _PtSign);
    __declspec(dllimport) char * __cdecl fcvt(  double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
 		__declspec(dllimport) char * __cdecl gcvt(  double _Val,   int _NumOfDigits,     char * _DstBuf);
 		__declspec(dllimport) char * __cdecl itoa(  int _Val,     char * _DstBuf,   int _Radix);
 		__declspec(dllimport) char * __cdecl ltoa(  long _Val,     char * _DstBuf,   int _Radix);


   __declspec(dllimport) int    __cdecl putenv(  const char * _EnvString);
#line 915 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

										__declspec(dllimport) void   __cdecl swab(  char * _Buf1,  char * _Buf2,   int _SizeInBytes);
 	__declspec(dllimport) char * __cdecl ultoa(  unsigned long _Val,     char * _Dstbuf,   int _Radix);
#pragma warning(pop)
_onexit_t __cdecl onexit(  _onexit_t _Func);

#line 922 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 924 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"


}

#line 929 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#pragma pack(pop)

#line 933 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 7561 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"


#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"

#pragma once


#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#pragma once




#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"

#pragma once






 
















































































#line 91 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"

  














































































#line 244 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"
 #line 245 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"

#line 247 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"

#line 249 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"
#line 250 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"





#line 8 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 9 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#pragma pack(push,8)















































#line 59 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 61 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 62 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

		





#line 70 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 71 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

		


		




		

 
  

 

#line 88 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
  
 #line 92 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"



 
  
 #line 98 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"










































	
	






		
			
		

#line 153 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
	#line 154 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

	
	




		
			
		

#line 166 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
	#line 167 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

	
	
		
	



#line 176 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 178 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"






	
		#pragma detect_mismatch("_MSC_VER", "1700")
	#line 187 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

	
		#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
	#line 191 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

	
		

#line 196 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 198 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 200 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
			#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
		#line 202 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
	#line 203 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 204 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 205 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"


	
#line 209 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"




#line 214 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"




#line 219 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 221 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 222 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"



#line 226 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"











#line 238 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"


 
#line 242 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
 

 









 









 









 

 









 









 




 





 













#line 324 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"











#line 336 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"













#pragma once












#pragma comment(lib,"msvcprtd")


#line 31 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"

























#line 57 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"

#line 59 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"

#line 61 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"

#line 63 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"
#line 338 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"



#line 342 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"







#line 350 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"


 











 
  

#line 368 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
   
  #line 370 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 #line 371 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"






 










 
  

#line 392 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
   
  #line 394 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 #line 395 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
  

#line 400 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
   
  #line 402 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 #line 403 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"


 

   


#line 411 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
    
   #line 413 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 #line 415 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"


 
  

#line 421 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
   
  #line 423 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 #line 424 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
  
 #line 428 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
   


     
   #line 435 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 #line 436 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"


    
#line 440 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"



		

 
  
  
  




  
  
  

  







   
   
   
  #line 469 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

  
  
  
  

 












#line 489 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
namespace std {
typedef bool _Bool;
}
 #line 495 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

		





		






typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;

		







 
#line 522 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

		
 
#line 526 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 
  
typedef unsigned short char16_t;
typedef unsigned int char32_t;
 #line 531 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 #line 532 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

		
		






 
namespace std {
enum _Uninitialized
	{	
	_Noinit
	};

		

#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit
	{	
public:
 

  
















#line 575 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
	__thiscall _Lockit();	
	explicit __thiscall _Lockit(int);	
	__thiscall ~_Lockit() throw ();	
  #line 579 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

    static  void __cdecl _Lockit_ctor(int);
    static  void __cdecl _Lockit_dtor(int);

private:
    static  void __cdecl _Lockit_ctor(_Lockit *);
    static  void __cdecl _Lockit_ctor(_Lockit *, int);
    static  void __cdecl _Lockit_dtor(_Lockit *);

	 _Lockit(const _Lockit&);				
	_Lockit&  operator=(const _Lockit&);	

	int _Locktype;

  











#line 606 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
	};

 



































































  



  


  



  


  
 #line 692 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

class __declspec(dllimport) _Init_locks
	{	
public:
 
      










#line 709 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
    __thiscall _Init_locks();
	__thiscall ~_Init_locks() throw ();
  #line 712 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

private:
    static  void __cdecl _Init_locks_ctor(_Init_locks *);
    static  void __cdecl _Init_locks_dtor(_Init_locks *);

 







#line 726 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
	};

#pragma warning(pop)
}
 #line 731 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"





		

__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void));

typedef int _Mbstatet;
typedef unsigned long _Uint32t;




 
 

 
 #pragma pack(pop)
#line 752 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 753 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"





#line 6 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"












 #line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"































































































































































































































































































































































































































































































































































































































































#line 641 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

#line 19 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"

 
 #line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"

#pragma once




 
#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
	
template<class _T1,
	class _Ret>
	struct unary_function;

	
template<class _T1,
	class _T2,
	class _Ret>
	struct binary_function;

	
struct _Nil
	{	
	};
static _Nil _Nil_obj;

	
template<class _Ty,
	_Ty _Val>
	struct integral_constant
	{	
	static const _Ty value = _Val;

	typedef _Ty value_type;
	typedef integral_constant<_Ty, _Val> type;

	operator value_type() const
		{	
		return (value);
		}
	};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

	
template<bool>
	struct _Cat_base
		: false_type
	{	
	};

template<>
	struct _Cat_base<true>
		: true_type
	{	
	};

	
template<bool _Test,
	class _Ty = void>
	struct enable_if
	{	
	};

template<class _Ty>
	struct enable_if<true, _Ty>
	{	
	typedef _Ty type;
	};

	
template<bool _Test,
	class _Ty1,
	class _Ty2>
	struct conditional
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct conditional<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

	
template<class _Ty1, class _Ty2>
	struct is_same
		: false_type
	{	
	};

template<class _Ty1>
	struct is_same<_Ty1, _Ty1>
		: true_type
	{	
	};

	
template<class _Ty>
	struct remove_const
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty[]>
	{	
	typedef _Ty type[];
	};

template<class _Ty, unsigned int _Nx>
	struct remove_const<const _Ty[_Nx]>
	{	
	typedef _Ty type[_Nx];
	};

	
template<class _Ty>
	struct remove_volatile
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty[]>
	{	
	typedef _Ty type[];
	};

template<class _Ty, unsigned int _Nx>
	struct remove_volatile<volatile _Ty[_Nx]>
	{	
	typedef _Ty type[_Nx];
	};

	
template<class _Ty>
	struct remove_cv
	{	
	typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
		type;
	};

	
template<class _Ty>
	struct _Is_integral
		: false_type
	{	
	};

template<>
	struct _Is_integral<bool>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed char>
		: true_type
	{	
	};

 
template<>
	struct _Is_integral<wchar_t>
		: true_type
	{	
	};
 #line 201 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"

template<>
	struct _Is_integral<unsigned short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed long>
		: true_type
	{	
	};

 











#line 251 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"

 
template<>
	struct _Is_integral<__int64>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned __int64>
		: true_type
	{	
	};
 #line 265 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"

	
template<class _Ty>
	struct is_integral
		: _Is_integral<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct _Is_floating_point
		: false_type
	{	
	};

template<>
	struct _Is_floating_point<float>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<double>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<long double>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_floating_point
		: _Is_floating_point<typename remove_cv<_Ty>::type>
	{	
	};

template<class _Ty>
	struct _Is_numeric
		: _Cat_base<is_integral<_Ty>::value
			|| is_floating_point<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct remove_reference
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&&>
	{	
	typedef _Ty type;
	};

	
template<class _Tgt,
	class _Src>
	struct _Copy_cv
	{	
	typedef typename remove_reference<_Tgt>::type _Tgtx;
	typedef _Tgtx& type;
	};

template<class _Tgt,
	class _Src>
	struct _Copy_cv<_Tgt, const _Src>
	{	
	typedef typename remove_reference<_Tgt>::type _Tgtx;
	typedef const _Tgtx& type;
	};

template<class _Tgt,
	class _Src>
	struct _Copy_cv<_Tgt, volatile _Src>
	{	
	typedef typename remove_reference<_Tgt>::type _Tgtx;
	typedef volatile _Tgtx& type;
	};

template<class _Tgt,
	class _Src>
	struct _Copy_cv<_Tgt, const volatile _Src>
	{	
	typedef typename remove_reference<_Tgt>::type _Tgtx;
	typedef const volatile _Tgtx& type;
	};

template<class _Tgt,
	class _Src>
	struct _Copy_cv<_Tgt, _Src&>
	{	
	typedef typename _Copy_cv<_Tgt, _Src>::type type;
	};

	
struct _Wrap_int
	{	
	_Wrap_int(int)
		{	
		}
	};

































		
template<class _Ty>
	struct _Has_result_type
		{ template<class _Uty> static auto _Fn(int, typename remove_reference<typename _Uty::result_type>::type * = 0, typename remove_reference<typename _Uty::result_type>::type * = 0, typename remove_reference<typename _Uty::result_type>::type * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 420 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"
#line 421 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"





#line 9 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
template<class _Ty>
	struct _Promote_to_float
	{	
	typedef typename conditional<is_integral<_Ty>::value,
		double, _Ty>::type type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Common_float_type
	{	
	typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
	typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
	typedef typename conditional<is_same<_Ty1f, long double>::value
		|| is_same<_Ty2f, long double>::value, long double,
		typename conditional<is_same<_Ty1f, double>::value
			|| is_same<_Ty2f, double>::value, double,
			float>::type>::type type;
	};
}


































extern "C" double __cdecl pow(  double,   double);
float __cdecl  pow(  float,   float);
long double __cdecl  pow(  long double,   long double);

template<class _Ty1,
	class _Ty2> inline
	typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value
		&& ::std:: _Is_numeric<_Ty2>::value,
		typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
	pow(const _Ty1 _Left, const _Ty2 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (:: pow(type(_Left), type(_Right)));
	}


extern "C"  double __cdecl acos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C"  double __cdecl asin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C"  double __cdecl atan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C"  double __cdecl atan2(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: _Common_float_type<_Ty1, _Ty2>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl ceil(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C"  double __cdecl cos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C"  double __cdecl cosh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C"  double __cdecl exp(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }

extern "C" __declspec(dllimport) double __cdecl floor(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C"  double __cdecl fmod(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: _Common_float_type<_Ty1, _Ty2>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl frexp(  double,   int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left,   int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl ldexp(  double,   int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left,   int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C"  double __cdecl log(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C"  double __cdecl log10(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C"  double __cdecl sin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C"  double __cdecl sinh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C"  double __cdecl sqrt(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C"  double __cdecl tan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C"  double __cdecl tanh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }

 #line 110 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 115 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"
#line 116 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"





#line 22 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"
 #line 23 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"
#line 24 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"

 

namespace std {
using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: abs;

using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: hypot; using :: hypotf;
}
 #line 60 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"
#line 61 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"





#line 7564 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"

#pragma once










 
#line 15 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"

 

namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;

using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;
using :: llabs; using :: lldiv;

 
using :: getenv;
using :: system;
 #line 39 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"
}
 #line 41 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"
#line 42 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"





#line 7565 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
#line 7566 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"




















































































#line 7651 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"








#line 7660 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"

extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) __declspec(dllimport) double __cdecl _hypot(double x, double y);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) __declspec(dllimport) float  __cdecl _hypotf(float x, float y);

#line 7665 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"

static __inline __declspec(__host__) __declspec(__device__) int signbit(long double a)
{
  return __signbitl(a);
}












static __inline __declspec(__host__) __declspec(__device__) int signbit(double a)
{
  return __signbit(a);
}












static __inline __declspec(__host__) __declspec(__device__) int signbit(float a)
{
  return __signbitf(a);
}

static __inline __declspec(__host__) __declspec(__device__) int isinf(long double a)
{
  return __isinfl(a);
}












static __inline __declspec(__host__) __declspec(__device__) int isinf(double a)
{
  return __isinf(a);
}












static __inline __declspec(__host__) __declspec(__device__) int isinf(float a)
{
  return __isinff(a);
}

static __inline __declspec(__host__) __declspec(__device__) int isnan(long double a)
{
  return __isnanl(a);
}











static __inline __declspec(__host__) __declspec(__device__) int isnan(double a)
{
  return __isnan(a);
}











static __inline __declspec(__host__) __declspec(__device__) int isnan(float a)
{
  return __isnanf(a);
}

static __inline __declspec(__host__) __declspec(__device__) int isfinite(long double a)
{
  return __finitel(a);
}












static __inline __declspec(__host__) __declspec(__device__) int isfinite(double a)
{
  return __finite(a);
}












static __inline __declspec(__host__) __declspec(__device__) int isfinite(float a)
{
  return __finitef(a);
}

template<class T> extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) T _Pow_int(T, int);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long long int abs(long long int);

#line 7816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"



#line 7820 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"







#line 7828 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) long int __cdecl abs(long int);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl abs(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double   __cdecl abs(double);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl fabs(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl ceil(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl floor(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl sqrt(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl pow(float, float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl pow(float, int);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) double   __cdecl pow(double, int);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl log(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl log10(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl fmod(float, float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl modf(float, float*);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl exp(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl frexp(float, int*);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl ldexp(float, int);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl asin(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl sin(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl sinh(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl acos(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl cos(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl cosh(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl atan(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl atan2(float, float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl tan(float);
extern __declspec(__host__) __declspec(__device__) __declspec(__cudart_builtin__) float    __cdecl tanh(float);



#line 7859 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"

static __inline __declspec(__host__) __declspec(__device__) float logb(float a)
{
  return logbf(a);
}

static __inline __declspec(__host__) __declspec(__device__) int ilogb(float a)
{
  return ilogbf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float scalbn(float a, int b)
{
  return scalbnf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float scalbln(float a, long int b)
{
  return scalblnf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float exp2(float a)
{
  return exp2f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float exp10(float a)
{
  return exp10f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float expm1(float a)
{
  return expm1f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float log2(float a)
{
  return log2f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float log1p(float a)
{
  return log1pf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float rsqrt(float a)
{
  return rsqrtf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float acosh(float a)
{
  return acoshf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float asinh(float a)
{
  return asinhf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float atanh(float a)
{
  return atanhf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float hypot(float a, float b)
{
  return hypotf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float cbrt(float a)
{
  return cbrtf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float rcbrt(float a)
{
  return rcbrtf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float sinpi(float a)
{
  return sinpif(a);
}

static __inline __declspec(__host__) __declspec(__device__) float cospi(float a)
{
  return cospif(a);
}

static __inline __declspec(__host__) __declspec(__device__) void sincospi(float a, float *sptr, float *cptr)
{
  sincospif(a, sptr, cptr);
}

static __inline __declspec(__host__) __declspec(__device__) void sincos(float a, float *sptr, float *cptr)
{
  sincosf(a, sptr, cptr);
}

static __inline __declspec(__host__) __declspec(__device__) float j0(float a)
{
  return j0f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float j1(float a)
{
  return j1f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float jn(int n, float a)
{
  return jnf(n, a);
}

static __inline __declspec(__host__) __declspec(__device__) float y0(float a)
{
  return y0f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float y1(float a)
{
  return y1f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float yn(int n, float a)
{ 
  return ynf(n, a);
}

static __inline __declspec(__host__) __declspec(__device__) float erf(float a)
{
  return erff(a);
}

static __inline __declspec(__host__) __declspec(__device__) float erfinv(float a)
{
  return erfinvf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float erfc(float a)
{
  return erfcf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float erfcinv(float a)
{
  return erfcinvf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float normcdfinv(float a)
{
  return normcdfinvf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float normcdf(float a)
{
  return normcdff(a);
}

static __inline __declspec(__host__) __declspec(__device__) float erfcx(float a)
{
  return erfcxf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float lgamma(float a)
{
  return lgammaf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float tgamma(float a)
{
  return tgammaf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float copysign(float a, float b)
{
  return copysignf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double copysign(double a, float b)
{
  return copysign(a, (double)b);
}

static __inline __declspec(__host__) __declspec(__device__) float copysign(float a, double b)
{
  return copysignf(a, (float)b);
}

static __inline __declspec(__host__) __declspec(__device__) float nextafter(float a, float b)
{
  return nextafterf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float remainder(float a, float b)
{
  return remainderf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float remquo(float a, float b, int *quo)
{
  return remquof(a, b, quo);
}

static __inline __declspec(__host__) __declspec(__device__) float round(float a)
{
  return roundf(a);
}

static __inline __declspec(__host__) __declspec(__device__) long int lround(float a)
{
  return lroundf(a);
}

static __inline __declspec(__host__) __declspec(__device__) long long int llround(float a)
{
  return llroundf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float trunc(float a)
{
  return truncf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float rint(float a)
{
  return rintf(a);
}

static __inline __declspec(__host__) __declspec(__device__) long int lrint(float a)
{
  return lrintf(a);
}

static __inline __declspec(__host__) __declspec(__device__) long long int llrint(float a)
{
  return llrintf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float nearbyint(float a)
{
  return nearbyintf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float fdim(float a, float b)
{
  return fdimf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float fma(float a, float b, float c)
{
  return fmaf(a, b, c);
}

static __inline __declspec(__host__) __declspec(__device__) float fmax(float a, float b)
{
  return fmaxf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float fmin(float a, float b)
{
  return fminf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int min(unsigned int a, unsigned int b)
{
  return umin(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int min(int a, unsigned int b)
{
  return umin((unsigned int)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int min(unsigned int a, int b)
{
  return umin(a, (unsigned int)b);
}

static __inline __declspec(__host__) __declspec(__device__) long long int min(long long int a, long long int b)
{
  return llmin(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int min(unsigned long long int a, unsigned long long int b)
{
  return ullmin(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int min(long long int a, unsigned long long int b)
{
  return ullmin((unsigned long long int)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int min(unsigned long long int a, long long int b)
{
  return ullmin(a, (unsigned long long int)b);
}

static __inline __declspec(__host__) __declspec(__device__) float min(float a, float b)
{
  return fminf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double min(double a, double b)
{
  return fmin(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double min(float a, double b)
{
  return fmin((double)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double min(double a, float b)
{
  return fmin(a, (double)b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int max(unsigned int a, unsigned int b)
{
  return umax(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int max(int a, unsigned int b)
{
  return umax((unsigned int)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int max(unsigned int a, int b)
{
  return umax(a, (unsigned int)b);
}

static __inline __declspec(__host__) __declspec(__device__) long long int max(long long int a, long long int b)
{
  return llmax(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int max(unsigned long long int a, unsigned long long int b)
{
  return ullmax(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int max(long long int a, unsigned long long int b)
{
  return ullmax((unsigned long long int)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int max(unsigned long long int a, long long int b)
{
  return ullmax(a, (unsigned long long int)b);
}

static __inline __declspec(__host__) __declspec(__device__) float max(float a, float b)
{
  return fmaxf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double max(double a, double b)
{
  return fmax(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double max(float a, double b)
{
  return fmax((double)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double max(double a, float b)
{
  return fmax(a, (double)b);
}







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 13682 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"





#line 13688 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"





#line 13694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"





#line 13700 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"

#line 13702 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"

#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\common_functions.h"

#line 170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\common_functions.h"

#line 77 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_surface_types.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_surface_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"



























































































































































































































































































































































































































#line 413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_surface_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_surface_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_surface_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_surface_types.h"







template<class T, int dim = 1>
struct __declspec(__device_builtin_surface_type__) surface : public surfaceReference
{
  __declspec(__host__) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<T>();
  }

  __declspec(__host__) surface(struct cudaChannelFormatDesc desc)
  {
    channelDesc = desc;
  }
};

template<int dim>
struct  __declspec(__device_builtin_surface_type__)  surface<void, dim> : public surfaceReference
{
  __declspec(__host__) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<void>();
  }
};

#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_surface_types.h"

#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_surface_types.h"
#line 78 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_texture_types.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_texture_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"



























































































































































































































































































































































































































#line 413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_texture_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_texture_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_texture_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_texture_types.h"







template<class T, int texType = 0x01, enum cudaTextureReadMode mode = cudaReadModeElementType>
struct __declspec(__device_builtin_texture_type__) texture : public textureReference
{
  __declspec(__host__) texture(int                         norm  = 0,
                   enum cudaTextureFilterMode  fMode = cudaFilterModePoint,
                   enum cudaTextureAddressMode aMode = cudaAddressModeClamp)
  {
    normalized     = norm;
    filterMode     = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc    = cudaCreateChannelDesc<T>();
    sRGB           = 0;
  }

  __declspec(__host__) texture(int                          norm,
                   enum cudaTextureFilterMode   fMode,
                   enum cudaTextureAddressMode  aMode,
                   struct cudaChannelFormatDesc desc)
  {
    normalized     = norm;
    filterMode     = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc    = desc;
    sRGB           = 0;
  }
};

#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_texture_types.h"

#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_texture_types.h"
#line 79 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"







extern "C"
{









extern __declspec(__device__) __declspec(__device_builtin__) int                    __mulhi(int x, int y);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __umulhi(unsigned int x, unsigned int y);









extern __declspec(__device__) __declspec(__device_builtin__) long long int          __mul64hi(long long int x, long long int y);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __umul64hi(unsigned long long int x, unsigned long long int y);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __int_as_float(int x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __float_as_int(float x);
extern __declspec(__device__) __declspec(__device_builtin__) void                   __syncthreads(void);
extern __declspec(__device__) __declspec(__device_builtin__) void                   __prof_trigger(int);
extern __declspec(__device__) __declspec(__device_builtin__) void                   __threadfence(void);
extern __declspec(__device__) __declspec(__device_builtin__) void                   __threadfence_block(void);
extern __declspec(__device__) __declspec(__device_builtin__) void                   __trap(void);
extern __declspec(__device__) __declspec(__device_builtin__) void                   __brkpt(int c = 0);






















extern __declspec(__device__) __declspec(__device_builtin__) float                  __saturatef(float x);




































































extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __sad(int x, int y, unsigned int z);



































































extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __usad(unsigned int x, unsigned int y, unsigned int z);









extern __declspec(__device__) __declspec(__device_builtin__) int                    __mul24(int x, int y);









extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __umul24(unsigned int x, unsigned int y);












extern __declspec(__device__) __declspec(__device_builtin__) float                  fdividef(float x, float y);










































































extern __declspec(__device__) __declspec(__device_builtin__) float                  __fdividef(float x, float y);
extern __declspec(__device__) __declspec(__device_builtin__) double                 fdivide(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __sinf(float x) ;











extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __cosf(float x) ;













extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __tanf(float x) ;














extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) void                   __sincosf(float x, float *sptr, float *cptr) ;

















































extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __expf(float x) ;































extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __exp10f(float x) ;

























extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __log2f(float x) ;



























extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __log10f(float x) ;











































extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __logf(float x) ;










































extern __declspec(__device__) __declspec(__device_builtin__) __declspec(__cudart_builtin__) float                  __powf(float x, float y) ;








extern __declspec(__device__) __declspec(__device_builtin__) int                    __float2int_rn(float x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __float2int_rz(float x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __float2int_ru(float);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __float2int_rd(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __float2uint_rn(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __float2uint_rz(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __float2uint_ru(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __float2uint_rd(float x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __int2float_rn(int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __int2float_rz(int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __int2float_ru(int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __int2float_rd(int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __uint2float_rn(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __uint2float_rz(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __uint2float_ru(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __uint2float_rd(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __float2ll_rn(float x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __float2ll_rz(float x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __float2ll_ru(float x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __float2ll_rd(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __float2ull_rn(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __float2ull_rz(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __float2ull_ru(float x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __float2ull_rd(float x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ll2float_rn(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ll2float_rz(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ll2float_ru(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ll2float_rd(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ull2float_rn(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ull2float_rz(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ull2float_ru(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __ull2float_rd(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned short         __float2half_rn(float x);








extern __declspec(__device__) __declspec(__device_builtin__) float                  __half2float(unsigned short x);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fadd_rn(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fadd_rz(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fadd_ru(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fadd_rd(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsub_rn(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsub_rz(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsub_ru(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsub_rd(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmul_rn(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmul_rz(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmul_ru(float x, float y);











extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmul_rd(float x, float y);
























































































































































extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmaf_rn(float x, float y, float z);
























































































































































extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmaf_rz(float x, float y, float z);
























































































































































extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmaf_ru(float x, float y, float z);
























































































































































extern __declspec(__device__) __declspec(__device_builtin__) float                  __fmaf_rd(float x, float y, float z);
































extern __declspec(__device__) __declspec(__device_builtin__) float                  __frcp_rn(float x);
































extern __declspec(__device__) __declspec(__device_builtin__) float                  __frcp_rz(float x);
































extern __declspec(__device__) __declspec(__device_builtin__) float                  __frcp_ru(float x);
































extern __declspec(__device__) __declspec(__device_builtin__) float                  __frcp_rd(float x);






























extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsqrt_rn(float x);






























extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsqrt_rz(float x);






























extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsqrt_ru(float x);






























extern __declspec(__device__) __declspec(__device_builtin__) float                  __fsqrt_rd(float x);






































extern __declspec(__device__) __declspec(__device_builtin__) float                  __frsqrt_rn(float x);










extern __declspec(__device__) __declspec(__device_builtin__) float                  __fdiv_rn(float x, float y);










extern __declspec(__device__) __declspec(__device_builtin__) float                  __fdiv_rz(float x, float y);










extern __declspec(__device__) __declspec(__device_builtin__) float                  __fdiv_ru(float x, float y);










extern __declspec(__device__) __declspec(__device_builtin__) float                  __fdiv_rd(float x, float y);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __clz(int x);










extern __declspec(__device__) __declspec(__device_builtin__) int                    __ffs(int x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __popc(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __brev(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __clzll(long long int x);










extern __declspec(__device__) __declspec(__device_builtin__) int                    __ffsll(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __popcll(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __brevll(unsigned long long int x);























extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __byte_perm(unsigned int x, unsigned int y, unsigned int s);











extern __declspec(__device__) __declspec(__device_builtin__) int                    __hadd(int, int);












extern __declspec(__device__) __declspec(__device_builtin__) int                    __rhadd(int, int);











extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __uhadd(unsigned int, unsigned int);












extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __urhadd(unsigned int, unsigned int);










extern __declspec(__device__) __declspec(__device_builtin__) int                    __double2int_rz(double);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __double2uint_rz(double);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_rz(double);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_rz(double);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __pm0(void);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __pm1(void);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __pm2(void);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int           __pm3(void);
#line 2276 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"

}







static __inline __declspec(__device__) int mulhi(int a, int b)
{
  return __mulhi(a, b);
}

static __inline __declspec(__device__) unsigned int mulhi(unsigned int a, unsigned int b)
{
  return __umulhi(a, b);
}

static __inline __declspec(__device__) unsigned int mulhi(int a, unsigned int b)
{
  return __umulhi((unsigned int)a, b);
}

static __inline __declspec(__device__) unsigned int mulhi(unsigned int a, int b)
{
  return __umulhi(a, (unsigned int)b);
}

static __inline __declspec(__device__) long long int mul64hi(long long int a, long long int b)
{
  return __mul64hi(a, b);
}

static __inline __declspec(__device__) unsigned long long int mul64hi(unsigned long long int a, unsigned long long int b)
{
  return __umul64hi(a, b);
}

static __inline __declspec(__device__) unsigned long long int mul64hi(long long int a, unsigned long long int b)
{
  return __umul64hi((unsigned long long int)a, b);
}

static __inline __declspec(__device__) unsigned long long int mul64hi(unsigned long long int a, long long int b)
{
  return __umul64hi(a, (unsigned long long int)b);
}

static __inline __declspec(__device__) int float_as_int(float a)
{
  return __float_as_int(a);
}

static __inline __declspec(__device__) float int_as_float(int a)
{
  return __int_as_float(a);
}

static __inline __declspec(__device__) float saturate(float a)
{
  return __saturatef(a);
}

static __inline __declspec(__device__) int mul24(int a, int b)
{
  return __mul24(a, b);
}

static __inline __declspec(__device__) unsigned int umul24(unsigned int a, unsigned int b)
{
  return __umul24(a, b);
}

static __inline __declspec(__device__) void trap(void)
{
  __trap();
}


static __inline __declspec(__device__) void brkpt(int c = 0)
{
  __brkpt(c);
}

static __inline __declspec(__device__) void syncthreads(void)
{
  __syncthreads();
}

static __inline __declspec(__device__) void prof_trigger(int e)
{
       if (e ==  0) __prof_trigger( 0);
  else if (e ==  1) __prof_trigger( 1);
  else if (e ==  2) __prof_trigger( 2);
  else if (e ==  3) __prof_trigger( 3);
  else if (e ==  4) __prof_trigger( 4);
  else if (e ==  5) __prof_trigger( 5);
  else if (e ==  6) __prof_trigger( 6);
  else if (e ==  7) __prof_trigger( 7);
  else if (e ==  8) __prof_trigger( 8);
  else if (e ==  9) __prof_trigger( 9);
  else if (e == 10) __prof_trigger(10);
  else if (e == 11) __prof_trigger(11);
  else if (e == 12) __prof_trigger(12);
  else if (e == 13) __prof_trigger(13);
  else if (e == 14) __prof_trigger(14);
  else if (e == 15) __prof_trigger(15);
}

static __inline __declspec(__device__) void threadfence(bool global = true)
{
  global ? __threadfence() : __threadfence_block();
}

static __inline __declspec(__device__) int float2int(float a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __float2int_rn(a) :
         mode == cudaRoundPosInf  ? __float2int_ru(a) :
         mode == cudaRoundMinInf  ? __float2int_rd(a) :
                                    __float2int_rz(a);
}

static __inline __declspec(__device__) unsigned int float2uint(float a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __float2uint_rn(a) :
         mode == cudaRoundPosInf  ? __float2uint_ru(a) :
         mode == cudaRoundMinInf  ? __float2uint_rd(a) :
                                    __float2uint_rz(a);
}

static __inline __declspec(__device__) float int2float(int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __int2float_rz(a) :
         mode == cudaRoundPosInf ? __int2float_ru(a) :
         mode == cudaRoundMinInf ? __int2float_rd(a) :
                                   __int2float_rn(a);
}

static __inline __declspec(__device__) float uint2float(unsigned int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __uint2float_rz(a) :
         mode == cudaRoundPosInf ? __uint2float_ru(a) :
         mode == cudaRoundMinInf ? __uint2float_rd(a) :
                                   __uint2float_rn(a);
}

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 6376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"







#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"






























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"

extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicAdd(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicAdd(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicExch(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicExch(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) float        __fAtomicExch(float *address, float val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicMin(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicMin(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicMax(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicMax(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicInc(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicDec(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicAnd(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicAnd(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicOr(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicOr(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicXor(int *address, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicXor(unsigned int *address, unsigned int val);
extern __declspec(__device__) __declspec(__device_builtin__) int          __iAtomicCAS(int *address, int compare, int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int __uAtomicCAS(unsigned int *address, unsigned int compare, unsigned int val);

}







static __inline __declspec(__device__) int atomicAdd(int *address, int val)
{
  return __iAtomicAdd(address, val);
}

static __inline __declspec(__device__) unsigned int atomicAdd(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd(address, val);
}

static __inline __declspec(__device__) int atomicSub(int *address, int val)
{
  return __iAtomicAdd(address, (unsigned int)-(int)val);
}

static __inline __declspec(__device__) unsigned int atomicSub(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd(address, (unsigned int)-(int)val);
}

static __inline __declspec(__device__) int atomicExch(int *address, int val)
{
  return __iAtomicExch(address, val);
}

static __inline __declspec(__device__) unsigned int atomicExch(unsigned int *address, unsigned int val)
{
  return __uAtomicExch(address, val);
}

static __inline __declspec(__device__) float atomicExch(float *address, float val)
{
  return __fAtomicExch(address, val);
}

static __inline __declspec(__device__) int atomicMin(int *address, int val)
{
  return __iAtomicMin(address, val);
}

static __inline __declspec(__device__) unsigned int atomicMin(unsigned int *address, unsigned int val)
{
  return __uAtomicMin(address, val);
}

static __inline __declspec(__device__) int atomicMax(int *address, int val)
{
  return __iAtomicMax(address, val);
}

static __inline __declspec(__device__) unsigned int atomicMax(unsigned int *address, unsigned int val)
{
  return __uAtomicMax(address, val);
}

static __inline __declspec(__device__) unsigned int atomicInc(unsigned int *address, unsigned int val)
{
  return __uAtomicInc(address, val);
}

static __inline __declspec(__device__) unsigned int atomicDec(unsigned int *address, unsigned int val)
{
  return __uAtomicDec(address, val);
}

static __inline __declspec(__device__) int atomicAnd(int *address, int val)
{
  return __iAtomicAnd(address, val);
}

static __inline __declspec(__device__) unsigned int atomicAnd(unsigned int *address, unsigned int val)
{
  return __uAtomicAnd(address, val);
}

static __inline __declspec(__device__) int atomicOr(int *address, int val)
{
  return __iAtomicOr(address, val);
}

static __inline __declspec(__device__) unsigned int atomicOr(unsigned int *address, unsigned int val)
{
  return __uAtomicOr(address, val);
}

static __inline __declspec(__device__) int atomicXor(int *address, int val)
{
  return __iAtomicXor(address, val);
}

static __inline __declspec(__device__) unsigned int atomicXor(unsigned int *address, unsigned int val)
{
  return __uAtomicXor(address, val);
}

static __inline __declspec(__device__) int atomicCAS(int *address, int compare, int val)
{
  return __iAtomicCAS(address, compare, val);
}

static __inline __declspec(__device__) unsigned int atomicCAS(unsigned int *address, unsigned int compare, unsigned int val)
{
  return __uAtomicCAS(address, compare, val);
}

#line 202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"

#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"

#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
#line 6384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_12_atomic_functions.h"






























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_12_atomic_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_12_atomic_functions.h"

extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __ullAtomicAdd(unsigned long long int *address, unsigned long long int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __ullAtomicExch(unsigned long long int *address, unsigned long long int val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __ullAtomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val);
extern __declspec(__device__) __declspec(__device_builtin__) int                    __any(int cond);
extern __declspec(__device__) __declspec(__device_builtin__) int                    __all(int cond);
}







static __inline __declspec(__device__) unsigned long long int atomicAdd(unsigned long long int *address, unsigned long long int val)
{
  return __ullAtomicAdd(address, val);
}

static __inline __declspec(__device__) unsigned long long int atomicExch(unsigned long long int *address, unsigned long long int val)
{
  return __ullAtomicExch(address, val);
}

static __inline __declspec(__device__) unsigned long long int atomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val)
{
  return __ullAtomicCAS(address, compare, val);
}

static __inline __declspec(__device__) bool any(bool cond)
{
  return (bool)__any((int)cond);
}

static __inline __declspec(__device__) bool all(bool cond)
{
  return (bool)__all((int)cond);
}

#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_12_atomic_functions.h"

#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_12_atomic_functions.h"

#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_12_atomic_functions.h"
#line 6385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"




































































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 71 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 72 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"

extern "C"
{








extern __declspec(__device__) __declspec(__device_builtin__) long long int         __double_as_longlong(double x);








extern __declspec(__device__) __declspec(__device_builtin__) double                __longlong_as_double(long long int x);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_rn(double x, double y, double z);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_rz(double x, double y, double z);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_ru(double x, double y, double z);




























































































































































extern __declspec(__device__) __declspec(__device_builtin__) double                __fma_rd(double x, double y, double z);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_rz(double x, double y);










 
extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dadd_rd(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_rz(double x, double y);










 
extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dsub_rd(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_rz(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __dmul_rd(double x, double y);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_rz(double x);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) float                 __double2float_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                   __double2int_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                   __double2int_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                   __double2int_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __double2uint_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __double2uint_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __double2uint_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) long long int          __double2ll_rd(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_rn(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_ru(double x);








extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long int __double2ull_rd(double x);







extern __declspec(__device__) __declspec(__device_builtin__) double                 __int2double_rn(int x);







extern __declspec(__device__) __declspec(__device_builtin__) double                 __uint2double_rn(unsigned int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_rn(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_rz(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_ru(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ll2double_rd(long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_rn(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_rz(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_ru(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) double                 __ull2double_rd(unsigned long long int x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __double2hiint(double x);








extern __declspec(__device__) __declspec(__device_builtin__) int                    __double2loint(double x);









extern __declspec(__device__) __declspec(__device_builtin__) double                 __hiloint2double(int hi, int lo);
}







static __inline __declspec(__device__) double fma(double a, double b, double c, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero   ? __fma_rz(a, b, c) :
         mode == cudaRoundPosInf ? __fma_ru(a, b, c) :
         mode == cudaRoundMinInf ? __fma_rd(a, b, c) :
                                   __fma_rn(a, b, c);
}

static __inline __declspec(__device__) double dmul(double a, double b, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __dmul_rz(a, b) :
         mode == cudaRoundPosInf ? __dmul_ru(a, b) :
         mode == cudaRoundMinInf ? __dmul_rd(a, b) :
                                   __dmul_rn(a, b);
}

static __inline __declspec(__device__) double dadd(double a, double b, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __dadd_rz(a, b) :
         mode == cudaRoundPosInf ? __dadd_ru(a, b) :
         mode == cudaRoundMinInf ? __dadd_rd(a, b) :
                                   __dadd_rn(a, b);
}

static __inline __declspec(__device__) double dsub(double a, double b, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __dsub_rz(a, b) :
         mode == cudaRoundPosInf ? __dsub_ru(a, b) :
         mode == cudaRoundMinInf ? __dsub_rd(a, b) :
                                   __dsub_rn(a, b);
}

static __inline __declspec(__device__) int double2int(double a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __double2int_rn(a) :
         mode == cudaRoundPosInf  ? __double2int_ru(a) :
         mode == cudaRoundMinInf  ? __double2int_rd(a) :
                                    __double2int_rz(a);
}

static __inline __declspec(__device__) unsigned int double2uint(double a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __double2uint_rn(a) :
         mode == cudaRoundPosInf  ? __double2uint_ru(a) :
         mode == cudaRoundMinInf  ? __double2uint_rd(a) :
                                    __double2uint_rz(a);
}

static __inline __declspec(__device__) long long int double2ll(double a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __double2ll_rn(a) :
         mode == cudaRoundPosInf  ? __double2ll_ru(a) :
         mode == cudaRoundMinInf  ? __double2ll_rd(a) :
                                    __double2ll_rz(a);
}

static __inline __declspec(__device__) unsigned long long int double2ull(double a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __double2ull_rn(a) :
         mode == cudaRoundPosInf  ? __double2ull_ru(a) :
         mode == cudaRoundMinInf  ? __double2ull_rd(a) :
                                    __double2ull_rz(a);
}

static __inline __declspec(__device__) double ll2double(long long int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __ll2double_rz(a) :
         mode == cudaRoundPosInf ? __ll2double_ru(a) :
         mode == cudaRoundMinInf ? __ll2double_rd(a) :
                                   __ll2double_rn(a);
}

static __inline __declspec(__device__) double ull2double(unsigned long long int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __ull2double_rz(a) :
         mode == cudaRoundPosInf ? __ull2double_ru(a) :
         mode == cudaRoundMinInf ? __ull2double_rd(a) :
                                   __ull2double_rn(a);
}

static __inline __declspec(__device__) double int2double(int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return (double)a;
}

static __inline __declspec(__device__) double uint2double(unsigned int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return (double)a;
}

static __inline __declspec(__device__) double float2double(float a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return (double)a;
}

#line 1229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"

































#line 1263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"

#line 1265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"

#line 6386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_atomic_functions.h"






























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_atomic_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_atomic_functions.h"

extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) float __fAtomicAdd(float *address, float val);
}







static __inline __declspec(__device__) float atomicAdd(float *address, float val)
{
  return __fAtomicAdd(address, val);
}

#line 83 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_atomic_functions.h"

#line 85 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_atomic_functions.h"

#line 87 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_atomic_functions.h"
#line 6387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"






























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"

extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) long long __illAtomicMin(long long *address, long long val);
extern __declspec(__device__) __declspec(__device_builtin__) long long __illAtomicMax(long long *address, long long val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long __ullAtomicMin(unsigned long long *address, unsigned long long val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long __ullAtomicMax(unsigned long long *address, unsigned long long val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long __ullAtomicAnd(unsigned long long *address, unsigned long long val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long __ullAtomicOr (unsigned long long *address, unsigned long long val);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned long long __ullAtomicXor(unsigned long long *address, unsigned long long val);
}







static __inline __declspec(__device__) long long atomicMin(long long *address, long long val)
{
    return __illAtomicMin(address, val);
}

static __inline __declspec(__device__) long long atomicMax(long long *address, long long val)
{
    return __illAtomicMax(address, val);
}

static __inline __declspec(__device__) unsigned long long atomicMin(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicMin(address, val);
}

static __inline __declspec(__device__) unsigned long long atomicMax(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicMax(address, val);
}

static __inline __declspec(__device__) unsigned long long atomicAnd(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicAnd(address, val);
}

static __inline __declspec(__device__) unsigned long long atomicOr(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicOr(address, val);
}

static __inline __declspec(__device__) unsigned long long atomicXor(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicXor(address, val);
}

#line 119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"

#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"

#line 123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"
#line 6388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_35_atomic_functions.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"

























































































































#line 123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_35_atomic_functions.h"

#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_35_atomic_functions.h"
#line 6389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"






























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"

extern "C"
{
extern __declspec(__device__) __declspec(__device_builtin__) void                   __threadfence_system(void);











extern __declspec(__device__) __declspec(__device_builtin__) double                __ddiv_rn(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __ddiv_rz(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __ddiv_ru(double x, double y);











extern __declspec(__device__) __declspec(__device_builtin__) double                __ddiv_rd(double x, double y);

































extern __declspec(__device__) __declspec(__device_builtin__) double                __drcp_rn(double x);

































extern __declspec(__device__) __declspec(__device_builtin__) double                __drcp_rz(double x);

































extern __declspec(__device__) __declspec(__device_builtin__) double                __drcp_ru(double x);

































extern __declspec(__device__) __declspec(__device_builtin__) double                __drcp_rd(double x);































extern __declspec(__device__) __declspec(__device_builtin__) double                __dsqrt_rn(double x);































extern __declspec(__device__) __declspec(__device_builtin__) double                __dsqrt_rz(double x);































extern __declspec(__device__) __declspec(__device_builtin__) double                __dsqrt_ru(double x);































extern __declspec(__device__) __declspec(__device_builtin__) double                __dsqrt_rd(double x);
extern __declspec(__device__) __declspec(__device_builtin__) unsigned int          __ballot(int);
extern __declspec(__device__) __declspec(__device_builtin__) int                   __syncthreads_count(int);
extern __declspec(__device__) __declspec(__device_builtin__) int                   __syncthreads_and(int);
extern __declspec(__device__) __declspec(__device_builtin__) int                   __syncthreads_or(int);
extern __declspec(__device__) __declspec(__device_builtin__) long long int         clock64(void);






extern __declspec(__device__) __declspec(__device_builtin__) float                 __fmaf_ieee_rn(float, float, float);
extern __declspec(__device__) __declspec(__device_builtin__) float                 __fmaf_ieee_rz(float, float, float);
extern __declspec(__device__) __declspec(__device_builtin__) float                 __fmaf_ieee_ru(float, float, float);
extern __declspec(__device__) __declspec(__device_builtin__) float                 __fmaf_ieee_rd(float, float, float);
extern __declspec(__device__) __declspec(__device_builtin__) double                __rcp64h(double);

}







static __inline __declspec(__device__) unsigned int ballot(bool pred)
{
  return __ballot((int)pred);
}

static __inline __declspec(__device__) int syncthreads_count(bool pred)
{
  return __syncthreads_count((int)pred);
}

static __inline __declspec(__device__) bool syncthreads_and(bool pred)
{
  return (bool)__syncthreads_and((int)pred);
}

static __inline __declspec(__device__) bool syncthreads_or(bool pred)
{
  return (bool)__syncthreads_or((int)pred);
}




static __inline __declspec(__device__) unsigned int __isGlobal(const void *ptr)
{
    unsigned int ret;
    asm volatile ("{ \n\t"
                  "    .reg .pred p; \n\t"
                  "    isspacep.global p, %1; \n\t"
                  "    selp.u32 %0, 1, 0, p;  \n\t"


#line 440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"
                  "} \n\t" : "=r"(ret) : "r"(ptr));
#line 442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"

    return ret;
}

#line 447 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"

#line 449 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"

#line 451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"
#line 6390 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"






























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"



extern "C"
{
    
    
}











#line 86 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"







static __declspec(__device__) __inline int __shfl(int var, int srcLane, int width=32) {
	int ret, c;
	c = ((32-width) << 8) | 0x1f;
	asm volatile ("shfl.idx.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(var), "r"(srcLane), "r"(c));
	return ret;
}

static __declspec(__device__) __inline int __shfl_up(int var, unsigned int delta, int width=32) {
	int ret, c;
	c = (32-width) << 8;
	asm volatile ("shfl.up.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(var), "r"(delta), "r"(c));
	return ret;
}

static __declspec(__device__) __inline int __shfl_down(int var, unsigned int delta, int width=32) {
	int ret, c;
	c = ((32-width) << 8) | 0x1f;
	asm volatile ("shfl.down.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(var), "r"(delta), "r"(c));
	return ret;
}

static __declspec(__device__) __inline int __shfl_xor(int var, int laneMask, int width=32) {
	int ret, c;
	c = ((32-width) << 8) | 0x1f;
	asm volatile ("shfl.bfly.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(var), "r"(laneMask), "r"(c));
	return ret;
}

static __declspec(__device__) __inline float __shfl(float var, int srcLane, int width=32) {
	float ret;
    int c;
	c = ((32-width) << 8) | 0x1f;
	asm volatile ("shfl.idx.b32 %0, %1, %2, %3;" : "=f"(ret) : "f"(var), "r"(srcLane), "r"(c));
	return ret;
}

static __declspec(__device__) __inline float __shfl_up(float var, unsigned int delta, int width=32) {
	float ret;
    int c;
	c = (32-width) << 8;
	asm volatile ("shfl.up.b32 %0, %1, %2, %3;" : "=f"(ret) : "f"(var), "r"(delta), "r"(c));
	return ret;
}

static __declspec(__device__) __inline float __shfl_down(float var, unsigned int delta, int width=32) {
	float ret;
    int c;
	c = ((32-width) << 8) | 0x1f;
	asm volatile ("shfl.down.b32 %0, %1, %2, %3;" : "=f"(ret) : "f"(var), "r"(delta), "r"(c));
	return ret;
}

static __declspec(__device__) __inline float __shfl_xor(float var, int laneMask, int width=32) {
	float ret;
    int c;
	c = ((32-width) << 8) | 0x1f;
	asm volatile ("shfl.bfly.b32 %0, %1, %2, %3;" : "=f"(ret) : "f"(var), "r"(laneMask), "r"(c));
	return ret;
}




#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"

#line 159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"

#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"

#line 163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"
#line 6391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"






























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"



extern "C"
{
    
    
}













#line 88 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"

#line 90 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"

static __declspec(__device__) __inline char __ldg(const char *ptr) { unsigned int ret; asm volatile ("ld.global.nc.s8 %0, [%1];"  : "=r"(ret) : "r" (ptr)); return (char)ret; }
static __declspec(__device__) __inline short __ldg(const short *ptr) { unsigned short ret; asm volatile ("ld.global.nc.s16 %0, [%1];"  : "=h"(ret) : "r" (ptr)); return (short)ret; }
static __declspec(__device__) __inline int __ldg(const int *ptr) { unsigned int ret; asm volatile ("ld.global.nc.s32 %0, [%1];"  : "=r"(ret) : "r" (ptr)); return (int)ret; }
static __declspec(__device__) __inline long long __ldg(const long long *ptr) { unsigned long long ret; asm volatile ("ld.global.nc.s64 %0, [%1];"  : "=l"(ret) : "r" (ptr)); return (long long)ret; }
static __declspec(__device__) __inline char2 __ldg(const char2 *ptr) { char2 ret; int2 tmp; asm volatile ("ld.global.nc.v2.s8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "r" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __declspec(__device__) __inline char4 __ldg(const char4 *ptr) { char4 ret; int4 tmp; asm volatile ("ld.global.nc.v4.s8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "r" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __declspec(__device__) __inline short2 __ldg(const short2 *ptr) { short2 ret; asm volatile ("ld.global.nc.v2.s16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline short4 __ldg(const short4 *ptr) { short4 ret; asm volatile ("ld.global.nc.v4.s16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline int2 __ldg(const int2 *ptr) { int2 ret; asm volatile ("ld.global.nc.v2.s32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline int4 __ldg(const int4 *ptr) { int4 ret; asm volatile ("ld.global.nc.v4.s32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline longlong2 __ldg(const longlong2 *ptr) { longlong2 ret; asm volatile ("ld.global.nc.v2.s64 %0, [%1];"  : "=l"(ret.x), "=l"(ret.y) : "r" (ptr)); return ret; }

static __declspec(__device__) __inline unsigned char __ldg(const unsigned char *ptr) { unsigned int ret; asm volatile ("ld.global.nc.u8 %0, [%1];"  : "=r"(ret) : "r" (ptr));  return (unsigned char)ret; }
static __declspec(__device__) __inline unsigned short __ldg(const unsigned short *ptr) { unsigned short ret; asm volatile ("ld.global.nc.u16 %0, [%1];"  : "=h"(ret) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline unsigned int __ldg(const unsigned int *ptr) { unsigned int ret; asm volatile ("ld.global.nc.u32 %0, [%1];"  : "=r"(ret) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline unsigned long long __ldg(const unsigned long long *ptr) { unsigned long long ret; asm volatile ("ld.global.nc.u64 %0, [%1];"  : "=l"(ret) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline uchar2 __ldg(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm volatile ("ld.global.nc.v2.u8 {%0,%1}, [%2];"  : "=r"(tmp.x), "=r"(tmp.y) : "r" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __declspec(__device__) __inline uchar4 __ldg(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm volatile ("ld.global.nc.v4.u8 {%0,%1,%2,%3}, [%4];"  : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "r" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __declspec(__device__) __inline ushort2 __ldg(const ushort2 *ptr) { ushort2 ret; asm volatile ("ld.global.nc.v2.u16 {%0,%1}, [%2];"  : "=h"(ret.x), "=h"(ret.y) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline ushort4 __ldg(const ushort4 *ptr) { ushort4 ret; asm volatile ("ld.global.nc.v4.u16 {%0,%1,%2,%3}, [%4];"  : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline uint2 __ldg(const uint2 *ptr) { uint2 ret; asm volatile ("ld.global.nc.v2.u32 {%0,%1}, [%2];"  : "=r"(ret.x), "=r"(ret.y) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline uint4 __ldg(const uint4 *ptr) { uint4 ret; asm volatile ("ld.global.nc.v4.u32 {%0,%1,%2,%3}, [%4];"  : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline ulonglong2 __ldg(const ulonglong2 *ptr) { ulonglong2 ret; asm volatile ("ld.global.nc.v2.u64 %0, [%1];"  : "=l"(ret.x), "=l"(ret.y) : "r" (ptr)); return ret; }

static __declspec(__device__) __inline float __ldg(const float *ptr) { float ret; asm volatile ("ld.global.nc.f32 %0, [%1];"  : "=f"(ret) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline double __ldg(const double *ptr) { double ret; asm volatile ("ld.global.nc.f64 %0, [%1];"  : "=d"(ret) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline float2 __ldg(const float2 *ptr) { float2 ret; asm volatile ("ld.global.nc.v2.f32 {%0,%1}, [%2];"  : "=f"(ret.x), "=f"(ret.y) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline float4 __ldg(const float4 *ptr) { float4 ret; asm volatile ("ld.global.nc.v4.f32 {%0,%1,%2,%3}, [%4];"  : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "r" (ptr)); return ret; }
static __declspec(__device__) __inline double2 __ldg(const double2 *ptr) { double2 ret; asm volatile ("ld.global.nc.v2.f64 {%0,%1}, [%2];"  : "=d"(ret.x), "=d"(ret.y) : "r" (ptr)); return ret; }










static __declspec(__device__) inline unsigned int __funnelshift_l(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}
static __declspec(__device__) inline unsigned int __funnelshift_lc(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.l.clamp.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}


static __declspec(__device__) inline unsigned int __funnelshift_r(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.r.wrap.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}
static __declspec(__device__) inline unsigned int __funnelshift_rc(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.r.clamp.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}


#line 159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"

#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"

#line 163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
#line 6392 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_35_intrinsics.h"














































































































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"

































































































































































#line 163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_35_intrinsics.h"



#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_35_intrinsics.h"

#line 6393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_surface_types.h"

































































































#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_surface_types.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"




















































































































































































































































































































#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 67 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"






extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surf1Dreadc1(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surf1Dreadc2(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surf1Dreadc4(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surf1Dreads1(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surf1Dreads2(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surf1Dreads4(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surf1Dreadu1(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surf1Dreadu2(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surf1Dreadu4(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surf1Dreadl1(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surf1Dreadl2(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);








#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"




#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf1Dread(T *res, surface<void, 0x01> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = __surf1Dreadc1(surf, x, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(*(ushort1*)res = __surf1Dreads1(surf, x, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(*(uint1  *)res = __surf1Dreadu1(surf, x, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(*(uint2  *)res = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4  *)res = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surf1Dread(&tmp, surf, x, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surf1Dread(T *res, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf1Dread<T>(surf, x, mode);
}

template<>
__forceinline __declspec(__device__) char surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) signed char surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) char1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surf1Dreadc2(surf, x, cudaBoundaryModeTrap);
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadc2(surf, x, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surf1Dreadc4(surf, x, cudaBoundaryModeTrap);
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadc4(surf, x, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surf1Dreads1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreads1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) short1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surf1Dreads1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreads1(surf, x, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surf1Dreads2(surf, x, cudaBoundaryModeTrap);
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreads2(surf, x, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surf1Dreads4(surf, x, cudaBoundaryModeTrap);
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreads4(surf, x, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) int1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uint1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) long long int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) longlong2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surf1Dreadl2(surf, x, cudaBoundaryModeTrap);
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadl2(surf, x, cudaBoundaryModeTrap);
}



template<>
__forceinline __declspec(__device__) long int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) long1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) long2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) float1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x));
}

template<>
__forceinline __declspec(__device__) float2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}








extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surf2Dreadc1(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surf2Dreadc2(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surf2Dreadc4(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surf2Dreads1(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surf2Dreads2(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surf2Dreads4(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surf2Dreadu1(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surf2Dreadu2(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surf2Dreadu4(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surf2Dreadl1(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surf2Dreadl2(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);








#line 441 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"




#line 446 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf2Dread(T *res, surface<void, 0x02> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(*(ushort1*)res = __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(*(uint1  *)res = __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(*(uint2  *)res = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4  *)res = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surf2Dread(&tmp, surf, x, y, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surf2Dread(T *res, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf2Dread<T>(surf, x, y, mode);
}

template<>
__forceinline __declspec(__device__) char surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) signed char surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) char1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap);
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) short1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap);
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) int1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uint1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) long long int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) longlong2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap);
}



template<>
__forceinline __declspec(__device__) long int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) long1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) long2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) float1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x));
}

template<>
__forceinline __declspec(__device__) float2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}








extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surf3Dreadc1(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surf3Dreadc2(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surf3Dreadc4(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surf3Dreads1(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surf3Dreads2(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surf3Dreads4(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surf3Dreadu1(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surf3Dreadu2(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surf3Dreadu4(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surf3Dreadl1(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surf3Dreadl2(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);








#line 789 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"




#line 794 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf3Dread(T *res, surface<void, 0x03> surf, int x, int y, int z, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(*(ushort1*)res = __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(*(uint1  *)res = __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(*(uint2  *)res = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4  *)res = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surf3Dread(&tmp, surf, x, y, z, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surf3Dread(T *res, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf3Dread<T>(surf, x, y, z, mode);
}

template<>
__forceinline __declspec(__device__) char surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) signed char surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) char1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) short1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) int1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uint1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) long long int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) longlong2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap);
}



template<>
__forceinline __declspec(__device__) long int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) long1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) long2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 1081 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) float1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x));
}

template<>
__forceinline __declspec(__device__) float2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap);
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}








extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surf1DLayeredreadc1(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surf1DLayeredreadc2(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surf1DLayeredreadc4(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surf1DLayeredreads1(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surf1DLayeredreads2(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surf1DLayeredreads4(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surf1DLayeredreadu1(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surf1DLayeredreadu2(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surf1DLayeredreadu4(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surf1DLayeredreadl1(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surf1DLayeredreadl2(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);








#line 1137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"




#line 1142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf1DLayeredread(T *res, surface<void, 0xF1> surf, int x, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(*(ushort1*)res = __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(*(uint1  *)res = __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(*(uint2  *)res = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4  *)res = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surf1DLayeredread(&tmp, surf, x, layer, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surf1DLayeredread(T *res, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf1DLayeredread<T>(surf, x, layer, mode);
}

template<>
__forceinline __declspec(__device__) char surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) signed char surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) char1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) short1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) int1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uint1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) long long int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) longlong2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap);
}



template<>
__forceinline __declspec(__device__) long int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) long1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) long2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 1429 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) float1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x));
}

template<>
__forceinline __declspec(__device__) float2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap);
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}








extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surf2DLayeredreadc1(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surf2DLayeredreadc2(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surf2DLayeredreadc4(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surf2DLayeredreads1(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surf2DLayeredreads2(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surf2DLayeredreads4(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surf2DLayeredreadu1(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surf2DLayeredreadu2(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surf2DLayeredreadu4(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surf2DLayeredreadl1(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surf2DLayeredreadl2(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);








#line 1485 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"




#line 1490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf2DLayeredread(T *res, surface<void, 0xF2> surf, int x, int y, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(*(ushort1*)res = __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(*(uint1  *)res = __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(*(uint2  *)res = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4  *)res = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surf2DLayeredread(&tmp, surf, x, y, layer, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surf2DLayeredread(T *res, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf2DLayeredread<T>(surf, x, y, layer, mode);
}

template<>
__forceinline __declspec(__device__) char surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) signed char surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) char1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) short1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) int1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uint1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) long long int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) longlong2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap);
}



template<>
__forceinline __declspec(__device__) long int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) long1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) long2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 1777 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) float1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x));
}

template<>
__forceinline __declspec(__device__) float2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap);
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}








extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surfCubemapreadc1(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surfCubemapreadc2(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surfCubemapreadc4(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surfCubemapreads1(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surfCubemapreads2(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surfCubemapreads4(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surfCubemapreadu1(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surfCubemapreadu2(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surfCubemapreadu4(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surfCubemapreadl1(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surfCubemapreadl2(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);








#line 1833 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"




#line 1838 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surfCubemapread(T *res, surface<void, 0x0C> surf, int x, int y, int face, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(*(ushort1*)res = __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(*(uint1  *)res = __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(*(uint2  *)res = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4  *)res = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surfCubemapread(&tmp, surf, x, y, face, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surfCubemapread(T *res, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surfCubemapread<T>(surf, x, y, face, mode);
}

template<>
__forceinline __declspec(__device__) char surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) signed char surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) char1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) short1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) int1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uint1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) long long int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) longlong2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeTrap);
}



template<>
__forceinline __declspec(__device__) long int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) long1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) long2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 2125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) float1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x));
}

template<>
__forceinline __declspec(__device__) float2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap);
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}








extern __declspec(__device__) __declspec(__device_builtin__) uchar1     __surfCubemapLayeredreadc1(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar2     __surfCubemapLayeredreadc2(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uchar4     __surfCubemapLayeredreadc4(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort1    __surfCubemapLayeredreads1(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort2    __surfCubemapLayeredreads2(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ushort4    __surfCubemapLayeredreads4(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint1      __surfCubemapLayeredreadu1(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint2      __surfCubemapLayeredreadu2(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) uint4      __surfCubemapLayeredreadu4(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong1 __surfCubemapLayeredreadl1(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) ulonglong2 __surfCubemapLayeredreadl2(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);








#line 2181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"





#line 2187 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surfCubemapLayeredread(T *res, surface<void, 0xFC> surf, int x, int y, int layerFace, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(*(ushort1*)res = __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(*(uint1  *)res = __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(*(uint2  *)res = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4  *)res = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) T surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surfCubemapLayeredread(&tmp, surf, x, y, layerFace, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __forceinline __declspec(__device__) void surfCubemapLayeredread(T *res, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surfCubemapLayeredread<T>(surf, x, y, layerFace, mode);
}

template<>
__forceinline __declspec(__device__) char surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) signed char surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned char surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) char1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uchar1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__forceinline __declspec(__device__) uchar2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) char4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__forceinline __declspec(__device__) uchar4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned short surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) short1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ushort1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__forceinline __declspec(__device__) ushort2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) short4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__forceinline __declspec(__device__) ushort4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) int1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) uint1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__forceinline __declspec(__device__) uint2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) int4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__forceinline __declspec(__device__) uint4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) long long int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long long int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) longlong1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulonglong1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__forceinline __declspec(__device__) longlong2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulonglong2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap);
}



template<>
__forceinline __declspec(__device__) long int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) unsigned long int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__forceinline __declspec(__device__) long1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) ulong1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) long2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) ulong2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__forceinline __declspec(__device__) long4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__forceinline __declspec(__device__) ulong4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 2474 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<>
__forceinline __declspec(__device__) float surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x);
}

template<>
__forceinline __declspec(__device__) float1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x));
}

template<>
__forceinline __declspec(__device__) float2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__forceinline __declspec(__device__) float4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap);
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}









extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwritec1(    uchar1 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwritec2(    uchar2 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwritec4(    uchar4 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwrites1(   ushort1 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwrites2(   ushort2 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwrites4(   ushort4 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwriteu1(     uint1 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwriteu2(     uint2 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwriteu4(     uint4 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwritel1(ulonglong1 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1Dwritel2(ulonglong2 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);








#line 2531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"




#line 2536 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf1Dwrite(T val, surface<void, 0x01> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(__surf1Dwritec1(tmp.c1, surf, x, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(__surf1Dwrites1(tmp.s1, surf, x, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(__surf1Dwriteu1(tmp.u1, surf, x, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(__surf1Dwriteu2(tmp.u2, surf, x, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surf1Dwriteu4(tmp.u4, surf, x, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surf1Dwrite(T val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf1Dwrite(val, surf, x, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surf1Dwrite(char val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(signed char val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned char val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(make_uchar1(val), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(char1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(make_uchar1((unsigned char)val.x), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(uchar1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(val, surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(char2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(uchar2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec2(val, surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(char4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(uchar4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec4(val, surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(short val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites1(make_ushort1((unsigned short)val), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned short val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites1(make_ushort1(val), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(short1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites1(make_ushort1((unsigned short)val.x), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(ushort1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites1(val, surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(short2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(ushort2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites2(val, surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(short4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(ushort4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites4(val, surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1(val), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(int1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(uint1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(val, surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(int2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(uint2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(val, surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(int4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(uint4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(val, surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(long long int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned long long int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel1(make_ulonglong1(val), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(longlong1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulonglong1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel1(val, surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(longlong2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulonglong2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel2(val, surf, x, cudaBoundaryModeTrap);
}



static __forceinline __declspec(__device__) void surf1Dwrite(long int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned long int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(long1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulong1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(long2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulong2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(long4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulong4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeTrap);
}

#line 2764 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surf1Dwrite(float val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(float1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(float2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1Dwrite(float4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, cudaBoundaryModeTrap);
}









extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwritec1(    uchar1 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwritec2(    uchar2 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwritec4(    uchar4 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwrites1(   ushort1 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwrites2(   ushort2 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwrites4(   ushort4 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwriteu1(     uint1 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwriteu2(     uint2 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwriteu4(     uint4 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwritel1(ulonglong1 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2Dwritel2(ulonglong2 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);








#line 2813 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"




#line 2818 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf2Dwrite(T val, surface<void, 0x02> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(__surf2Dwritec1(tmp.c1, surf, x, y, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(__surf2Dwrites1(tmp.s1, surf, x, y, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(__surf2Dwriteu1(tmp.u1, surf, x, y, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(__surf2Dwriteu2(tmp.u2, surf, x, y, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surf2Dwriteu4(tmp.u4, surf, x, y, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surf2Dwrite(T val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf2Dwrite(val, surf, x, y, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surf2Dwrite(char val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(signed char val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned char val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(make_uchar1(val), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(char1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(make_uchar1((unsigned char)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(uchar1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(val, surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(char2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(uchar2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec2(val, surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(char4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(uchar4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec4(val, surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(short val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites1(make_ushort1((unsigned short)val), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned short val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites1(make_ushort1(val), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(short1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites1(make_ushort1((unsigned short)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(ushort1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites1(val, surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(short2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(ushort2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites2(val, surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(short4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(ushort4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites4(val, surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1(val), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(int1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(uint1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(val, surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(int2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(uint2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(val, surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(int4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(uint4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(val, surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(long long int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned long long int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel1(make_ulonglong1(val), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(longlong1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulonglong1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel1(val, surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(longlong2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulonglong2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel2(val, surf, x, y, cudaBoundaryModeTrap);
}



static __forceinline __declspec(__device__) void surf2Dwrite(long int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned long int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(long1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulong1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(long2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulong2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(long4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulong4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeTrap);
}

#line 3046 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surf2Dwrite(float val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(float1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(float2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2Dwrite(float4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, cudaBoundaryModeTrap);
}









extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwritec1(    uchar1 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwritec2(    uchar2 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwritec4(    uchar4 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwrites1(   ushort1 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwrites2(   ushort2 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwrites4(   ushort4 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwriteu1(     uint1 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwriteu2(     uint2 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwriteu4(     uint4 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwritel1(ulonglong1 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf3Dwritel2(ulonglong2 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);








#line 3095 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"




#line 3100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf3Dwrite(T val, surface<void, 0x03> surf, int x, int y, int z, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(__surf3Dwritec1(tmp.c1, surf, x, y, z, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(__surf3Dwrites1(tmp.s1, surf, x, y, z, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(__surf3Dwriteu1(tmp.u1, surf, x, y, z, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(__surf3Dwriteu2(tmp.u2, surf, x, y, z, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surf3Dwriteu4(tmp.u4, surf, x, y, z, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surf3Dwrite(T val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf3Dwrite(val, surf, x, y, z, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surf3Dwrite(char val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(signed char val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned char val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec1(make_uchar1(val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(char1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec1(make_uchar1((unsigned char)val.x), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(uchar1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec1(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(char2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(uchar2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec2(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(char4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(uchar4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec4(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(short val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites1(make_ushort1((unsigned short)val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned short val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites1(make_ushort1(val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(short1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites1(make_ushort1((unsigned short)val.x), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(ushort1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites1(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(short2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(ushort2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites2(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(short4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(ushort4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites4(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1(val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(int1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(uint1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(int2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(uint2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu2(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(int4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(uint4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu4(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(long long int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned long long int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritel1(make_ulonglong1(val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(longlong1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulonglong1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritel1(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(longlong2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulonglong2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritel2(val, surf, x, y, z, cudaBoundaryModeTrap);
}



static __forceinline __declspec(__device__) void surf3Dwrite(long int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned long int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(long1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulong1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(long2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulong2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(long4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulong4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeTrap);
}

#line 3328 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surf3Dwrite(float val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(float1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(float2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, z, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf3Dwrite(float4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, z, cudaBoundaryModeTrap);
}









extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwritec1(    uchar1 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwritec2(    uchar2 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwritec4(    uchar4 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwrites1(   ushort1 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwrites2(   ushort2 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwrites4(   ushort4 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwriteu1(     uint1 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwriteu2(     uint2 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwriteu4(     uint4 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwritel1(ulonglong1 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf1DLayeredwritel2(ulonglong2 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);








#line 3377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"




#line 3382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf1DLayeredwrite(T val, surface<void, 0xF1> surf, int x, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(__surf1DLayeredwritec1(tmp.c1, surf, x, layer, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(__surf1DLayeredwrites1(tmp.s1, surf, x, layer, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(__surf1DLayeredwriteu1(tmp.u1, surf, x, layer, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(__surf1DLayeredwriteu2(tmp.u2, surf, x, layer, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surf1DLayeredwriteu4(tmp.u4, surf, x, layer, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surf1DLayeredwrite(T val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf1DLayeredwrite(val, surf, x, layer, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surf1DLayeredwrite(char val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(signed char val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned char val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec1(make_uchar1(val), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(char1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uchar1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec1(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(char2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uchar2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec2(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(char4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uchar4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec4(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned short val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites1(make_ushort1(val), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ushort1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites1(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ushort2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites2(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ushort4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites4(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1(val), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uint1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uint2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu2(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uint4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu4(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(long long int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned long long int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritel1(make_ulonglong1(val), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(longlong1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulonglong1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritel1(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(longlong2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulonglong2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritel2(val, surf, x, layer, cudaBoundaryModeTrap);
}



static __forceinline __declspec(__device__) void surf1DLayeredwrite(long int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned long int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(long1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulong1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(long2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulong2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(long4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulong4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeTrap);
}

#line 3610 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, layer, cudaBoundaryModeTrap);
}









extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwritec1(    uchar1 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwritec2(    uchar2 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwritec4(    uchar4 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwrites1(   ushort1 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwrites2(   ushort2 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwrites4(   ushort4 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwriteu1(     uint1 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwriteu2(     uint2 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwriteu4(     uint4 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwritel1(ulonglong1 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surf2DLayeredwritel2(ulonglong2 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);








#line 3659 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"




#line 3664 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surf2DLayeredwrite(T val, surface<void, 0xF2> surf, int x, int y, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(__surf2DLayeredwritec1(tmp.c1, surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(__surf2DLayeredwrites1(tmp.s1, surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(__surf2DLayeredwriteu1(tmp.u1, surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(__surf2DLayeredwriteu2(tmp.u2, surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surf2DLayeredwriteu4(tmp.u4, surf, x, y, layer, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surf2DLayeredwrite(T val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf2DLayeredwrite(val, surf, x, y, layer, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surf2DLayeredwrite(char val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(signed char val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned char val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec1(make_uchar1(val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(char1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uchar1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec1(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(char2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uchar2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec2(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(char4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uchar4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec4(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned short val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites1(make_ushort1(val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ushort1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites1(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ushort2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites2(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ushort4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites4(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1(val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uint1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uint2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu2(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uint4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu4(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(long long int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned long long int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(longlong1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulonglong1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritel1(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(longlong2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulonglong2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritel2(val, surf, x, y, layer, cudaBoundaryModeTrap);
}



static __forceinline __declspec(__device__) void surf2DLayeredwrite(long int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned long int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(long1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulong1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(long2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulong2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(long4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulong4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeTrap);
}

#line 3892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, layer, cudaBoundaryModeTrap);
}








extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwritec1(    uchar1 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwritec2(    uchar2 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwritec4(    uchar4 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwrites1(   ushort1 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwrites2(   ushort2 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwrites4(   ushort4 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwriteu1(     uint1 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwriteu2(     uint2 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwriteu4(     uint4 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwritel1(ulonglong1 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapwritel2(ulonglong2 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);








#line 3940 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"





#line 3946 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surfCubemapwrite(T val, surface<void, 0x0C> surf, int x, int y, int face, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(__surfCubemapwritec1(tmp.c1, surf, x, y, face, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(__surfCubemapwrites1(tmp.s1, surf, x, y, face, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(__surfCubemapwriteu1(tmp.u1, surf, x, y, face, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(__surfCubemapwriteu2(tmp.u2, surf, x, y, face, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surfCubemapwriteu4(tmp.u4, surf, x, y, face, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surfCubemapwrite(T val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surfCubemapwrite(val, surf, x, y, face, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surfCubemapwrite(char val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(signed char val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned char val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec1(make_uchar1(val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(char1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec1(make_uchar1((unsigned char)val.x), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uchar1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec1(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(char2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uchar2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec2(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(char4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uchar4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec4(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites1(make_ushort1((unsigned short)val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned short val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites1(make_ushort1(val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites1(make_ushort1((unsigned short)val.x), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ushort1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites1(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ushort2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites2(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ushort4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites4(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1(val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uint1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uint2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu2(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uint4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu4(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(long long int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned long long int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritel1(make_ulonglong1(val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(longlong1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulonglong1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritel1(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(longlong2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulonglong2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritel2(val, surf, x, y, face, cudaBoundaryModeTrap);
}



static __forceinline __declspec(__device__) void surfCubemapwrite(long int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned long int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(long1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulong1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(long2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulong2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(long4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulong4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeTrap);
}

#line 4174 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surfCubemapwrite(float val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, face, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, face, cudaBoundaryModeTrap);
}








extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwritec1(    uchar1 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwritec2(    uchar2 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwritec4(    uchar4 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwrites1(   ushort1 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwrites2(   ushort2 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwrites4(   ushort4 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwriteu1(     uint1 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwriteu2(     uint2 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwriteu4(     uint4 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwritel1(ulonglong1 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __declspec(__device__) __declspec(__device_builtin__) void __surfCubemapLayeredwritel2(ulonglong2 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);








#line 4222 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"





#line 4228 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

template<class T>
static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(T val, surface<void, 0xFC> surf, int x, int y, int layerFace, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(__surfCubemapLayeredwritec1(tmp.c1, surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(__surfCubemapLayeredwrites1(tmp.s1, surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(__surfCubemapLayeredwriteu1(tmp.u1, surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(__surfCubemapLayeredwriteu2(tmp.u2, surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surfCubemapLayeredwriteu4(tmp.u4, surf, x, y, layerFace, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(T val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surfCubemapLayeredwrite(val, surf, x, y, layerFace, (int)sizeof(T), mode);
}


static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(signed char val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned char val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec1(make_uchar1(val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uchar1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec1(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uchar2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec2(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uchar4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec4(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned short val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites1(make_ushort1(val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ushort1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites1(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ushort2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites2(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ushort4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites4(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1(val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uint1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uint2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu2(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uint4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu4(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(long long int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned long long int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritel1(make_ulonglong1(val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(longlong1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulonglong1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritel1(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(longlong2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulonglong2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritel2(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}



static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(long int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned long int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(long1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulong1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(long2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulong2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(long4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulong4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

#line 4456 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap);
}


























































































































































































































































































#line 4759 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

#line 4761 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"

#line 6394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"




























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_texture_types.h"









































































































#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_texture_types.h"
#line 63 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 64 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"




















































































































































































































































































































#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 67 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







template<class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchi(texture<T, 0x01, readMode> t, int4 i);
template<class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchi(texture<T, 0x01, readMode> t, int4 i);
template<class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchi(texture<T, 0x01, readMode> t, int4 i);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetch(texture<T, texType, readMode> t, float4 i, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetch(texture<T, texType, readMode> t, float4 i, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetch(texture<T, texType, readMode> t, float4 i, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchc(texture<T, texType, readMode> t, float4 i);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchc(texture<T, texType, readMode> t, float4 i);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchc(texture<T, texType, readMode> t, float4 i);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchl(texture<T, texType, readMode> t, float4 i, int l, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchl(texture<T, texType, readMode> t, float4 i, int l, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchl(texture<T, texType, readMode> t, float4 i, int l, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchlc(texture<T, texType, readMode> t, float4 i, int l);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchlc(texture<T, texType, readMode> t, float4 i, int l);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchlc(texture<T, texType, readMode> t, float4 i, int l);







static __forceinline __declspec(__device__) char tex1Dfetch(texture<char, 0x01, cudaReadModeElementType> t, int x)
{


#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchi(t, make_int4(x, 0, 0, 0));
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1Dfetch(texture<signed char, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1Dfetch(texture<unsigned char, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1Dfetch(texture<char1, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1Dfetch(texture<uchar1, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1Dfetch(texture<char2, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1Dfetch(texture<uchar2, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1Dfetch(texture<char4, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1Dfetch(texture<uchar4, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1Dfetch(texture<short, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1Dfetch(texture<unsigned short, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1Dfetch(texture<short1, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1Dfetch(texture<ushort1, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1Dfetch(texture<short2, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1Dfetch(texture<ushort2, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1Dfetch(texture<short4, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1Dfetch(texture<ushort4, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1Dfetch(texture<int, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1Dfetch(texture<unsigned int, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1Dfetch(texture<int1, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1Dfetch(texture<uint1, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1Dfetch(texture<int2, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1Dfetch(texture<uint2, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1Dfetch(texture<int4, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1Dfetch(texture<uint4, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex1Dfetch(texture<long, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1Dfetch(texture<unsigned long, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1Dfetch(texture<long1, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1Dfetch(texture<ulong1, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1Dfetch(texture<long2, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1Dfetch(texture<ulong2, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1Dfetch(texture<long4, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1Dfetch(texture<ulong4, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 352 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1Dfetch(texture<float, 0x01, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1Dfetch(texture<float1, 0x01, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1Dfetch(texture<float2, 0x01, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1Dfetch(texture<float4, 0x01, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1Dfetch(texture<char, 0x01, cudaReadModeNormalizedFloat> t, int x)
{


#line 398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
#line 400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1Dfetch(texture<signed char, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1Dfetch(texture<unsigned char, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1Dfetch(texture<char1, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1Dfetch(texture<uchar1, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1Dfetch(texture<char2, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1Dfetch(texture<uchar2, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1Dfetch(texture<char4, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1Dfetch(texture<uchar4, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1Dfetch(texture<short, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1Dfetch(texture<unsigned short, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1Dfetch(texture<short1, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1Dfetch(texture<ushort1, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1Dfetch(texture<short2, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1Dfetch(texture<ushort2, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1Dfetch(texture<short4, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1Dfetch(texture<ushort4, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v   = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex1D(texture<char, 0x01, cudaReadModeElementType> t, float x)
{


#line 550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetch(t, make_float4(x, 0, 0, 0));
#line 552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1D(texture<signed char, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1D(texture<unsigned char, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1D(texture<char1, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1D(texture<uchar1, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1D(texture<char2, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1D(texture<uchar2, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1D(texture<char4, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1D(texture<uchar4, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1D(texture<short, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1D(texture<unsigned short, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1D(texture<short1, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1D(texture<ushort1, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1D(texture<short2, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1D(texture<ushort2, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1D(texture<short4, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1D(texture<ushort4, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1D(texture<int, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1D(texture<unsigned int, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1D(texture<int1, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1D(texture<uint1, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1D(texture<int2, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1D(texture<uint2, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1D(texture<int4, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1D(texture<uint4, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}















static __forceinline __declspec(__device__) long tex1D(texture<long, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1D(texture<unsigned long, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1D(texture<long1, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1D(texture<ulong1, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1D(texture<long2, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1D(texture<ulong2, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1D(texture<long4, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1D(texture<ulong4, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1D(texture<float, 0x01, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1D(texture<float1, 0x01, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1D(texture<float2, 0x01, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1D(texture<float4, 0x01, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1D(texture<char, 0x01, cudaReadModeNormalizedFloat> t, float x)
{


#line 853 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
#line 855 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1D(texture<signed char, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1D(texture<unsigned char, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1D(texture<char1, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1D(texture<uchar1, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1D(texture<char2, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1D(texture<uchar2, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1D(texture<char4, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1D(texture<uchar4, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1D(texture<short, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1D(texture<unsigned short, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1D(texture<short1, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1D(texture<ushort1, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1D(texture<short2, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1D(texture<ushort2, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1D(texture<short4, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1D(texture<ushort4, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v   = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex2D(texture<char, 0x02, cudaReadModeElementType> t, float x, float y)
{


#line 1005 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetch(t, make_float4(x, y, 0, 0));
#line 1007 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex2D(texture<signed char, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex2D(texture<unsigned char, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex2D(texture<char1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex2D(texture<uchar1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex2D(texture<char2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex2D(texture<uchar2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex2D(texture<char4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex2D(texture<uchar4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex2D(texture<short, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex2D(texture<unsigned short, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex2D(texture<short1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex2D(texture<ushort1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex2D(texture<short2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex2D(texture<ushort2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex2D(texture<short4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex2D(texture<ushort4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex2D(texture<int, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex2D(texture<unsigned int, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex2D(texture<int1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex2D(texture<uint1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex2D(texture<int2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex2D(texture<uint2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex2D(texture<int4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex2D(texture<uint4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex2D(texture<long, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex2D(texture<unsigned long, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex2D(texture<long1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex2D(texture<ulong1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex2D(texture<long2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex2D(texture<ulong2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex2D(texture<long4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex2D(texture<ulong4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 1256 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex2D(texture<float, 0x02, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex2D(texture<float1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex2D(texture<float2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex2D(texture<float4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex2D(texture<char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{


#line 1302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
#line 1304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2D(texture<signed char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2D(texture<unsigned char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2D(texture<char1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2D(texture<uchar1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2D(texture<char2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2D(texture<uchar2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2D(texture<char4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2D(texture<uchar4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex2D(texture<short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2D(texture<unsigned short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2D(texture<short1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2D(texture<ushort1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2D(texture<short2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2D(texture<ushort2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2D(texture<short4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2D(texture<ushort4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v   = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex1DLayered(texture<char, 0xF1, cudaReadModeElementType> t, float x, int layer)
{


#line 1454 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
#line 1456 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1DLayered(texture<signed char, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1DLayered(texture<unsigned char, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1DLayered(texture<char1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1DLayered(texture<uchar1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1DLayered(texture<char2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1DLayered(texture<uchar2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1DLayered(texture<char4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1DLayered(texture<uchar4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1DLayered(texture<short, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1DLayered(texture<unsigned short, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1DLayered(texture<short1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1DLayered(texture<ushort1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1DLayered(texture<short2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1DLayered(texture<ushort2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1DLayered(texture<short4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1DLayered(texture<ushort4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1DLayered(texture<int, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1DLayered(texture<unsigned int, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1DLayered(texture<int1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1DLayered(texture<uint1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1DLayered(texture<int2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1DLayered(texture<uint2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1DLayered(texture<int4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1DLayered(texture<uint4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex1DLayered(texture<long, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1DLayered(texture<unsigned long, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1DLayered(texture<long1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1DLayered(texture<ulong1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1DLayered(texture<long2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1DLayered(texture<ulong2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1DLayered(texture<long4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1DLayered(texture<ulong4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 1705 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1DLayered(texture<float, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayered(texture<float1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayered(texture<float2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayered(texture<float4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1DLayered(texture<char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{


#line 1751 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
#line 1753 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayered(texture<signed char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayered(texture<unsigned char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayered(texture<char1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLayered(texture<uchar1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayered(texture<char2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLayered(texture<uchar2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayered(texture<char4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLayered(texture<uchar4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1DLayered(texture<short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayered(texture<unsigned short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayered(texture<short1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLayered(texture<ushort1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayered(texture<short2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLayered(texture<ushort2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayered(texture<short4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLayered(texture<ushort4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v   = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex2DLayered(texture<char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{


#line 1903 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
#line 1905 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex2DLayered(texture<signed char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex2DLayered(texture<unsigned char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex2DLayered(texture<char1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex2DLayered(texture<uchar1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex2DLayered(texture<char2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex2DLayered(texture<uchar2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex2DLayered(texture<char4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex2DLayered(texture<uchar4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex2DLayered(texture<short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex2DLayered(texture<unsigned short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex2DLayered(texture<short1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex2DLayered(texture<ushort1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex2DLayered(texture<short2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex2DLayered(texture<ushort2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex2DLayered(texture<short4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex2DLayered(texture<ushort4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex2DLayered(texture<int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex2DLayered(texture<unsigned int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex2DLayered(texture<int1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex2DLayered(texture<uint1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex2DLayered(texture<int2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex2DLayered(texture<uint2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex2DLayered(texture<int4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex2DLayered(texture<uint4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex2DLayered(texture<long, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex2DLayered(texture<unsigned long, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex2DLayered(texture<long1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex2DLayered(texture<ulong1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex2DLayered(texture<long2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex2DLayered(texture<ulong2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex2DLayered(texture<long4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex2DLayered(texture<ulong4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 2154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex2DLayered(texture<float, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayered(texture<float1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayered(texture<float2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayered(texture<float4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex2DLayered(texture<char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{


#line 2200 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
#line 2202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayered(texture<signed char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayered(texture<unsigned char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayered(texture<char1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLayered(texture<uchar1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayered(texture<char2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLayered(texture<uchar2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayered(texture<char4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLayered(texture<uchar4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex2DLayered(texture<short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayered(texture<unsigned short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayered(texture<short1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLayered(texture<ushort1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayered(texture<short2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLayered(texture<ushort2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v  = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayered(texture<short4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v   = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLayered(texture<ushort4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v   = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex3D(texture<char, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{


#line 2352 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetch(t, make_float4(x, y, z, 0));
#line 2354 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex3D(texture<signed char, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex3D(texture<unsigned char, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex3D(texture<char1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex3D(texture<uchar1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex3D(texture<char2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex3D(texture<uchar2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex3D(texture<char4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex3D(texture<uchar4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex3D(texture<short, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex3D(texture<unsigned short, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex3D(texture<short1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex3D(texture<ushort1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex3D(texture<short2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex3D(texture<ushort2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex3D(texture<short4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex3D(texture<ushort4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex3D(texture<int, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex3D(texture<unsigned int, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex3D(texture<int1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex3D(texture<uint1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex3D(texture<int2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex3D(texture<uint2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex3D(texture<int4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex3D(texture<uint4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex3D(texture<long, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex3D(texture<unsigned long, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex3D(texture<long1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex3D(texture<ulong1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex3D(texture<long2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex3D(texture<ulong2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex3D(texture<long4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex3D(texture<ulong4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 2603 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex3D(texture<float, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex3D(texture<float1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex3D(texture<float2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex3D(texture<float4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex3D(texture<char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{


#line 2649 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
#line 2651 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3D(texture<signed char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3D(texture<unsigned char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex3D(texture<char1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex3D(texture<uchar1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex3D(texture<char2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex3D(texture<uchar2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex3D(texture<char4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex3D(texture<uchar4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex3D(texture<short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3D(texture<unsigned short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex3D(texture<short1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex3D(texture<ushort1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex3D(texture<short2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex3D(texture<ushort2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex3D(texture<short4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex3D(texture<ushort4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v   = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char texCubemap(texture<char, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{


#line 2801 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchc(t, make_float4(x, y, z, 0));
#line 2803 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char texCubemap(texture<signed char, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char texCubemap(texture<unsigned char, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 texCubemap(texture<char1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 texCubemap(texture<uchar1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 texCubemap(texture<char2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 texCubemap(texture<uchar2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 texCubemap(texture<char4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 texCubemap(texture<uchar4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short texCubemap(texture<short, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short texCubemap(texture<unsigned short, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 texCubemap(texture<short1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 texCubemap(texture<ushort1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 texCubemap(texture<short2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 texCubemap(texture<ushort2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 texCubemap(texture<short4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 texCubemap(texture<ushort4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int texCubemap(texture<int, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int texCubemap(texture<unsigned int, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 texCubemap(texture<int1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 texCubemap(texture<uint1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 texCubemap(texture<int2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 texCubemap(texture<uint2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 texCubemap(texture<int4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 texCubemap(texture<uint4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long texCubemap(texture<long, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long texCubemap(texture<unsigned long, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 texCubemap(texture<long1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 texCubemap(texture<ulong1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 texCubemap(texture<long2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 texCubemap(texture<ulong2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 texCubemap(texture<long4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 texCubemap(texture<ulong4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 3052 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float texCubemap(texture<float, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetchc(t, make_float4(x, y, z, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 texCubemap(texture<float1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetchc(t, make_float4(x, y, z, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 texCubemap(texture<float2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetchc(t, make_float4(x, y, z, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 texCubemap(texture<float4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetchc(t, make_float4(x, y, z, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float texCubemap(texture<char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{


#line 3098 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
#line 3100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemap(texture<signed char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemap(texture<unsigned char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemap(texture<char1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemap(texture<uchar1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemap(texture<char2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemap(texture<uchar2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemap(texture<char4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemap(texture<uchar4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float texCubemap(texture<short, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemap(texture<unsigned short, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemap(texture<short1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemap(texture<ushort1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemap(texture<short2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemap(texture<ushort2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemap(texture<short4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemap(texture<ushort4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v   = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char texCubemapLayered(texture<char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{


#line 3250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
#line 3252 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char texCubemapLayered(texture<signed char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char texCubemapLayered(texture<unsigned char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 texCubemapLayered(texture<char1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 texCubemapLayered(texture<uchar1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 texCubemapLayered(texture<char2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 texCubemapLayered(texture<uchar2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 texCubemapLayered(texture<char4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 texCubemapLayered(texture<uchar4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short texCubemapLayered(texture<short, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short texCubemapLayered(texture<unsigned short, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 texCubemapLayered(texture<short1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 texCubemapLayered(texture<ushort1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 texCubemapLayered(texture<short2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 texCubemapLayered(texture<ushort2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 texCubemapLayered(texture<short4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 texCubemapLayered(texture<ushort4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int texCubemapLayered(texture<int, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int texCubemapLayered(texture<unsigned int, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 texCubemapLayered(texture<int1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 texCubemapLayered(texture<uint1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 texCubemapLayered(texture<int2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 texCubemapLayered(texture<uint2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 texCubemapLayered(texture<int4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 texCubemapLayered(texture<uint4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long texCubemapLayered(texture<long, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long texCubemapLayered(texture<unsigned long, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 texCubemapLayered(texture<long1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 texCubemapLayered(texture<ulong1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 texCubemapLayered(texture<long2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 texCubemapLayered(texture<ulong2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 texCubemapLayered(texture<long4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 texCubemapLayered(texture<ulong4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 3501 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float texCubemapLayered(texture<float, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer);

  return v.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLayered(texture<float1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLayered(texture<float2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLayered(texture<float4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float texCubemapLayered(texture<char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{


#line 3547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
#line 3549 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLayered(texture<signed char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLayered(texture<unsigned char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLayered(texture<char1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemapLayered(texture<uchar1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLayered(texture<char2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemapLayered(texture<uchar2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLayered(texture<char4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemapLayered(texture<uchar4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float texCubemapLayered(texture<short, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLayered(texture<unsigned short, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLayered(texture<short1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemapLayered(texture<ushort1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLayered(texture<short2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemapLayered(texture<ushort2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v  = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLayered(texture<short4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v   = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemapLayered(texture<ushort4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v   = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}






















































































#line 3774 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"











template<int comp, class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itex2Dgather(texture<T, 0x02, readMode> t, float2 i, int c = comp);
template<int comp, class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utex2Dgather(texture<T, 0x02, readMode> t, float2 i, int c = comp);
template<int comp, class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftex2Dgather(texture<T, 0x02, readMode> t, float2 i, int c = comp);



















static __forceinline __declspec(__device__) char4 tex2Dgather(texture<char, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) char4 tex2Dgather(texture<signed char, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) uchar4 tex2Dgather(texture<unsigned char, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) char4 tex2Dgather(texture<char1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) uchar4 tex2Dgather(texture<uchar1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) char4 tex2Dgather(texture<char2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) uchar4 tex2Dgather(texture<uchar2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) char4 tex2Dgather(texture<char3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) uchar4 tex2Dgather(texture<uchar3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) char4 tex2Dgather(texture<char4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) uchar4 tex2Dgather(texture<uchar4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) short4 tex2Dgather(texture<signed short, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) ushort4 tex2Dgather(texture<unsigned short, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) short4 tex2Dgather(texture<short1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) ushort4 tex2Dgather(texture<ushort1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) short4 tex2Dgather(texture<short2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) ushort4 tex2Dgather(texture<ushort2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) short4 tex2Dgather(texture<short3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) ushort4 tex2Dgather(texture<ushort3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) short4 tex2Dgather(texture<short4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) ushort4 tex2Dgather(texture<ushort4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __forceinline __declspec(__device__) int4 tex2Dgather(texture<signed int, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) uint4 tex2Dgather(texture<unsigned int, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) int4 tex2Dgather(texture<int1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) uint4 tex2Dgather(texture<uint1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) int4 tex2Dgather(texture<int2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) uint4 tex2Dgather(texture<uint2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) int4 tex2Dgather(texture<int3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) uint4 tex2Dgather(texture<uint3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) int4 tex2Dgather(texture<int4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return v; } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) uint4 tex2Dgather(texture<uint4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return v; } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<float, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<float1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<float2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { float4 v = __ftex2Dgather<1>(t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<float3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { float4 v = __ftex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { float4 v = __ftex2Dgather<1>(t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<float4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { float4 v = __ftex2Dgather<3>(t, make_float2(x, y)); return v; } else if (comp == 2) { float4 v = __ftex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { float4 v = __ftex2Dgather<1>(t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}








static __forceinline __declspec(__device__) float4 tex2Dgather(texture<char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<signed char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<unsigned char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<char1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<uchar1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<char2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<uchar2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<char3, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<uchar3, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<char4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<uchar4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<signed short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<unsigned short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<short1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<ushort1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<short2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<ushort2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<short3, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<ushort3, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<short4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __forceinline __declspec(__device__) float4 tex2Dgather(texture<ushort4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}







template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchlod(texture<T, texType, readMode> t, float4 i, float level, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchlod(texture<T, texType, readMode> t, float4 i, float level, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchlod(texture<T, texType, readMode> t, float4 i, float level, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchlodc(texture<T, texType, readMode> t, float4 i, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchlodc(texture<T, texType, readMode> t, float4 i, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchlodc(texture<T, texType, readMode> t, float4 i, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchlodl(texture<T, texType, readMode> t, float4 i, int l, float level, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchlodl(texture<T, texType, readMode> t, float4 i, int l, float level, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchlodl(texture<T, texType, readMode> t, float4 i, int l, float level, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchlodlc(texture<T, texType, readMode> t, float4 i, int l, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchlodlc(texture<T, texType, readMode> t, float4 i, int l, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchlodlc(texture<T, texType, readMode> t, float4 i, int l, float level);







static __forceinline __declspec(__device__) char tex1DLod(texture<char, 0x01, cudaReadModeElementType> t, float x, float level)
{


#line 4129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
#line 4131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1DLod(texture<signed char, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1DLod(texture<unsigned char, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1DLod(texture<char1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1DLod(texture<uchar1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1DLod(texture<char2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1DLod(texture<uchar2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1DLod(texture<char4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1DLod(texture<uchar4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1DLod(texture<short, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1DLod(texture<unsigned short, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1DLod(texture<short1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1DLod(texture<ushort1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1DLod(texture<short2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1DLod(texture<ushort2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1DLod(texture<short4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1DLod(texture<ushort4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1DLod(texture<int, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1DLod(texture<unsigned int, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1DLod(texture<int1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1DLod(texture<uint1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1DLod(texture<int2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1DLod(texture<uint2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1DLod(texture<int4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1DLod(texture<uint4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uint4(v.x, v.y, v.z, v.w);
}















static __forceinline __declspec(__device__) long tex1DLod(texture<long, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1DLod(texture<unsigned long, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1DLod(texture<long1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1DLod(texture<ulong1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1DLod(texture<long2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1DLod(texture<ulong2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1DLod(texture<long4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1DLod(texture<ulong4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 4386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1DLod(texture<float, 0x01, cudaReadModeElementType> t, float x, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1DLod(texture<float1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1DLod(texture<float2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1DLod(texture<float4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1DLod(texture<char, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{


#line 4432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
#line 4434 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLod(texture<signed char, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLod(texture<unsigned char, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLod(texture<char1, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLod(texture<uchar1, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLod(texture<char2, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLod(texture<uchar2, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLod(texture<char4, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLod(texture<uchar4, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1DLod(texture<short, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLod(texture<unsigned short, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLod(texture<short1, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLod(texture<ushort1, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLod(texture<short2, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLod(texture<ushort2, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLod(texture<short4, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLod(texture<ushort4, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v   = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex2DLod(texture<char, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{


#line 4584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
#line 4586 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex2DLod(texture<signed char, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex2DLod(texture<unsigned char, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex2DLod(texture<char1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex2DLod(texture<uchar1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex2DLod(texture<char2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex2DLod(texture<uchar2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex2DLod(texture<char4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex2DLod(texture<uchar4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex2DLod(texture<short, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex2DLod(texture<unsigned short, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex2DLod(texture<short1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex2DLod(texture<ushort1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex2DLod(texture<short2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex2DLod(texture<ushort2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex2DLod(texture<short4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex2DLod(texture<ushort4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex2DLod(texture<int, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex2DLod(texture<unsigned int, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex2DLod(texture<int1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex2DLod(texture<uint1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex2DLod(texture<int2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex2DLod(texture<uint2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex2DLod(texture<int4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex2DLod(texture<uint4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex2DLod(texture<long, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex2DLod(texture<unsigned long, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex2DLod(texture<long1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex2DLod(texture<ulong1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex2DLod(texture<long2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex2DLod(texture<ulong2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex2DLod(texture<long4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex2DLod(texture<ulong4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 4835 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex2DLod(texture<float, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex2DLod(texture<float1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex2DLod(texture<float2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex2DLod(texture<float4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex2DLod(texture<char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{


#line 4881 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
#line 4883 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLod(texture<signed char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLod(texture<unsigned char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLod(texture<char1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLod(texture<uchar1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLod(texture<char2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLod(texture<uchar2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLod(texture<char4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLod(texture<uchar4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex2DLod(texture<short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLod(texture<unsigned short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLod(texture<short1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLod(texture<ushort1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLod(texture<short2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLod(texture<ushort2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLod(texture<short4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLod(texture<ushort4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v   = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex1DLayeredLod(texture<char, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{


#line 5033 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
#line 5035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1DLayeredLod(texture<signed char, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1DLayeredLod(texture<unsigned char, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1DLayeredLod(texture<char1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1DLayeredLod(texture<uchar1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1DLayeredLod(texture<char2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1DLayeredLod(texture<uchar2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1DLayeredLod(texture<char4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1DLayeredLod(texture<uchar4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1DLayeredLod(texture<short, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1DLayeredLod(texture<unsigned short, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1DLayeredLod(texture<short1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1DLayeredLod(texture<ushort1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1DLayeredLod(texture<short2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1DLayeredLod(texture<ushort2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1DLayeredLod(texture<short4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1DLayeredLod(texture<ushort4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1DLayeredLod(texture<int, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1DLayeredLod(texture<unsigned int, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1DLayeredLod(texture<int1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1DLayeredLod(texture<uint1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1DLayeredLod(texture<int2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1DLayeredLod(texture<uint2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1DLayeredLod(texture<int4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1DLayeredLod(texture<uint4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex1DLayeredLod(texture<long, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1DLayeredLod(texture<unsigned long, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1DLayeredLod(texture<long1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1DLayeredLod(texture<ulong1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1DLayeredLod(texture<long2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1DLayeredLod(texture<ulong2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1DLayeredLod(texture<long4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1DLayeredLod(texture<ulong4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 5284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1DLayeredLod(texture<float, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayeredLod(texture<float1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredLod(texture<float2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredLod(texture<float4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1DLayeredLod(texture<char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{


#line 5330 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
#line 5332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayeredLod(texture<signed char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayeredLod(texture<unsigned char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayeredLod(texture<char1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLayeredLod(texture<uchar1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredLod(texture<char2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredLod(texture<uchar2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredLod(texture<char4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredLod(texture<uchar4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1DLayeredLod(texture<short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayeredLod(texture<unsigned short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayeredLod(texture<short1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLayeredLod(texture<ushort1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredLod(texture<short2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredLod(texture<ushort2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredLod(texture<short4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredLod(texture<ushort4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v   = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex2DLayeredLod(texture<char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{


#line 5482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
#line 5484 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex2DLayeredLod(texture<signed char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex2DLayeredLod(texture<unsigned char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex2DLayeredLod(texture<char1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex2DLayeredLod(texture<uchar1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex2DLayeredLod(texture<char2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex2DLayeredLod(texture<uchar2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex2DLayeredLod(texture<char4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex2DLayeredLod(texture<uchar4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex2DLayeredLod(texture<short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex2DLayeredLod(texture<unsigned short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex2DLayeredLod(texture<short1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex2DLayeredLod(texture<ushort1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex2DLayeredLod(texture<short2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex2DLayeredLod(texture<ushort2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex2DLayeredLod(texture<short4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex2DLayeredLod(texture<ushort4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex2DLayeredLod(texture<int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex2DLayeredLod(texture<unsigned int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex2DLayeredLod(texture<int1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex2DLayeredLod(texture<uint1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex2DLayeredLod(texture<int2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex2DLayeredLod(texture<uint2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex2DLayeredLod(texture<int4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex2DLayeredLod(texture<uint4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex2DLayeredLod(texture<long, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex2DLayeredLod(texture<unsigned long, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex2DLayeredLod(texture<long1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex2DLayeredLod(texture<ulong1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex2DLayeredLod(texture<long2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex2DLayeredLod(texture<ulong2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex2DLayeredLod(texture<long4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex2DLayeredLod(texture<ulong4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 5733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex2DLayeredLod(texture<float, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayeredLod(texture<float1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredLod(texture<float2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredLod(texture<float4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex2DLayeredLod(texture<char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{


#line 5779 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
#line 5781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayeredLod(texture<signed char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayeredLod(texture<unsigned char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayeredLod(texture<char1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLayeredLod(texture<uchar1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredLod(texture<char2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredLod(texture<uchar2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredLod(texture<char4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredLod(texture<uchar4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex2DLayeredLod(texture<short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayeredLod(texture<unsigned short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayeredLod(texture<short1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLayeredLod(texture<ushort1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredLod(texture<short2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredLod(texture<ushort2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v  = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredLod(texture<short4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v   = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredLod(texture<ushort4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v   = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex3DLod(texture<char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{


#line 5931 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlod(t, make_float4(x, y, z, 0), level);
#line 5933 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex3DLod(texture<signed char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex3DLod(texture<unsigned char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex3DLod(texture<char1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex3DLod(texture<uchar1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex3DLod(texture<char2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex3DLod(texture<uchar2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex3DLod(texture<char4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex3DLod(texture<uchar4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex3DLod(texture<short, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex3DLod(texture<unsigned short, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex3DLod(texture<short1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex3DLod(texture<ushort1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex3DLod(texture<short2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex3DLod(texture<ushort2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex3DLod(texture<short4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex3DLod(texture<ushort4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex3DLod(texture<int, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex3DLod(texture<unsigned int, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex3DLod(texture<int1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex3DLod(texture<uint1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex3DLod(texture<int2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex3DLod(texture<uint2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex3DLod(texture<int4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex3DLod(texture<uint4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex3DLod(texture<long, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex3DLod(texture<unsigned long, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex3DLod(texture<long1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex3DLod(texture<ulong1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex3DLod(texture<long2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex3DLod(texture<ulong2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex3DLod(texture<long4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex3DLod(texture<ulong4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 6182 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex3DLod(texture<float, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex3DLod(texture<float1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex3DLod(texture<float2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex3DLod(texture<float4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex3DLod(texture<char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{


#line 6228 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
#line 6230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3DLod(texture<signed char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3DLod(texture<unsigned char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex3DLod(texture<char1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex3DLod(texture<uchar1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex3DLod(texture<char2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex3DLod(texture<uchar2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex3DLod(texture<char4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex3DLod(texture<uchar4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex3DLod(texture<short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3DLod(texture<unsigned short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex3DLod(texture<short1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex3DLod(texture<ushort1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex3DLod(texture<short2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex3DLod(texture<ushort2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex3DLod(texture<short4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex3DLod(texture<ushort4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v   = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char texCubemapLod(texture<char, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{


#line 6380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
#line 6382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char texCubemapLod(texture<signed char, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char texCubemapLod(texture<unsigned char, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 texCubemapLod(texture<char1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 texCubemapLod(texture<uchar1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 texCubemapLod(texture<char2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 texCubemapLod(texture<uchar2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 texCubemapLod(texture<char4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 texCubemapLod(texture<uchar4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short texCubemapLod(texture<short, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short texCubemapLod(texture<unsigned short, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 texCubemapLod(texture<short1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 texCubemapLod(texture<ushort1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 texCubemapLod(texture<short2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 texCubemapLod(texture<ushort2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 texCubemapLod(texture<short4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 texCubemapLod(texture<ushort4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int texCubemapLod(texture<int, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int texCubemapLod(texture<unsigned int, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 texCubemapLod(texture<int1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 texCubemapLod(texture<uint1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 texCubemapLod(texture<int2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 texCubemapLod(texture<uint2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 texCubemapLod(texture<int4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 texCubemapLod(texture<uint4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long texCubemapLod(texture<long, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long texCubemapLod(texture<unsigned long, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 texCubemapLod(texture<long1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 texCubemapLod(texture<ulong1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 texCubemapLod(texture<long2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 texCubemapLod(texture<ulong2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 texCubemapLod(texture<long4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 texCubemapLod(texture<ulong4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 6631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float texCubemapLod(texture<float, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLod(texture<float1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLod(texture<float2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLod(texture<float4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float texCubemapLod(texture<char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{


#line 6677 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
#line 6679 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLod(texture<signed char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLod(texture<unsigned char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLod(texture<char1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemapLod(texture<uchar1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLod(texture<char2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemapLod(texture<uchar2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLod(texture<char4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemapLod(texture<uchar4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float texCubemapLod(texture<short, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLod(texture<unsigned short, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLod(texture<short1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemapLod(texture<ushort1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLod(texture<short2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemapLod(texture<ushort2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v  = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLod(texture<short4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v   = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemapLod(texture<ushort4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v   = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char texCubemapLayeredLod(texture<char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{


#line 6829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
#line 6831 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char texCubemapLayeredLod(texture<signed char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char texCubemapLayeredLod(texture<unsigned char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 texCubemapLayeredLod(texture<char1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 texCubemapLayeredLod(texture<uchar1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 texCubemapLayeredLod(texture<char2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 texCubemapLayeredLod(texture<uchar2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 texCubemapLayeredLod(texture<char4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 texCubemapLayeredLod(texture<uchar4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short texCubemapLayeredLod(texture<short, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short texCubemapLayeredLod(texture<unsigned short, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 texCubemapLayeredLod(texture<short1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 texCubemapLayeredLod(texture<ushort1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 texCubemapLayeredLod(texture<short2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 texCubemapLayeredLod(texture<ushort2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 texCubemapLayeredLod(texture<short4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 texCubemapLayeredLod(texture<ushort4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int texCubemapLayeredLod(texture<int, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int texCubemapLayeredLod(texture<unsigned int, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 texCubemapLayeredLod(texture<int1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 texCubemapLayeredLod(texture<uint1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 texCubemapLayeredLod(texture<int2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 texCubemapLayeredLod(texture<uint2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 texCubemapLayeredLod(texture<int4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 texCubemapLayeredLod(texture<uint4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long texCubemapLayeredLod(texture<long, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long texCubemapLayeredLod(texture<unsigned long, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 texCubemapLayeredLod(texture<long1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 texCubemapLayeredLod(texture<ulong1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 texCubemapLayeredLod(texture<long2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 texCubemapLayeredLod(texture<ulong2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 texCubemapLayeredLod(texture<long4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 texCubemapLayeredLod(texture<ulong4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 7080 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float texCubemapLayeredLod(texture<float, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return v.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLayeredLod(texture<float1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLayeredLod(texture<float2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLayeredLod(texture<float4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float texCubemapLayeredLod(texture<char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{


#line 7126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
#line 7128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLayeredLod(texture<signed char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLayeredLod(texture<unsigned char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLayeredLod(texture<char1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemapLayeredLod(texture<uchar1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLayeredLod(texture<char2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemapLayeredLod(texture<uchar2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLayeredLod(texture<char4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemapLayeredLod(texture<uchar4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float texCubemapLayeredLod(texture<short, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float texCubemapLayeredLod(texture<unsigned short, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 texCubemapLayeredLod(texture<short1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 texCubemapLayeredLod(texture<ushort1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 texCubemapLayeredLod(texture<short2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 texCubemapLayeredLod(texture<ushort2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v  = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 texCubemapLayeredLod(texture<short4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v   = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 texCubemapLayeredLod(texture<ushort4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v   = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}


template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchgrad(texture<T, texType, readMode> t, float4 i, float4 dPdx, float4 dPdy, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchgrad(texture<T, texType, readMode> t, float4 i, float4 dPdx, float4 dPdy, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchgrad(texture<T, texType, readMode> t, float4 i, float4 dPdx, float4 dPdy, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)  uint4 __utexfetchgradl(texture<T, texType, readMode> t, float4 i, int l, float4 dPdx, float4 dPdy, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__)   int4 __itexfetchgradl(texture<T, texType, readMode> t, float4 i, int l, float4 dPdx, float4 dPdy, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __declspec(__device__) __declspec(__device_builtin__) float4 __ftexfetchgradl(texture<T, texType, readMode> t, float4 i, int l, float4 dPdx, float4 dPdy, int d = (texType & 0xF));







static __forceinline __declspec(__device__) char tex1DGrad(texture<char, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{


#line 7286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
#line 7288 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1DGrad(texture<signed char, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1DGrad(texture<unsigned char, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1DGrad(texture<char1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1DGrad(texture<uchar1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1DGrad(texture<char2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1DGrad(texture<uchar2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1DGrad(texture<char4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1DGrad(texture<uchar4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1DGrad(texture<short, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1DGrad(texture<unsigned short, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1DGrad(texture<short1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1DGrad(texture<ushort1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1DGrad(texture<short2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1DGrad(texture<ushort2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1DGrad(texture<short4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1DGrad(texture<ushort4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1DGrad(texture<int, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1DGrad(texture<unsigned int, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1DGrad(texture<int1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1DGrad(texture<uint1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1DGrad(texture<int2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1DGrad(texture<uint2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1DGrad(texture<int4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1DGrad(texture<uint4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}















static __forceinline __declspec(__device__) long tex1DGrad(texture<long, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1DGrad(texture<unsigned long, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1DGrad(texture<long1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1DGrad(texture<ulong1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1DGrad(texture<long2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1DGrad(texture<ulong2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1DGrad(texture<long4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1DGrad(texture<ulong4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 7543 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1DGrad(texture<float, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1DGrad(texture<float1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1DGrad(texture<float2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1DGrad(texture<float4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1DGrad(texture<char, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{


#line 7589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
#line 7591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DGrad(texture<signed char, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DGrad(texture<unsigned char, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DGrad(texture<char1, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DGrad(texture<uchar1, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DGrad(texture<char2, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DGrad(texture<uchar2, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DGrad(texture<char4, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DGrad(texture<uchar4, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1DGrad(texture<short, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DGrad(texture<unsigned short, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DGrad(texture<short1, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DGrad(texture<ushort1, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DGrad(texture<short2, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DGrad(texture<ushort2, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DGrad(texture<short4, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DGrad(texture<ushort4, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v   = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex2DGrad(texture<char, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{


#line 7741 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
#line 7743 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex2DGrad(texture<signed char, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex2DGrad(texture<unsigned char, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex2DGrad(texture<char1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex2DGrad(texture<uchar1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex2DGrad(texture<char2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex2DGrad(texture<uchar2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex2DGrad(texture<char4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex2DGrad(texture<uchar4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex2DGrad(texture<short, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex2DGrad(texture<unsigned short, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex2DGrad(texture<short1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex2DGrad(texture<ushort1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex2DGrad(texture<short2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex2DGrad(texture<ushort2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex2DGrad(texture<short4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex2DGrad(texture<ushort4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex2DGrad(texture<int, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex2DGrad(texture<unsigned int, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex2DGrad(texture<int1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex2DGrad(texture<uint1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex2DGrad(texture<int2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex2DGrad(texture<uint2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex2DGrad(texture<int4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex2DGrad(texture<uint4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex2DGrad(texture<long, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex2DGrad(texture<unsigned long, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex2DGrad(texture<long1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex2DGrad(texture<ulong1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex2DGrad(texture<long2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex2DGrad(texture<ulong2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex2DGrad(texture<long4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex2DGrad(texture<ulong4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 7992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex2DGrad(texture<float, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex2DGrad(texture<float1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex2DGrad(texture<float2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex2DGrad(texture<float4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex2DGrad(texture<char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{


#line 8038 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
#line 8040 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DGrad(texture<signed char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DGrad(texture<unsigned char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DGrad(texture<char1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DGrad(texture<uchar1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DGrad(texture<char2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DGrad(texture<uchar2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DGrad(texture<char4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DGrad(texture<uchar4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex2DGrad(texture<short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DGrad(texture<unsigned short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DGrad(texture<short1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DGrad(texture<ushort1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DGrad(texture<short2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DGrad(texture<ushort2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DGrad(texture<short4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DGrad(texture<ushort4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v   = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex1DLayeredGrad(texture<char, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{


#line 8190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
#line 8192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex1DLayeredGrad(texture<signed char, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex1DLayeredGrad(texture<unsigned char, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex1DLayeredGrad(texture<char1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex1DLayeredGrad(texture<uchar1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex1DLayeredGrad(texture<char2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex1DLayeredGrad(texture<uchar2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex1DLayeredGrad(texture<char4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex1DLayeredGrad(texture<uchar4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex1DLayeredGrad(texture<short, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex1DLayeredGrad(texture<unsigned short, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex1DLayeredGrad(texture<short1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex1DLayeredGrad(texture<ushort1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex1DLayeredGrad(texture<short2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex1DLayeredGrad(texture<ushort2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex1DLayeredGrad(texture<short4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex1DLayeredGrad(texture<ushort4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex1DLayeredGrad(texture<int, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex1DLayeredGrad(texture<unsigned int, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex1DLayeredGrad(texture<int1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex1DLayeredGrad(texture<uint1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex1DLayeredGrad(texture<int2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex1DLayeredGrad(texture<uint2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex1DLayeredGrad(texture<int4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex1DLayeredGrad(texture<uint4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex1DLayeredGrad(texture<long, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex1DLayeredGrad(texture<unsigned long, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex1DLayeredGrad(texture<long1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex1DLayeredGrad(texture<ulong1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex1DLayeredGrad(texture<long2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex1DLayeredGrad(texture<ulong2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex1DLayeredGrad(texture<long4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex1DLayeredGrad(texture<ulong4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 8441 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex1DLayeredGrad(texture<float, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayeredGrad(texture<float1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredGrad(texture<float2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredGrad(texture<float4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex1DLayeredGrad(texture<char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{


#line 8487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
#line 8489 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayeredGrad(texture<signed char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayeredGrad(texture<unsigned char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayeredGrad(texture<char1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLayeredGrad(texture<uchar1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredGrad(texture<char2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredGrad(texture<uchar2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredGrad(texture<char4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredGrad(texture<uchar4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex1DLayeredGrad(texture<short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex1DLayeredGrad(texture<unsigned short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex1DLayeredGrad(texture<short1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex1DLayeredGrad(texture<ushort1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredGrad(texture<short2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex1DLayeredGrad(texture<ushort2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredGrad(texture<short4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex1DLayeredGrad(texture<ushort4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v   = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex2DLayeredGrad(texture<char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{


#line 8639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
#line 8641 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex2DLayeredGrad(texture<signed char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex2DLayeredGrad(texture<unsigned char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex2DLayeredGrad(texture<char1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex2DLayeredGrad(texture<uchar1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex2DLayeredGrad(texture<char2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex2DLayeredGrad(texture<uchar2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex2DLayeredGrad(texture<char4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex2DLayeredGrad(texture<uchar4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex2DLayeredGrad(texture<short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex2DLayeredGrad(texture<unsigned short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex2DLayeredGrad(texture<short1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex2DLayeredGrad(texture<ushort1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex2DLayeredGrad(texture<short2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex2DLayeredGrad(texture<ushort2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex2DLayeredGrad(texture<short4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex2DLayeredGrad(texture<ushort4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex2DLayeredGrad(texture<int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex2DLayeredGrad(texture<unsigned int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex2DLayeredGrad(texture<int1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex2DLayeredGrad(texture<uint1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex2DLayeredGrad(texture<int2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex2DLayeredGrad(texture<uint2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex2DLayeredGrad(texture<int4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex2DLayeredGrad(texture<uint4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex2DLayeredGrad(texture<long, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex2DLayeredGrad(texture<unsigned long, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex2DLayeredGrad(texture<long1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex2DLayeredGrad(texture<ulong1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex2DLayeredGrad(texture<long2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex2DLayeredGrad(texture<ulong2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex2DLayeredGrad(texture<long4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex2DLayeredGrad(texture<ulong4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 8890 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex2DLayeredGrad(texture<float, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayeredGrad(texture<float1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredGrad(texture<float2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredGrad(texture<float4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex2DLayeredGrad(texture<char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{


#line 8936 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
#line 8938 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayeredGrad(texture<signed char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayeredGrad(texture<unsigned char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayeredGrad(texture<char1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLayeredGrad(texture<uchar1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredGrad(texture<char2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredGrad(texture<uchar2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredGrad(texture<char4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredGrad(texture<uchar4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex2DLayeredGrad(texture<short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex2DLayeredGrad(texture<unsigned short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex2DLayeredGrad(texture<short1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex2DLayeredGrad(texture<ushort1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredGrad(texture<short2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex2DLayeredGrad(texture<ushort2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v  = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredGrad(texture<short4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v   = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex2DLayeredGrad(texture<ushort4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v   = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) char tex3DGrad(texture<char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{


#line 9088 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v  = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
#line 9090 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __forceinline __declspec(__device__) signed char tex3DGrad(texture<signed char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (signed char)v.x;
}

static __forceinline __declspec(__device__) unsigned char tex3DGrad(texture<unsigned char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (unsigned char)v.x;
}

static __forceinline __declspec(__device__) char1 tex3DGrad(texture<char1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_char1(v.x);
}

static __forceinline __declspec(__device__) uchar1 tex3DGrad(texture<uchar1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uchar1(v.x);
}

static __forceinline __declspec(__device__) char2 tex3DGrad(texture<char2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_char2(v.x, v.y);
}

static __forceinline __declspec(__device__) uchar2 tex3DGrad(texture<uchar2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uchar2(v.x, v.y);
}

static __forceinline __declspec(__device__) char4 tex3DGrad(texture<char4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uchar4 tex3DGrad(texture<uchar4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) short tex3DGrad(texture<short, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (short)v.x;
}

static __forceinline __declspec(__device__) unsigned short tex3DGrad(texture<unsigned short, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (unsigned short)v.x;
}

static __forceinline __declspec(__device__) short1 tex3DGrad(texture<short1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_short1(v.x);
}

static __forceinline __declspec(__device__) ushort1 tex3DGrad(texture<ushort1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ushort1(v.x);
}

static __forceinline __declspec(__device__) short2 tex3DGrad(texture<short2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_short2(v.x, v.y);
}

static __forceinline __declspec(__device__) ushort2 tex3DGrad(texture<ushort2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ushort2(v.x, v.y);
}

static __forceinline __declspec(__device__) short4 tex3DGrad(texture<short4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ushort4 tex3DGrad(texture<ushort4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) int tex3DGrad(texture<int, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (int)v.x;
}

static __forceinline __declspec(__device__) unsigned int tex3DGrad(texture<unsigned int, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (unsigned int)v.x;
}

static __forceinline __declspec(__device__) int1 tex3DGrad(texture<int1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_int1(v.x);
}

static __forceinline __declspec(__device__) uint1 tex3DGrad(texture<uint1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uint1(v.x);
}

static __forceinline __declspec(__device__) int2 tex3DGrad(texture<int2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_int2(v.x, v.y);
}

static __forceinline __declspec(__device__) uint2 tex3DGrad(texture<uint2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uint2(v.x, v.y);
}

static __forceinline __declspec(__device__) int4 tex3DGrad(texture<int4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) uint4 tex3DGrad(texture<uint4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}









static __forceinline __declspec(__device__) long tex3DGrad(texture<long, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (long)v.x;
}

static __forceinline __declspec(__device__) unsigned long tex3DGrad(texture<unsigned long, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (unsigned long)v.x;
}

static __forceinline __declspec(__device__) long1 tex3DGrad(texture<long1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_long1(v.x);
}

static __forceinline __declspec(__device__) ulong1 tex3DGrad(texture<ulong1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ulong1(v.x);
}

static __forceinline __declspec(__device__) long2 tex3DGrad(texture<long2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_long2(v.x, v.y);
}

static __forceinline __declspec(__device__) ulong2 tex3DGrad(texture<ulong2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ulong2(v.x, v.y);
}

static __forceinline __declspec(__device__) long4 tex3DGrad(texture<long4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __forceinline __declspec(__device__) ulong4 tex3DGrad(texture<ulong4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 9339 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"







static __forceinline __declspec(__device__) float tex3DGrad(texture<float, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return v.x;
}

static __forceinline __declspec(__device__) float1 tex3DGrad(texture<float1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_float1(v.x);
}

static __forceinline __declspec(__device__) float2 tex3DGrad(texture<float2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_float2(v.x, v.y);
}

static __forceinline __declspec(__device__) float4 tex3DGrad(texture<float4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __forceinline __declspec(__device__) float tex3DGrad(texture<char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{


#line 9385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
#line 9387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3DGrad(texture<signed char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3DGrad(texture<unsigned char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex3DGrad(texture<char1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex3DGrad(texture<uchar1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex3DGrad(texture<char2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex3DGrad(texture<uchar2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex3DGrad(texture<char4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex3DGrad(texture<uchar4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __forceinline __declspec(__device__) float tex3DGrad(texture<short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float tex3DGrad(texture<unsigned short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __forceinline __declspec(__device__) float1 tex3DGrad(texture<short1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float1 tex3DGrad(texture<ushort1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __forceinline __declspec(__device__) float2 tex3DGrad(texture<short2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float2 tex3DGrad(texture<ushort2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v  = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __forceinline __declspec(__device__) float4 tex3DGrad(texture<short4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v   = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __forceinline __declspec(__device__) float4 tex3DGrad(texture<ushort4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v   = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

#line 9527 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"



















































































































#line 9643 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"

#line 9645 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"


#line 6395 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"


























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"




















































































































































































































































































































#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1Dfetch(char *retVal, cudaTextureObject_t texObject, int x)
{



#line 76 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
#line 79 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1Dfetch(signed char *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(char1 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(char2 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(char4 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1Dfetch(unsigned char *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(uchar1 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(uchar2 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(uchar4 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1Dfetch(short *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(short1 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(short2 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(short4 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1Dfetch(unsigned short *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(ushort1 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(ushort2 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(ushort4 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1Dfetch(int *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(int1 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(int2 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(int4 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1Dfetch(unsigned int *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(uint1 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(uint2 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(uint4 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1Dfetch(long *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(long1 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(long2 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(long4 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1Dfetch(unsigned long *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(ulong1 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(ulong2 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(ulong4 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 326 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1Dfetch(float *retVal, cudaTextureObject_t texObject, int x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(float1 *retVal, cudaTextureObject_t texObject, int x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1Dfetch(float2 *retVal, cudaTextureObject_t texObject, int x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1Dfetch(float4 *retVal, cudaTextureObject_t texObject, int x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1Dfetch(cudaTextureObject_t texObject, int x)
{
   T ret;
   tex1Dfetch(&ret, texObject, x);
   return ret;
}







static __forceinline __declspec(__device__) void tex1D(char *retVal, cudaTextureObject_t texObject, float x)
{



#line 388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
#line 391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1D(signed char *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(char1 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(char2 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(char4 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1D(unsigned char *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(uchar1 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(uchar2 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(uchar4 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1D(short *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(short1 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(short2 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(short4 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1D(unsigned short *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(ushort1 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(ushort2 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(ushort4 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1D(int *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(int1 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(int2 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(int4 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1D(unsigned int *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(uint1 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(uint2 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(uint4 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1D(long *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(long1 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(long2 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(long4 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1D(unsigned long *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(ulong1 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(ulong2 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(ulong4 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 638 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1D(float *retVal, cudaTextureObject_t texObject, float x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(float1 *retVal, cudaTextureObject_t texObject, float x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1D(float2 *retVal, cudaTextureObject_t texObject, float x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1D(float4 *retVal, cudaTextureObject_t texObject, float x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1D(cudaTextureObject_t texObject, float x)
{
   T ret;
   tex1D(&ret, texObject, x);
   return ret;
}







static __forceinline __declspec(__device__) void tex2D(char *retVal, cudaTextureObject_t texObject, float x, float y)
{



#line 700 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
#line 703 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex2D(signed char *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(char1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(char2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(char4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2D(short *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(short1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(short2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(short4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2D(int *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(int1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(int2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(int4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2D(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex2D(long *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(long1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(long2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(long4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2D(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 950 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex2D(float *retVal, cudaTextureObject_t texObject, float x, float y)
{
   float4 tmp;
   asm volatile ("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(float1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   float4 tmp;
   asm volatile ("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2D(float2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   float4 tmp;
   asm volatile ("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2D(float4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   float4 tmp;
   asm volatile ("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2D(cudaTextureObject_t texObject, float x, float y)
{
   T ret;
   tex2D(&ret, texObject, x, y);
   return ret;
}







static __forceinline __declspec(__device__) void tex3D(char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{



#line 1012 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
#line 1015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex3D(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex3D(short *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex3D(int *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3D(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex3D(long *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3D(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 1262 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex3D(float *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3D(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3D(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex3D(cudaTextureObject_t texObject, float x, float y, float z)
{
   T ret;
   tex3D(&ret, texObject, x, y, z);
   return ret;
}







static __forceinline __declspec(__device__) void tex1DLayered(char *retVal, cudaTextureObject_t texObject, float x, int layer)
{



#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
#line 1327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLayered(short *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLayered(int *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayered(unsigned int *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1DLayered(long *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(long1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(long2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(long4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 1574 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1DLayered(float *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   float4 tmp;
   asm volatile ("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   float4 tmp;
   asm volatile ("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   float4 tmp;
   asm volatile ("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   float4 tmp;
   asm volatile ("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1DLayered(cudaTextureObject_t texObject, float x, int layer)
{
   T ret;
   tex1DLayered(&ret, texObject, x, layer);
   return ret;
}







static __forceinline __declspec(__device__) void tex2DLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{



#line 1636 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
#line 1639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex2DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayered(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex2DLayered(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 1886 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex2DLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   float4 tmp;
   asm volatile ("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   float4 tmp;
   asm volatile ("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   float4 tmp;
   asm volatile ("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   float4 tmp;
   asm volatile ("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer)
{
   T ret;
   tex2DLayered(&ret, texObject, x, y, layer);
   return ret;
}







static __forceinline __declspec(__device__) void texCubemap(char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{



#line 1948 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
#line 1951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void texCubemap(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemap(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemap(short *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemap(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemap(int *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemap(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void texCubemap(long *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemap(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 2198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void texCubemap(float *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemap(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemap(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T texCubemap(cudaTextureObject_t texObject, float x, float y, float z)
{
   T ret;
   texCubemap(&ret, texObject, x, y, z);
   return ret;
}







static __forceinline __declspec(__device__) void texCubemapLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{



#line 2260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
#line 2263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void texCubemapLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemapLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemapLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayered(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void texCubemapLayered(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 2510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void texCubemapLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   float4 tmp;
   asm volatile ("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   float4 tmp;
   asm volatile ("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   float4 tmp;
   asm volatile ("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   float4 tmp;
   asm volatile ("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T texCubemapLayered(cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   T ret;
   texCubemapLayered(&ret, texObject, x, y, z, layer);
   return ret;
}







static __forceinline __declspec(__device__) void tex2Dgather(char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2Dgather(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2Dgather(short *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2Dgather(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2Dgather(int *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2Dgather(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2Dgather(long *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2Dgather(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2Dgather(float *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   float4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   float4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2Dgather(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   float4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2Dgather(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   float4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2Dgather(cudaTextureObject_t to, float x, float y, int comp = 0)
{
   T ret;
   tex2Dgather(&ret, to, x, y, comp);
   return ret;
}







static __forceinline __declspec(__device__) void tex1DLod(char *retVal, cudaTextureObject_t texObject, float x, float level)
{



#line 3282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
#line 3285 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLod(short *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLod(int *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1DLod(long *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 3532 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1DLod(float *retVal, cudaTextureObject_t texObject, float x, float level)
{
   float4 tmp;
   asm volatile ("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   float4 tmp;
   asm volatile ("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   float4 tmp;
   asm volatile ("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   float4 tmp;
   asm volatile ("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1DLod(cudaTextureObject_t texObject, float x, float level)
{
   T ret;
   tex1DLod(&ret, texObject, x, level);
   return ret;
}







static __forceinline __declspec(__device__) void tex2DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{



#line 3594 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
#line 3597 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex2DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex2DLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 3844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex2DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   float4 tmp;
   asm volatile ("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   float4 tmp;
   asm volatile ("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   float4 tmp;
   asm volatile ("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   float4 tmp;
   asm volatile ("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2DLod(cudaTextureObject_t texObject, float x, float y, float level)
{
   T ret;
   tex2DLod(&ret, texObject, x, y, level);
   return ret;
}







static __forceinline __declspec(__device__) void tex3DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{



#line 3906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
#line 3909 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex3DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex3DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex3DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex3DLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 4156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex3DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   T ret;
   tex3DLod(&ret, texObject, x, y, z, level);
   return ret;
}







static __forceinline __declspec(__device__) void tex1DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{



#line 4218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
#line 4221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1DLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 4468 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1DLayeredLod(cudaTextureObject_t texObject, float x, int layer, float level)
{
   T ret;
   tex1DLayeredLod(&ret, texObject, x, layer, level);
   return ret;
}







static __forceinline __declspec(__device__) void tex2DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{



#line 4530 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
#line 4533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex2DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex2DLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 4780 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex2DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   T ret;
   tex2DLayeredLod(&ret, texObject, x, y, layer, level);
   return ret;
}







static __forceinline __declspec(__device__) void texCubemapLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{



#line 4842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
#line 4845 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void texCubemapLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemapLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemapLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void texCubemapLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 5092 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void texCubemapLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T texCubemapLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   T ret;
   texCubemapLod(&ret, texObject, x, y, z, level);
   return ret;
}







static __forceinline __declspec(__device__) void texCubemapLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{



#line 5154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
#line 5157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void texCubemapLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemapLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void texCubemapLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void texCubemapLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 5404 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void texCubemapLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void texCubemapLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T texCubemapLayeredLod(cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   T ret;
   texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level);
   return ret;
}







static __forceinline __declspec(__device__) void tex1DGrad(char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{



#line 5466 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
#line 5469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DGrad(short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DGrad(int *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1DGrad(long *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 5716 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1DGrad(float *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1DGrad(cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   T ret;
   tex1DGrad(&ret, texObject, x, dPdx, dPdy);
   return ret;
}







static __forceinline __declspec(__device__) void tex2DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{



#line 5778 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
#line 5781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex2DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex2DGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 6028 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex2DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   T ret;
   tex2DGrad(&ret, texObject, x, y, dPdx, dPdy);
   return ret;
}







static __forceinline __declspec(__device__) void tex3DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{



#line 6090 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
#line 6093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex3DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex3DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex3DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex3DGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex3DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 6340 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex3DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex3DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex3DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   T ret;
   tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy);
   return ret;
}







static __forceinline __declspec(__device__) void tex1DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{



#line 6402 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
#line 6405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex1DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex1DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex1DLayeredGrad(long *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(long1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(long2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(long4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 6652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex1DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex1DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex1DLayeredGrad(cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   T ret;
   tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy);
   return ret;
}







static __forceinline __declspec(__device__) void tex2DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{



#line 6714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    int4 tmp;
    asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
#line 6717 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
    *retVal = (char)tmp.x;
}
static __forceinline __declspec(__device__) void tex2DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (signed char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned char)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned short)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __forceinline __declspec(__device__) void tex2DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned int)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}









static __forceinline __declspec(__device__) void tex2DLayeredGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_long1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_long2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned long)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ulong1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}

#line 6964 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"








static __forceinline __declspec(__device__) void tex2DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (float)(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float1(tmp.x);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void tex2DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   T ret;
   tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy);
   return ret;
}

#line 7015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"

#line 7017 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"

#line 7019 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"



#line 6396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"


























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"























































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"




































































#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#line 57 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"

#line 58 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"






















































































































#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"




















































































































































































































#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\builtin_types.h"
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"










































































































































































































#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\host_defines.h"
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"




















































































































































































































































































































#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"
#line 62 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"








static __forceinline __declspec(__device__) void surf1Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=f"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=f"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=f"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surf1Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surf1Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b8.trap  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b8.clamp {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b8.zero  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b8.trap  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b8.clamp {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b8.zero  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b16.trap  {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b16.clamp {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b16.zero  {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b16.trap  {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b16.clamp {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b16.zero  {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b64.trap  {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b64.clamp {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b64.zero  {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b64.trap  {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b64.clamp {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b64.zero  {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surf1Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surf1Dread(cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf1Dread(&ret, surfObject, x, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surf2Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surf2Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surf2Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surf2Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surf2Dread(cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf2Dread(&ret, surfObject, x, y, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surf3Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf3Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surf3Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surf3Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf3Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surf3Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf3Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf3Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf3Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf3Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf3Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf3Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surf3Dread(cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf3Dread(&ret, surfObject, x, y, z, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surf1DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surf1DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surf1DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf1DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surf1DLayeredread(cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf1DLayeredread(&ret, surfObject, x, layer, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surf2DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surf2DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surf2DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surf2DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surf2DLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf2DLayeredread(&ret, surfObject, x, y, layer, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surfCubemapread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surfCubemapread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surfCubemapread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surfCubemapread(cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surfCubemapread(&ret, surfObject, face, x, y, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surfCubemapLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (char)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (signed char)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (unsigned char)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (short)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (unsigned short)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (int)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (unsigned int)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (long long)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_longlong1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (unsigned long long)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (float)(tmp);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_float1(tmp.x);
}







static __forceinline __declspec(__device__) void surfCubemapLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __forceinline __declspec(__device__) void surfCubemapLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __forceinline __declspec(__device__) void surfCubemapLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __forceinline __declspec(__device__) T surfCubemapLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surfCubemapLayeredread(&ret, surfObject, x, y, z, layerface, boundaryMode);
   return ret;
}







static __forceinline __declspec(__device__) void surf1Dwrite(char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(float data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surf1Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b8.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b8.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b8.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b8.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b8.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b8.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b16.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b16.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b16.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b16.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b16.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b16.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b64.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b64.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b64.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b64.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b64.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b64.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surf1Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b8.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b8.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b8.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b8.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b8.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b8.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b16.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b16.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b16.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b16.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b16.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b16.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __forceinline __declspec(__device__) void surf2Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surf2Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surf2Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __forceinline __declspec(__device__) void surf3Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surf3Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surf3Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf3Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __forceinline __declspec(__device__) void surf1DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surf1DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surf1DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf1DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __forceinline __declspec(__device__) void surf2DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surf2DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surf2DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surf2DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __forceinline __declspec(__device__) void surfCubemapwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surfCubemapwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surfCubemapwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x));
   }
}







static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
}







static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __forceinline __declspec(__device__) void surfCubemapLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}

#line 7275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"

#line 7277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"

#line 7279 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"



#line 6397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"

#line 6399 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"

#line 80 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"
#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_launch_parameters.h"




















































#line 1 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"












































































































































































































































































































































































































































#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#line 54 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_launch_parameters.h"






#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_launch_parameters.h"


extern "C" {
#line 65 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_launch_parameters.h"

uint3 __declspec(__device_builtin__) extern const threadIdx;
uint3 __declspec(__device_builtin__) extern const blockIdx;
dim3 __declspec(__device_builtin__) extern const blockDim;
dim3 __declspec(__device_builtin__) extern const gridDim;
int __declspec(__device_builtin__) extern const warpSize;




}
#line 77 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_launch_parameters.h"






#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_launch_parameters.h"






#line 91 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_launch_parameters.h"






#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_launch_parameters.h"






#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_launch_parameters.h"






#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_launch_parameters.h"

#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_launch_parameters.h"
#line 81 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"

#line 83 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"









namespace
{





























template<class T>
__inline __declspec(__host__) cudaError_t cudaSetupArgument(
  T      arg,
  size_t offset
)
{
  return ::cudaSetupArgument((const void*)&arg, sizeof(T), offset);
}































static __inline __declspec(__host__) cudaError_t cudaEventCreate(
  cudaEvent_t  *event,
  unsigned int  flags
)
{
  return ::cudaEventCreateWithFlags(event, flags);
}
























































__inline __declspec(__host__) cudaError_t cudaMallocHost(
  void         **ptr,
  size_t         size,
  unsigned int   flags
)
{
  return ::cudaHostAlloc(ptr, size, flags);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaHostAlloc(
  T            **ptr,
  size_t         size,
  unsigned int   flags
)
{
  return ::cudaHostAlloc((void**)(void*)ptr, size, flags);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaHostGetDevicePointer(
  T            **pDevice,
  void          *pHost,
  unsigned int   flags
)
{
  return ::cudaHostGetDevicePointer((void**)(void*)pDevice, pHost, flags);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMalloc(
  T      **devPtr,
  size_t   size
)
{
  return ::cudaMalloc((void**)(void*)devPtr, size);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMallocHost(
  T            **ptr,
  size_t         size,
  unsigned int   flags = 0
)
{
  return cudaMallocHost((void**)(void*)ptr, size, flags);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMallocPitch(
  T      **devPtr,
  size_t  *pitch,
  size_t   width,
  size_t   height
)
{
  return ::cudaMallocPitch((void**)(void*)devPtr, pitch, width, height);
}




































template<class T>
__inline __declspec(__host__) cudaError_t cudaMemcpyToSymbol(
  const T                   &symbol,
  const void                *src,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyHostToDevice
)
{
  return ::cudaMemcpyToSymbol((const void*)&symbol, src, count, offset, kind);
}









































template<class T>
__inline __declspec(__host__) cudaError_t cudaMemcpyToSymbolAsync(
  const T                   &symbol,
  const void                *src,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyHostToDevice,
        cudaStream_t         stream = 0
)
{
  return ::cudaMemcpyToSymbolAsync((const void*)&symbol, src, count, offset, kind, stream);
}


































template<class T>
__inline __declspec(__host__) cudaError_t cudaMemcpyFromSymbol(
        void                *dst,
  const T                   &symbol,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyDeviceToHost
)
{
  return ::cudaMemcpyFromSymbol(dst, (const void*)&symbol, count, offset, kind);
}









































template<class T>
__inline __declspec(__host__) cudaError_t cudaMemcpyFromSymbolAsync(
        void                *dst,
  const T                   &symbol,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyDeviceToHost,
        cudaStream_t         stream = 0
)
{
  return ::cudaMemcpyFromSymbolAsync(dst, (const void*)&symbol, count, offset, kind, stream);
}





















template<class T>
__inline __declspec(__host__) cudaError_t cudaGetSymbolAddress(
        void **devPtr,
  const T     &symbol
)
{
  return ::cudaGetSymbolAddress(devPtr, (const void*)&symbol);
}





















template<class T>
__inline __declspec(__host__) cudaError_t cudaGetSymbolSize(
        size_t *size,
  const T      &symbol
)
{
  return ::cudaGetSymbolSize(size, (const void*)&symbol);
}



































template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTexture(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
  const struct cudaChannelFormatDesc     &desc,
        size_t                            size = 0xffffffff
)
{
  return ::cudaBindTexture(offset, &tex, devPtr, &desc, size);
}


































template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTexture(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
        size_t                            size = 0xffffffff
)
{
  return cudaBindTexture(offset, tex, devPtr, tex.channelDesc, size);
}














































template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTexture2D(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
  const struct cudaChannelFormatDesc     &desc,
  size_t                                  width,
  size_t                                  height,
  size_t                                  pitch
)
{
  return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch);
}













































template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTexture2D(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
  size_t                                  width,
  size_t                                  height,
  size_t                                  pitch
)
{
  return ::cudaBindTexture2D(offset, &tex, devPtr, &tex.channelDesc, width, height, pitch);
}






























template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  cudaArray_const_t                       array,
  const struct cudaChannelFormatDesc     &desc
)
{
  return ::cudaBindTextureToArray(&tex, array, &desc);
}





























template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  cudaArray_const_t                       array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t                  err = ::cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindTextureToArray(tex, array, desc) : err;
}






























template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTextureToMipmappedArray(
  const struct texture<T, dim, readMode> &tex,
  cudaMipmappedArray_const_t              mipmappedArray,
  const struct cudaChannelFormatDesc     &desc
)
{
  return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc);
}





























template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTextureToMipmappedArray(
  const struct texture<T, dim, readMode> &tex,
  cudaMipmappedArray_const_t              mipmappedArray
)
{
  struct cudaChannelFormatDesc desc;
  cudaArray_t                  levelArray;
  cudaError_t                  err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0);
  
  if (err != cudaSuccess) {
      return err;
  }
  err = ::cudaGetChannelDesc(&desc, levelArray);

  return err == cudaSuccess ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err;
}






















template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaUnbindTexture(
  const struct texture<T, dim, readMode> &tex
)
{
  return ::cudaUnbindTexture(&tex);
}



























template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaGetTextureAlignmentOffset(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex
)
{
  return ::cudaGetTextureAlignmentOffset(offset, &tex);
}













































template<class T>
__inline __declspec(__host__) cudaError_t cudaFuncSetCacheConfig(
  T                  *func,
  enum cudaFuncCache  cacheConfig
)
{
  return ::cudaFuncSetCacheConfig((const void*)func, cacheConfig);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaFuncSetSharedMemConfig(
  T                        *func,
  enum cudaSharedMemConfig  config
)
{
  return ::cudaFuncSetSharedMemConfig((const void*)func, config);
}



































template<class T>
__inline __declspec(__host__) cudaError_t cudaLaunch(
  T *func
)
{
  return ::cudaLaunch((const void*)func);
}































template<class T>
__inline __declspec(__host__) cudaError_t cudaFuncGetAttributes(
  struct cudaFuncAttributes *attr,
  T                         *entry
)
{
  return ::cudaFuncGetAttributes(attr, (const void*)entry);
}





















template<class T, int dim>
__inline __declspec(__host__) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim>       &surf,
  cudaArray_const_t                   array,
  const struct cudaChannelFormatDesc &desc
)
{
  return ::cudaBindSurfaceToArray(&surf, array, &desc);
}




















template<class T, int dim>
__inline __declspec(__host__) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim> &surf,
  cudaArray_const_t             array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t                  err = ::cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindSurfaceToArray(surf, array, desc) : err;
}

#line 1179 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"

 

} 

#line 1185 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"

#line 1187 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"

#line 1 "C:/Users/H8/Documents/Visual Studio 2012/Projects/AmpIdent/AmpIdentGPUkernel/AmpIdentGPUkernel/kernel.cu"
#line 1 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1187 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"

#line 2 "C:/Users/H8/Documents/Visual Studio 2012/Projects/AmpIdent/AmpIdentGPUkernel/AmpIdentGPUkernel/kernel.cu"
#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"














#pragma once




#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"





#pragma pack(push,8)


extern "C" {
#line 31 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

























struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;

#line 69 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"










#line 80 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"













#line 94 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"





















#line 116 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"













__declspec(dllimport) FILE * __cdecl __iob_func(void);
#line 131 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"





typedef __int64 fpos_t;

#line 139 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"






#line 146 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
























  __declspec(dllimport) int __cdecl _filbuf(  FILE * _File );
 __declspec(dllimport) int __cdecl _flsbuf(  int _Ch,   FILE * _File);




  __declspec(dllimport) FILE * __cdecl _fsopen(  const char * _Filename,   const char * _Mode,   int _ShFlag);
#line 178 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

__declspec(dllimport) void __cdecl clearerr(  FILE * _File);

 __declspec(dllimport) errno_t __cdecl clearerr_s(  FILE * _File );
#line 183 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl fclose(  FILE * _File);
 __declspec(dllimport) int __cdecl _fcloseall(void);




  __declspec(dllimport) FILE * __cdecl _fdopen(  int _FileHandle,   const char * _Mode);
#line 191 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

  __declspec(dllimport) int __cdecl feof(  FILE * _File);
  __declspec(dllimport) int __cdecl ferror(  FILE * _File);
 __declspec(dllimport) int __cdecl fflush(  FILE * _File);
 __declspec(dllimport) int __cdecl fgetc(  FILE * _File);
 __declspec(dllimport) int __cdecl _fgetchar(void);
 __declspec(dllimport) int __cdecl fgetpos(  FILE * _File ,   fpos_t * _Pos);
 __declspec(dllimport) char * __cdecl fgets(  char * _Buf,   int _MaxCount,   FILE * _File);




  __declspec(dllimport) int __cdecl _fileno(  FILE * _File);
#line 205 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"




#line 210 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

  __declspec(dllimport) char * __cdecl _tempnam(  const char * _DirName,   const char * _FilePrefix);



#line 216 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

 __declspec(dllimport) int __cdecl _flushall(void);
   __declspec(dllimport) FILE * __cdecl fopen(  const char * _Filename,   const char * _Mode);

 __declspec(dllimport) errno_t __cdecl fopen_s(  FILE ** _File,   const char * _Filename,   const char * _Mode);
#line 222 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl fprintf(  FILE * _File,     const char * _Format, ...);

 __declspec(dllimport) int __cdecl fprintf_s(  FILE * _File,     const char * _Format, ...);
#line 226 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl fputc(  int _Ch,   FILE * _File);
 __declspec(dllimport) int __cdecl _fputchar(  int _Ch);
 __declspec(dllimport) int __cdecl fputs(  const char * _Str,   FILE * _File);
 __declspec(dllimport) size_t __cdecl fread(  void * _DstBuf,   size_t _ElementSize,   size_t _Count,   FILE * _File);

 __declspec(dllimport) size_t __cdecl fread_s(  void * _DstBuf,   size_t _DstSize,   size_t _ElementSize,   size_t _Count,   FILE * _File);
#line 233 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
   __declspec(dllimport) FILE * __cdecl freopen(  const char * _Filename,   const char * _Mode,   FILE * _File);

 __declspec(dllimport) errno_t __cdecl freopen_s(  FILE ** _File,   const char * _Filename,   const char * _Mode,   FILE * _OldFile);
#line 237 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
   __declspec(dllimport) int __cdecl fscanf(  FILE * _File,     const char * _Format, ...);
  __declspec(dllimport) int __cdecl _fscanf_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl fscanf_s(  FILE * _File,     const char * _Format, ...);
#line 244 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _fscanf_s_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
#pragma warning(pop)
 __declspec(dllimport) int __cdecl fsetpos(  FILE * _File,   const fpos_t * _Pos);
 __declspec(dllimport) int __cdecl fseek(  FILE * _File,   long _Offset,   int _Origin);
  __declspec(dllimport) long __cdecl ftell(  FILE * _File);

 __declspec(dllimport) int __cdecl _fseeki64(  FILE * _File,   __int64 _Offset,   int _Origin);
  __declspec(dllimport) __int64 __cdecl _ftelli64(  FILE * _File);

 __declspec(dllimport) size_t __cdecl fwrite(  const void * _Str,   size_t _Size,   size_t _Count,   FILE * _File);
  __declspec(dllimport) int __cdecl getc(  FILE * _File);
  __declspec(dllimport) int __cdecl getchar(void);
  __declspec(dllimport) int __cdecl _getmaxstdio(void);

__declspec(dllimport) char * __cdecl gets_s(  char * _Buf,   rsize_t _Size);
#line 260 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline char * __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
 __declspec(dllimport) char * __cdecl gets(  char *_Buffer);
  int __cdecl _getw(  FILE * _File);





 __declspec(dllimport) int __cdecl _pclose(  FILE * _File);
  __declspec(dllimport) FILE * __cdecl _popen(  const char * _Command,   const char * _Mode);
#line 271 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl printf(    const char * _Format, ...);

 __declspec(dllimport) int __cdecl printf_s(    const char * _Format, ...);
#line 275 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl putc(  int _Ch,   FILE * _File);
 __declspec(dllimport) int __cdecl putchar(  int _Ch);
 __declspec(dllimport) int __cdecl puts(  const char * _Str);
 __declspec(dllimport) int __cdecl _putw(  int _Word,   FILE * _File);


__declspec(dllimport) int __cdecl remove(  const char * _Filename);
  __declspec(dllimport) int __cdecl rename(  const char * _OldFilename,   const char * _NewFilename);
__declspec(dllimport) int __cdecl _unlink(  const char * _Filename);

 __declspec(dllimport) int __cdecl unlink(  const char * _Filename);
#line 287 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
#line 288 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
__declspec(dllimport) void __cdecl rewind(  FILE * _File);
 __declspec(dllimport) int __cdecl _rmtmp(void);
   __declspec(dllimport) int __cdecl scanf(    const char * _Format, ...);
  __declspec(dllimport) int __cdecl _scanf_l(    const char * _Format,   _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl scanf_s(    const char * _Format, ...);
#line 297 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _scanf_s_l(    const char * _Format,   _locale_t _Locale, ...);
#pragma warning(pop)
 __declspec(dllimport) void __cdecl setbuf(  FILE * _File,     char * _Buffer);
 __declspec(dllimport) int __cdecl _setmaxstdio(  int _Max);
 __declspec(dllimport) unsigned int __cdecl _set_output_format(  unsigned int _Format);
 __declspec(dllimport) unsigned int __cdecl _get_output_format(void);
 __declspec(dllimport) int __cdecl setvbuf(  FILE * _File,   char * _Buf,   int _Mode,   size_t _Size);
 __declspec(dllimport) int __cdecl _snprintf_s(  char * _DstBuf,   size_t _SizeInBytes,   size_t _MaxCount,     const char * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snprintf_s(  char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _ArgList); } __pragma(warning(pop)); }

 __declspec(dllimport) int __cdecl sprintf_s(  char * _DstBuf,   size_t _SizeInBytes,     const char * _Format, ...);
#line 309 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl sprintf_s(  char (&_Dest)[_Size],     const char * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return vsprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
  __declspec(dllimport) int __cdecl _scprintf(    const char * _Format, ...);
   __declspec(dllimport) int __cdecl sscanf(  const char * _Src,     const char * _Format, ...);
  __declspec(dllimport) int __cdecl _sscanf_l(  const char * _Src,     const char * _Format,   _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl sscanf_s(  const char * _Src,     const char * _Format, ...);
#line 318 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _sscanf_s_l(  const char * _Src,     const char * _Format,   _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _snscanf(    const char * _Src,   size_t _MaxCount,     const char * _Format, ...);
  __declspec(dllimport) int __cdecl _snscanf_l(    const char * _Src,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snscanf_s(    const char * _Src,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _snscanf_s_l(    const char * _Src,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
#pragma warning(pop)
   __declspec(dllimport) FILE * __cdecl tmpfile(void);

 __declspec(dllimport) errno_t __cdecl tmpfile_s(    FILE ** _File);
 __declspec(dllimport) errno_t __cdecl tmpnam_s(  char * _Buf,   rsize_t _Size);
#line 329 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(  char (&_Buf)[_Size]) throw() { return tmpnam_s(_Buf, _Size); } }
 __declspec(dllimport) char * __cdecl tmpnam(  char *_Buffer);
 __declspec(dllimport) int __cdecl ungetc(  int _Ch,   FILE * _File);
 __declspec(dllimport) int __cdecl vfprintf(  FILE * _File,     const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vfprintf_s(  FILE * _File,     const char * _Format, va_list _ArgList);
#line 336 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl vprintf(    const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vprintf_s(    const char * _Format, va_list _ArgList);
#line 340 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
  __declspec(dllimport) int __cdecl vsnprintf(  char * _DstBuf,   size_t _MaxCount,     const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vsnprintf_s(  char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsnprintf_s(  char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, va_list _Args) throw() { return vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _Args); } }
#line 345 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _vsnprintf_s(  char * _DstBuf,   size_t _SizeInBytes,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(  char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, va_list _Args) throw() { return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
 __declspec(dllimport) int __cdecl _snprintf(    char *_Dest,   size_t _Count,     const char * _Format, ...);  __declspec(dllimport) int __cdecl _vsnprintf(    char *_Dest,   size_t _Count,     const char * _Format, va_list _Args);
#pragma warning(pop)

__declspec(dllimport) int __cdecl vsprintf_s(  char * _DstBuf,   size_t _SizeInBytes,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(  char (&_Dest)[_Size],     const char * _Format, va_list _Args) throw() { return vsprintf_s(_Dest, _Size, _Format, _Args); } }
#line 355 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
#pragma warning(push)
#pragma warning(disable:4793)
 __declspec(dllimport) int __cdecl sprintf(  char *_Dest,  const char * _Format, ...);  __declspec(dllimport) int __cdecl vsprintf(  char *_Dest,  const char * _Format, va_list _Args);
#pragma warning(pop)
  __declspec(dllimport) int __cdecl _vscprintf(    const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _snprintf_c(  char * _DstBuf,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _vsnprintf_c(  char *_DstBuf,   size_t _MaxCount,     const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _fprintf_p(  FILE * _File,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _printf_p(    const char * _Format, ...);
 __declspec(dllimport) int __cdecl _sprintf_p(  char * _Dst,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _vfprintf_p(  FILE * _File,     const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vprintf_p(    const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsprintf_p(  char * _Dst,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
  __declspec(dllimport) int __cdecl _scprintf_p(    const char * _Format, ...);
  __declspec(dllimport) int __cdecl _vscprintf_p(    const char * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _set_printf_count_output(  int _Value);
__declspec(dllimport) int __cdecl _get_printf_count_output(void);

 __declspec(dllimport) int __cdecl _printf_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _printf_p_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _printf_s_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vprintf_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vprintf_p_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vprintf_s_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _fprintf_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fprintf_p_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fprintf_s_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vfprintf_l(  FILE * _File,   const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfprintf_p_l(  FILE * _File,   const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfprintf_s_l(  FILE * _File,   const char * _Format,   _locale_t _Locale, va_list _ArgList);

  __declspec(dllimport) int __cdecl _sprintf_l(    char * _DstBuf,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _sprintf_p_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _sprintf_s_l(  char * _DstBuf,   size_t _DstSize,     const char * _Format,   _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _vsprintf_l(    char * _DstBuf,   const char * _Format,   _locale_t, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsprintf_p_l(  char * _DstBuf,   size_t _MaxCount,     const char* _Format,   _locale_t _Locale,  va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsprintf_s_l(  char * _DstBuf,   size_t _DstSize,     const char * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _scprintf_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _scprintf_p_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vscprintf_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vscprintf_p_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);

  __declspec(dllimport) int __cdecl _snprintf_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snprintf_c_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snprintf_s_l(  char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _vsnprintf_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnprintf_c_l(  char * _DstBuf,   size_t _MaxCount, const char *,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnprintf_s_l(  char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char* _Format,  _locale_t _Locale, va_list _ArgList);







#line 414 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"




  __declspec(dllimport) FILE * __cdecl _wfsopen(  const wchar_t * _Filename,   const wchar_t * _Mode,   int _ShFlag);
#line 420 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

 __declspec(dllimport) wint_t __cdecl fgetwc(  FILE * _File);
 __declspec(dllimport) wint_t __cdecl _fgetwchar(void);
 __declspec(dllimport) wint_t __cdecl fputwc(  wchar_t _Ch,   FILE * _File);
 __declspec(dllimport) wint_t __cdecl _fputwchar(  wchar_t _Ch);
  __declspec(dllimport) wint_t __cdecl getwc(  FILE * _File);
  __declspec(dllimport) wint_t __cdecl getwchar(void);
 __declspec(dllimport) wint_t __cdecl putwc(  wchar_t _Ch,   FILE * _File);
 __declspec(dllimport) wint_t __cdecl putwchar(  wchar_t _Ch);
 __declspec(dllimport) wint_t __cdecl ungetwc(  wint_t _Ch,   FILE * _File);

 __declspec(dllimport) wchar_t * __cdecl fgetws(  wchar_t * _Dst,   int _SizeInWords,   FILE * _File);
 __declspec(dllimport) int __cdecl fputws(  const wchar_t * _Str,   FILE * _File);
 __declspec(dllimport) wchar_t * __cdecl _getws_s(  wchar_t * _Str,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline wchar_t * __cdecl _getws_s(  wchar_t (&_String)[_Size]) throw() { return _getws_s(_String, _Size); } }
 __declspec(dllimport) wchar_t * __cdecl _getws(  wchar_t *_String);
 __declspec(dllimport) int __cdecl _putws(  const wchar_t * _Str);

 __declspec(dllimport) int __cdecl fwprintf(  FILE * _File,     const wchar_t * _Format, ...);

 __declspec(dllimport) int __cdecl fwprintf_s(  FILE * _File,     const wchar_t * _Format, ...);
#line 442 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl wprintf(    const wchar_t * _Format, ...);

 __declspec(dllimport) int __cdecl wprintf_s(    const wchar_t * _Format, ...);
#line 446 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
  __declspec(dllimport) int __cdecl _scwprintf(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl vfwprintf(  FILE * _File,     const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vfwprintf_s(  FILE * _File,     const wchar_t * _Format, va_list _ArgList);
#line 451 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl vwprintf(    const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vwprintf_s(    const wchar_t * _Format, va_list _ArgList);
#line 455 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"


__declspec(dllimport) int __cdecl swprintf_s(  wchar_t * _Dst,   size_t _SizeInWords,     const wchar_t * _Format, ...);
#line 459 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl swprintf_s(  wchar_t (&_Dest)[_Size],     const wchar_t * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return vswprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }

__declspec(dllimport) int __cdecl vswprintf_s(  wchar_t * _Dst,   size_t _SizeInWords,     const wchar_t * _Format, va_list _ArgList);
#line 463 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(  wchar_t (&_Dest)[_Size],     const wchar_t * _Format, va_list _Args) throw() { return vswprintf_s(_Dest, _Size, _Format, _Args); } }

 __declspec(dllimport) int __cdecl _swprintf_c(  wchar_t * _DstBuf,   size_t _SizeInWords,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vswprintf_c(  wchar_t * _DstBuf,   size_t _SizeInWords,     const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _snwprintf_s(  wchar_t * _DstBuf,   size_t _SizeInWords,   size_t _MaxCount,     const wchar_t * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snwprintf_s(  wchar_t (&_Dest)[_Size],   size_t _Count,     const wchar_t * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _ArgList); } __pragma(warning(pop)); }
 __declspec(dllimport) int __cdecl _vsnwprintf_s(  wchar_t * _DstBuf,   size_t _SizeInWords,   size_t _MaxCount,     const wchar_t * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(  wchar_t (&_Dest)[_Size],   size_t _Count,     const wchar_t * _Format, va_list _Args) throw() { return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
 __declspec(dllimport) int __cdecl _snwprintf(    wchar_t *_Dest,   size_t _Count,     const wchar_t * _Format, ...);  __declspec(dllimport) int __cdecl _vsnwprintf(    wchar_t *_Dest,   size_t _Count,     const wchar_t * _Format, va_list _Args);
#pragma warning(pop)

 __declspec(dllimport) int __cdecl _fwprintf_p(  FILE * _File,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _wprintf_p(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vfwprintf_p(  FILE * _File,     const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vwprintf_p(    const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _swprintf_p(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vswprintf_p(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format, va_list _ArgList);
  __declspec(dllimport) int __cdecl _scwprintf_p(    const wchar_t * _Format, ...);
  __declspec(dllimport) int __cdecl _vscwprintf_p(    const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _wprintf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _wprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _wprintf_s_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vwprintf_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vwprintf_s_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _fwprintf_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fwprintf_p_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fwprintf_s_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vfwprintf_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfwprintf_p_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfwprintf_s_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _swprintf_c_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _swprintf_p_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _swprintf_s_l(  wchar_t * _DstBuf,   size_t _DstSize,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vswprintf_c_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vswprintf_p_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vswprintf_s_l(  wchar_t * _DstBuf,   size_t _DstSize,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

  __declspec(dllimport) int __cdecl _scwprintf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _scwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _vscwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

  __declspec(dllimport) int __cdecl _snwprintf_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snwprintf_s_l(  wchar_t * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _vsnwprintf_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnwprintf_s_l(  wchar_t * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);










#line 526 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"


#pragma warning(push)
#pragma warning(disable:4141 4996 4793)
 __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _swprintf(    wchar_t *_Dest,     const wchar_t * _Format, ...);  __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _vswprintf(    wchar_t *_Dest,     const wchar_t * _Format, va_list _Args);
 __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __swprintf_l( wchar_t *_Dest,     const wchar_t * _Format, _locale_t _Plocinfo, ...);  __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __vswprintf_l( wchar_t *_Dest,     const wchar_t * _Format, _locale_t _Plocinfo, va_list _Args);
#pragma warning(pop)


#line 1 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"












#pragma once







#line 22 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"










#line 33 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"

#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int swprintf(wchar_t * _String, size_t _Count, const wchar_t * _Format, ...)
{
    va_list _Arglist;
    int _Ret;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl vswprintf(wchar_t * _String, size_t _Count, const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap);
}
#pragma warning( pop )


#line 57 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"

#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int _swprintf_l(wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    int _Ret;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Plocinfo) ) + ( (sizeof(_Plocinfo) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl _vswprintf_l(wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )


#pragma warning( push )
#pragma warning( disable : 4996 )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  __inline int swprintf(    wchar_t * _String,     const wchar_t * _Format, ...)
{
    va_list _Arglist;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    int _Ret = _vswprintf(_String, _Format, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  __inline int __cdecl vswprintf(    wchar_t * _String,     const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf(_String, _Format, _Ap);
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  __inline int _swprintf_l(    wchar_t * _String,     const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Plocinfo) ) + ( (sizeof(_Plocinfo) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  __inline int __cdecl _vswprintf_l(    wchar_t * _String,     const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return __vswprintf_l(_String, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )

#pragma warning( pop )

#line 126 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"

#line 128 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"
#line 129 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"

#line 536 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
#line 537 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"













#line 551 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

  __declspec(dllimport) wchar_t * __cdecl _wtempnam(  const wchar_t * _Directory,   const wchar_t * _FilePrefix);



#line 557 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

  __declspec(dllimport) int __cdecl _vscwprintf(    const wchar_t * _Format, va_list _ArgList);
  __declspec(dllimport) int __cdecl _vscwprintf_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
   __declspec(dllimport) int __cdecl fwscanf(  FILE * _File,     const wchar_t * _Format, ...);
  __declspec(dllimport) int __cdecl _fwscanf_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl fwscanf_s(  FILE * _File,     const wchar_t * _Format, ...);
#line 567 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _fwscanf_s_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
   __declspec(dllimport) int __cdecl swscanf(  const wchar_t * _Src,     const wchar_t * _Format, ...);
  __declspec(dllimport) int __cdecl _swscanf_l(  const wchar_t * _Src,     const wchar_t * _Format,   _locale_t _Locale, ...);

 __declspec(dllimport) int __cdecl swscanf_s(  const wchar_t *_Src,     const wchar_t * _Format, ...);
#line 573 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _swscanf_s_l(  const wchar_t * _Src,     const wchar_t * _Format,   _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _snwscanf(    const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format, ...);
  __declspec(dllimport) int __cdecl _snwscanf_l(    const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snwscanf_s(    const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _snwscanf_s_l(    const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
   __declspec(dllimport) int __cdecl wscanf(    const wchar_t * _Format, ...);
  __declspec(dllimport) int __cdecl _wscanf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);

 __declspec(dllimport) int __cdecl wscanf_s(    const wchar_t * _Format, ...);
#line 583 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _wscanf_s_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
#pragma warning(pop)

  __declspec(dllimport) FILE * __cdecl _wfdopen(  int _FileHandle ,   const wchar_t * _Mode);
   __declspec(dllimport) FILE * __cdecl _wfopen(  const wchar_t * _Filename,   const wchar_t * _Mode);
 __declspec(dllimport) errno_t __cdecl _wfopen_s(  FILE ** _File,   const wchar_t * _Filename,   const wchar_t * _Mode);
   __declspec(dllimport) FILE * __cdecl _wfreopen(  const wchar_t * _Filename,   const wchar_t * _Mode,   FILE * _OldFile);
 __declspec(dllimport) errno_t __cdecl _wfreopen_s(  FILE ** _File,   const wchar_t * _Filename,   const wchar_t * _Mode,   FILE * _OldFile);






  __declspec(dllimport) FILE * __cdecl _wpopen(  const wchar_t *_Command,   const wchar_t * _Mode);
#line 599 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
__declspec(dllimport) int __cdecl _wremove(  const wchar_t * _Filename);
 __declspec(dllimport) errno_t __cdecl _wtmpnam_s(  wchar_t * _DstBuf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
 __declspec(dllimport) wchar_t * __cdecl _wtmpnam(  wchar_t *_Buffer);

 __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(  FILE * _File);
 __declspec(dllimport) wint_t __cdecl _fputwc_nolock(  wchar_t _Ch,   FILE * _File);
 __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(  wint_t _Ch,   FILE * _File);






#line 614 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
inline   wint_t __cdecl getwchar()
        {return (fgetwc((&__iob_func()[0]))); }   
inline  wint_t __cdecl putwchar(  wchar_t _C)
        {return (fputwc(_C, (&__iob_func()[1]))); }       
#line 619 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"










#line 630 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"


#line 633 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"


#line 636 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"















#line 652 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"











__declspec(dllimport) void __cdecl _lock_file(  FILE * _File);
__declspec(dllimport) void __cdecl _unlock_file(  FILE * _File);

 __declspec(dllimport) int __cdecl _fclose_nolock(  FILE * _File);
 __declspec(dllimport) int __cdecl _fflush_nolock(  FILE * _File);
 __declspec(dllimport) size_t __cdecl _fread_nolock(  void * _DstBuf,   size_t _ElementSize,   size_t _Count,   FILE * _File);
 __declspec(dllimport) size_t __cdecl _fread_nolock_s(  void * _DstBuf,   size_t _DstSize,   size_t _ElementSize,   size_t _Count,   FILE * _File);
 __declspec(dllimport) int __cdecl _fseek_nolock(  FILE * _File,   long _Offset,   int _Origin);
  __declspec(dllimport) long __cdecl _ftell_nolock(  FILE * _File);
 __declspec(dllimport) int __cdecl _fseeki64_nolock(  FILE * _File,   __int64 _Offset,   int _Origin);
  __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(  FILE * _File);
 __declspec(dllimport) size_t __cdecl _fwrite_nolock(  const void * _DstBuf,   size_t _Size,   size_t _Count,   FILE * _File);
 __declspec(dllimport) int __cdecl _ungetc_nolock(  int _Ch,   FILE * _File);












#line 689 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"











#line 701 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

 __declspec(dllimport) char * __cdecl tempnam(  const char * _Directory,   const char * _FilePrefix);



#line 707 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

  __declspec(dllimport) int __cdecl fcloseall(void);
   __declspec(dllimport) FILE * __cdecl fdopen(  int _FileHandle,   const char * _Format);
  __declspec(dllimport) int __cdecl fgetchar(void);
   __declspec(dllimport) int __cdecl fileno(  FILE * _File);
  __declspec(dllimport) int __cdecl flushall(void);
  __declspec(dllimport) int __cdecl fputchar(  int _Ch);
   __declspec(dllimport) int __cdecl getw(  FILE * _File);
  __declspec(dllimport) int __cdecl putw(  int _Ch,   FILE * _File);
   __declspec(dllimport) int __cdecl rmtmp(void);

#line 719 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"


}
#line 723 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

#pragma pack(pop)

#line 727 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

#line 3 "C:/Users/H8/Documents/Visual Studio 2012/Projects/AmpIdent/AmpIdentGPUkernel/AmpIdentGPUkernel/kernel.cu"
 
__declspec(__global__) void kernel(int a, int b, int *c)
{
    *c = (a + b)*(a + b);
}
 
int main()
{
    return 0;
}
