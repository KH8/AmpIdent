#line 1 "C:/Users/H8/Documents/Visual Studio 2012/Projects/AmpIdent/AmpIdentGPUkernel/AmpIdentGPUkernel/kernel.cu"
#line 702 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"
#pragma region Input Buffer SAL 1 compatibility macros
#line 1466
#pragma endregion Input Buffer SAL 1 compatibility macros
#line 61 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#pragma pack ( push, 8 )
#line 29 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"
#pragma pack ( push, 8 )
#line 48 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"
extern "C" { typedef unsigned __w64 uintptr_t; }
#line 57 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"
extern "C" { typedef char *va_list; }
#line 142 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"
#pragma pack ( pop )
#line 430 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
typedef unsigned __w64 size_t; 
#include "crt/host_runtime.h"
#line 437 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
extern "C" { typedef size_t rsize_t; }
#line 446 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
extern "C" { typedef int __w64 intptr_t; }
#line 464 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
extern "C" { typedef int __w64 ptrdiff_t; }
#line 475 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
extern "C" { typedef unsigned short wint_t; }
#line 476
extern "C" { typedef unsigned short wctype_t; }
#line 497 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
extern "C" { typedef int errno_t; }
#line 501 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
extern "C" { typedef long __w64 __time32_t; }
#line 506 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
extern "C" { typedef __int64 __time64_t; }
#line 514 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
extern "C" { typedef __time64_t time_t; }
#line 569 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
extern "C" { __declspec(dllimport) void __cdecl _invalid_parameter(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); } 
#line 576 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
extern "C" { 
#line 575
__declspec(dllimport) __declspec(noreturn) void __cdecl 
#line 576
_invoke_watson(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); } 
#line 1979 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
struct threadlocaleinfostruct; 
#line 1980
struct threadmbcinfostruct; 
#line 1981
extern "C" { typedef threadlocaleinfostruct *pthreadlocinfo; }
#line 1982
extern "C" { typedef threadmbcinfostruct *pthreadmbcinfo; }
#line 1983
struct __lc_time_data; 
#line 1989
extern "C" { typedef 
#line 1985
struct localeinfo_struct { 
#line 1987
pthreadlocinfo locinfo; 
#line 1988
pthreadmbcinfo mbcinfo; 
#line 1989
} _locale_tstruct, *_locale_t; }
#line 1997
extern "C" { typedef 
#line 1992
struct localerefcount { 
#line 1993
char *locale; 
#line 1994
__wchar_t *wlocale; 
#line 1995
int *refcount; 
#line 1996
int *wrefcount; 
#line 1997
} locrefcount; }
#line 2018
extern "C" { typedef 
#line 1999
struct threadlocaleinfostruct { 
#line 2000
int refcount; 
#line 2001
unsigned lc_codepage; 
#line 2002
unsigned lc_collate_cp; 
#line 2003
unsigned lc_time_cp; 
#line 2004
locrefcount lc_category[6]; 
#line 2005
int lc_clike; 
#line 2006
int mb_cur_max; 
#line 2007
int *lconv_intl_refcount; 
#line 2008
int *lconv_num_refcount; 
#line 2009
int *lconv_mon_refcount; 
#line 2010
struct lconv *lconv; 
#line 2011
int *ctype1_refcount; 
#line 2012
unsigned short *ctype1; 
#line 2013
const unsigned short *pctype; 
#line 2014
const unsigned char *pclmap; 
#line 2015
const unsigned char *pcumap; 
#line 2016
__lc_time_data *lc_time_curr; 
#line 2017
__wchar_t *locale_name[6]; 
#line 2018
} threadlocinfo; }
#line 2055 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#pragma pack ( pop )
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_types.h"
#if 0
#line 61
enum cudaRoundMode { 
#line 63
cudaRoundNearest, 
#line 64
cudaRoundZero, 
#line 65
cudaRoundPosInf, 
#line 66
cudaRoundMinInf
#line 67
}; 
#endif
#line 36 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"
namespace std { typedef decltype((__nullptr)) nullptr_t; }
#line 37
using std::nullptr_t;
#line 43 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"
extern "C" { __declspec(dllimport) extern int *__cdecl _errno(); } 
#line 46
extern "C" { errno_t __cdecl _set_errno(int ); } 
#line 47
extern "C" { errno_t __cdecl _get_errno(int * ); } 
#line 69 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"
extern "C" { __declspec(dllimport) extern unsigned long __cdecl __threadid(); } 
#line 71
extern "C" { __declspec(dllimport) extern uintptr_t __cdecl __threadhandle(); } 
#line 124 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 124
enum cudaError { 
#line 131
cudaSuccess, 
#line 137
cudaErrorMissingConfiguration, 
#line 143
cudaErrorMemoryAllocation, 
#line 149
cudaErrorInitializationError, 
#line 159
cudaErrorLaunchFailure, 
#line 168
cudaErrorPriorLaunchFailure, 
#line 178
cudaErrorLaunchTimeout, 
#line 187
cudaErrorLaunchOutOfResources, 
#line 193
cudaErrorInvalidDeviceFunction, 
#line 202
cudaErrorInvalidConfiguration, 
#line 208
cudaErrorInvalidDevice, 
#line 214
cudaErrorInvalidValue, 
#line 220
cudaErrorInvalidPitchValue, 
#line 226
cudaErrorInvalidSymbol, 
#line 231
cudaErrorMapBufferObjectFailed, 
#line 236
cudaErrorUnmapBufferObjectFailed, 
#line 242
cudaErrorInvalidHostPointer, 
#line 248
cudaErrorInvalidDevicePointer, 
#line 254
cudaErrorInvalidTexture, 
#line 260
cudaErrorInvalidTextureBinding, 
#line 267
cudaErrorInvalidChannelDescriptor, 
#line 273
cudaErrorInvalidMemcpyDirection, 
#line 283
cudaErrorAddressOfConstant, 
#line 292
cudaErrorTextureFetchFailed, 
#line 301
cudaErrorTextureNotBound, 
#line 310
cudaErrorSynchronizationError, 
#line 316
cudaErrorInvalidFilterSetting, 
#line 322
cudaErrorInvalidNormSetting, 
#line 330
cudaErrorMixedDeviceExecution, 
#line 337
cudaErrorCudartUnloading, 
#line 342
cudaErrorUnknown, 
#line 350
cudaErrorNotYetImplemented, 
#line 359
cudaErrorMemoryValueTooLarge, 
#line 366
cudaErrorInvalidResourceHandle, 
#line 374
cudaErrorNotReady, 
#line 381
cudaErrorInsufficientDriver, 
#line 394
cudaErrorSetOnActiveProcess, 
#line 400
cudaErrorInvalidSurface, 
#line 406
cudaErrorNoDevice, 
#line 412
cudaErrorECCUncorrectable, 
#line 417
cudaErrorSharedObjectSymbolNotFound, 
#line 422
cudaErrorSharedObjectInitFailed, 
#line 428
cudaErrorUnsupportedLimit, 
#line 434
cudaErrorDuplicateVariableName, 
#line 440
cudaErrorDuplicateTextureName, 
#line 446
cudaErrorDuplicateSurfaceName, 
#line 456
cudaErrorDevicesUnavailable, 
#line 461
cudaErrorInvalidKernelImage, 
#line 469
cudaErrorNoKernelImageForDevice, 
#line 482
cudaErrorIncompatibleDriverContext, 
#line 489
cudaErrorPeerAccessAlreadyEnabled, 
#line 496
cudaErrorPeerAccessNotEnabled, 
#line 502
cudaErrorDeviceAlreadyInUse = 54, 
#line 509
cudaErrorProfilerDisabled, 
#line 517
cudaErrorProfilerNotInitialized, 
#line 524
cudaErrorProfilerAlreadyStarted, 
#line 531
cudaErrorProfilerAlreadyStopped, 
#line 539
cudaErrorAssert, 
#line 546
cudaErrorTooManyPeers, 
#line 552
cudaErrorHostMemoryAlreadyRegistered, 
#line 558
cudaErrorHostMemoryNotRegistered, 
#line 563
cudaErrorOperatingSystem, 
#line 569
cudaErrorPeerAccessUnsupported, 
#line 576
cudaErrorLaunchMaxDepthExceeded, 
#line 584
cudaErrorLaunchFileScopedTex, 
#line 592
cudaErrorLaunchFileScopedSurf, 
#line 607
cudaErrorSyncDepthExceeded, 
#line 619
cudaErrorLaunchPendingCountExceeded, 
#line 624
cudaErrorNotPermitted, 
#line 630
cudaErrorNotSupported, 
#line 635
cudaErrorStartupFailure = 127, 
#line 643
cudaErrorApiFailureBase = 10000
#line 644
}; 
#endif
#line 649 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 649
enum cudaChannelFormatKind { 
#line 651
cudaChannelFormatKindSigned, 
#line 652
cudaChannelFormatKindUnsigned, 
#line 653
cudaChannelFormatKindFloat, 
#line 654
cudaChannelFormatKindNone
#line 655
}; 
#endif
#line 660 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 660
struct cudaChannelFormatDesc { 
#line 662
int x; 
#line 663
int y; 
#line 664
int z; 
#line 665
int w; 
#line 666
cudaChannelFormatKind f; 
#line 667
}; 
#endif
#line 672 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
typedef struct cudaArray *cudaArray_t; 
#line 677
typedef const cudaArray *cudaArray_const_t; 
#line 679
struct cudaArray; 
#line 684
typedef struct cudaMipmappedArray *cudaMipmappedArray_t; 
#line 689
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t; 
#line 691
struct cudaMipmappedArray; 
#line 696
#if 0
#line 696
enum cudaMemoryType { 
#line 698
cudaMemoryTypeHost = 1, 
#line 699
cudaMemoryTypeDevice
#line 700
}; 
#endif
#line 705 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 705
enum cudaMemcpyKind { 
#line 707
cudaMemcpyHostToHost, 
#line 708
cudaMemcpyHostToDevice, 
#line 709
cudaMemcpyDeviceToHost, 
#line 710
cudaMemcpyDeviceToDevice, 
#line 711
cudaMemcpyDefault
#line 712
}; 
#endif
#line 718 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 718
struct cudaPitchedPtr { 
#line 720
void *ptr; 
#line 721
size_t pitch; 
#line 722
size_t xsize; 
#line 723
size_t ysize; 
#line 724
}; 
#endif
#line 730 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 730
struct cudaExtent { 
#line 732
size_t width; 
#line 733
size_t height; 
#line 734
size_t depth; 
#line 735
}; 
#endif
#line 741 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 741
struct cudaPos { 
#line 743
size_t x; 
#line 744
size_t y; 
#line 745
size_t z; 
#line 746
}; 
#endif
#line 751 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 751
struct cudaMemcpy3DParms { 
#line 753
cudaArray_t srcArray; 
#line 754
cudaPos srcPos; 
#line 755
cudaPitchedPtr srcPtr; 
#line 757
cudaArray_t dstArray; 
#line 758
cudaPos dstPos; 
#line 759
cudaPitchedPtr dstPtr; 
#line 761
cudaExtent extent; 
#line 762
cudaMemcpyKind kind; 
#line 763
}; 
#endif
#line 768 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 768
struct cudaMemcpy3DPeerParms { 
#line 770
cudaArray_t srcArray; 
#line 771
cudaPos srcPos; 
#line 772
cudaPitchedPtr srcPtr; 
#line 773
int srcDevice; 
#line 775
cudaArray_t dstArray; 
#line 776
cudaPos dstPos; 
#line 777
cudaPitchedPtr dstPtr; 
#line 778
int dstDevice; 
#line 780
cudaExtent extent; 
#line 781
}; 
#endif
#line 786 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
struct cudaGraphicsResource; 
#line 791
#if 0
#line 791
enum cudaGraphicsRegisterFlags { 
#line 793
cudaGraphicsRegisterFlagsNone, 
#line 794
cudaGraphicsRegisterFlagsReadOnly, 
#line 795
cudaGraphicsRegisterFlagsWriteDiscard, 
#line 796
cudaGraphicsRegisterFlagsSurfaceLoadStore = 4, 
#line 797
cudaGraphicsRegisterFlagsTextureGather = 8
#line 798
}; 
#endif
#line 803 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 803
enum cudaGraphicsMapFlags { 
#line 805
cudaGraphicsMapFlagsNone, 
#line 806
cudaGraphicsMapFlagsReadOnly, 
#line 807
cudaGraphicsMapFlagsWriteDiscard
#line 808
}; 
#endif
#line 813 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 813
enum cudaGraphicsCubeFace { 
#line 815
cudaGraphicsCubeFacePositiveX, 
#line 816
cudaGraphicsCubeFaceNegativeX, 
#line 817
cudaGraphicsCubeFacePositiveY, 
#line 818
cudaGraphicsCubeFaceNegativeY, 
#line 819
cudaGraphicsCubeFacePositiveZ, 
#line 820
cudaGraphicsCubeFaceNegativeZ
#line 821
}; 
#endif
#line 826 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 826
enum cudaResourceType { 
#line 828
cudaResourceTypeArray, 
#line 829
cudaResourceTypeMipmappedArray, 
#line 830
cudaResourceTypeLinear, 
#line 831
cudaResourceTypePitch2D
#line 832
}; 
#endif
#line 837 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 837
enum cudaResourceViewFormat { 
#line 839
cudaResViewFormatNone, 
#line 840
cudaResViewFormatUnsignedChar1, 
#line 841
cudaResViewFormatUnsignedChar2, 
#line 842
cudaResViewFormatUnsignedChar4, 
#line 843
cudaResViewFormatSignedChar1, 
#line 844
cudaResViewFormatSignedChar2, 
#line 845
cudaResViewFormatSignedChar4, 
#line 846
cudaResViewFormatUnsignedShort1, 
#line 847
cudaResViewFormatUnsignedShort2, 
#line 848
cudaResViewFormatUnsignedShort4, 
#line 849
cudaResViewFormatSignedShort1, 
#line 850
cudaResViewFormatSignedShort2, 
#line 851
cudaResViewFormatSignedShort4, 
#line 852
cudaResViewFormatUnsignedInt1, 
#line 853
cudaResViewFormatUnsignedInt2, 
#line 854
cudaResViewFormatUnsignedInt4, 
#line 855
cudaResViewFormatSignedInt1, 
#line 856
cudaResViewFormatSignedInt2, 
#line 857
cudaResViewFormatSignedInt4, 
#line 858
cudaResViewFormatHalf1, 
#line 859
cudaResViewFormatHalf2, 
#line 860
cudaResViewFormatHalf4, 
#line 861
cudaResViewFormatFloat1, 
#line 862
cudaResViewFormatFloat2, 
#line 863
cudaResViewFormatFloat4, 
#line 864
cudaResViewFormatUnsignedBlockCompressed1, 
#line 865
cudaResViewFormatUnsignedBlockCompressed2, 
#line 866
cudaResViewFormatUnsignedBlockCompressed3, 
#line 867
cudaResViewFormatUnsignedBlockCompressed4, 
#line 868
cudaResViewFormatSignedBlockCompressed4, 
#line 869
cudaResViewFormatUnsignedBlockCompressed5, 
#line 870
cudaResViewFormatSignedBlockCompressed5, 
#line 871
cudaResViewFormatUnsignedBlockCompressed6H, 
#line 872
cudaResViewFormatSignedBlockCompressed6H, 
#line 873
cudaResViewFormatUnsignedBlockCompressed7
#line 874
}; 
#endif
#line 879 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 879
struct cudaResourceDesc { 
#line 880
cudaResourceType resType; 
#line 882
union { 
#line 883
struct { 
#line 884
cudaArray_t array; 
#line 885
} array; 
#line 886
struct { 
#line 887
cudaMipmappedArray_t mipmap; 
#line 888
} mipmap; 
#line 889
struct { 
#line 890
void *devPtr; 
#line 891
cudaChannelFormatDesc desc; 
#line 892
size_t sizeInBytes; 
#line 893
} linear; 
#line 894
struct { 
#line 895
void *devPtr; 
#line 896
cudaChannelFormatDesc desc; 
#line 897
size_t width; 
#line 898
size_t height; 
#line 899
size_t pitchInBytes; 
#line 900
} pitch2D; 
#line 901
} res; 
#line 902
}; 
#endif
#line 907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 907
struct cudaResourceViewDesc { 
#line 909
cudaResourceViewFormat format; 
#line 910
size_t width; 
#line 911
size_t height; 
#line 912
size_t depth; 
#line 913
unsigned firstMipmapLevel; 
#line 914
unsigned lastMipmapLevel; 
#line 915
unsigned firstLayer; 
#line 916
unsigned lastLayer; 
#line 917
}; 
#endif
#line 922 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 922
struct cudaPointerAttributes { 
#line 928
cudaMemoryType memoryType; 
#line 939
int device; 
#line 945
void *devicePointer; 
#line 951
void *hostPointer; 
#line 952
}; 
#endif
#line 957 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 957
struct cudaFuncAttributes { 
#line 964
size_t sharedSizeBytes; 
#line 970
size_t constSizeBytes; 
#line 975
size_t localSizeBytes; 
#line 982
int maxThreadsPerBlock; 
#line 987
int numRegs; 
#line 994
int ptxVersion; 
#line 1001
int binaryVersion; 
#line 1002
}; 
#endif
#line 1007 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 1007
enum cudaFuncCache { 
#line 1009
cudaFuncCachePreferNone, 
#line 1010
cudaFuncCachePreferShared, 
#line 1011
cudaFuncCachePreferL1, 
#line 1012
cudaFuncCachePreferEqual
#line 1013
}; 
#endif
#line 1019 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 1019
enum cudaSharedMemConfig { 
#line 1021
cudaSharedMemBankSizeDefault, 
#line 1022
cudaSharedMemBankSizeFourByte, 
#line 1023
cudaSharedMemBankSizeEightByte
#line 1024
}; 
#endif
#line 1029 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 1029
enum cudaComputeMode { 
#line 1031
cudaComputeModeDefault, 
#line 1032
cudaComputeModeExclusive, 
#line 1033
cudaComputeModeProhibited, 
#line 1034
cudaComputeModeExclusiveProcess
#line 1035
}; 
#endif
#line 1040 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 1040
enum cudaLimit { 
#line 1042
cudaLimitStackSize, 
#line 1043
cudaLimitPrintfFifoSize, 
#line 1044
cudaLimitMallocHeapSize, 
#line 1045
cudaLimitDevRuntimeSyncDepth, 
#line 1046
cudaLimitDevRuntimePendingLaunchCount
#line 1047
}; 
#endif
#line 1052 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 1052
enum cudaOutputMode { 
#line 1054
cudaKeyValuePair, 
#line 1055
cudaCSV
#line 1056
}; 
#endif
#line 1061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 1061
enum cudaDeviceAttr { 
#line 1063
cudaDevAttrMaxThreadsPerBlock = 1, 
#line 1064
cudaDevAttrMaxBlockDimX, 
#line 1065
cudaDevAttrMaxBlockDimY, 
#line 1066
cudaDevAttrMaxBlockDimZ, 
#line 1067
cudaDevAttrMaxGridDimX, 
#line 1068
cudaDevAttrMaxGridDimY, 
#line 1069
cudaDevAttrMaxGridDimZ, 
#line 1070
cudaDevAttrMaxSharedMemoryPerBlock, 
#line 1071
cudaDevAttrTotalConstantMemory, 
#line 1072
cudaDevAttrWarpSize, 
#line 1073
cudaDevAttrMaxPitch, 
#line 1074
cudaDevAttrMaxRegistersPerBlock, 
#line 1075
cudaDevAttrClockRate, 
#line 1076
cudaDevAttrTextureAlignment, 
#line 1077
cudaDevAttrGpuOverlap, 
#line 1078
cudaDevAttrMultiProcessorCount, 
#line 1079
cudaDevAttrKernelExecTimeout, 
#line 1080
cudaDevAttrIntegrated, 
#line 1081
cudaDevAttrCanMapHostMemory, 
#line 1082
cudaDevAttrComputeMode, 
#line 1083
cudaDevAttrMaxTexture1DWidth, 
#line 1084
cudaDevAttrMaxTexture2DWidth, 
#line 1085
cudaDevAttrMaxTexture2DHeight, 
#line 1086
cudaDevAttrMaxTexture3DWidth, 
#line 1087
cudaDevAttrMaxTexture3DHeight, 
#line 1088
cudaDevAttrMaxTexture3DDepth, 
#line 1089
cudaDevAttrMaxTexture2DLayeredWidth, 
#line 1090
cudaDevAttrMaxTexture2DLayeredHeight, 
#line 1091
cudaDevAttrMaxTexture2DLayeredLayers, 
#line 1092
cudaDevAttrSurfaceAlignment, 
#line 1093
cudaDevAttrConcurrentKernels, 
#line 1094
cudaDevAttrEccEnabled, 
#line 1095
cudaDevAttrPciBusId, 
#line 1096
cudaDevAttrPciDeviceId, 
#line 1097
cudaDevAttrTccDriver, 
#line 1098
cudaDevAttrMemoryClockRate, 
#line 1099
cudaDevAttrGlobalMemoryBusWidth, 
#line 1100
cudaDevAttrL2CacheSize, 
#line 1101
cudaDevAttrMaxThreadsPerMultiProcessor, 
#line 1102
cudaDevAttrAsyncEngineCount, 
#line 1103
cudaDevAttrUnifiedAddressing, 
#line 1104
cudaDevAttrMaxTexture1DLayeredWidth, 
#line 1105
cudaDevAttrMaxTexture1DLayeredLayers, 
#line 1106
cudaDevAttrMaxTexture2DGatherWidth = 45, 
#line 1107
cudaDevAttrMaxTexture2DGatherHeight, 
#line 1108
cudaDevAttrMaxTexture3DWidthAlt, 
#line 1109
cudaDevAttrMaxTexture3DHeightAlt, 
#line 1110
cudaDevAttrMaxTexture3DDepthAlt, 
#line 1111
cudaDevAttrPciDomainId, 
#line 1112
cudaDevAttrTexturePitchAlignment, 
#line 1113
cudaDevAttrMaxTextureCubemapWidth, 
#line 1114
cudaDevAttrMaxTextureCubemapLayeredWidth, 
#line 1115
cudaDevAttrMaxTextureCubemapLayeredLayers, 
#line 1116
cudaDevAttrMaxSurface1DWidth, 
#line 1117
cudaDevAttrMaxSurface2DWidth, 
#line 1118
cudaDevAttrMaxSurface2DHeight, 
#line 1119
cudaDevAttrMaxSurface3DWidth, 
#line 1120
cudaDevAttrMaxSurface3DHeight, 
#line 1121
cudaDevAttrMaxSurface3DDepth, 
#line 1122
cudaDevAttrMaxSurface1DLayeredWidth, 
#line 1123
cudaDevAttrMaxSurface1DLayeredLayers, 
#line 1124
cudaDevAttrMaxSurface2DLayeredWidth, 
#line 1125
cudaDevAttrMaxSurface2DLayeredHeight, 
#line 1126
cudaDevAttrMaxSurface2DLayeredLayers, 
#line 1127
cudaDevAttrMaxSurfaceCubemapWidth, 
#line 1128
cudaDevAttrMaxSurfaceCubemapLayeredWidth, 
#line 1129
cudaDevAttrMaxSurfaceCubemapLayeredLayers, 
#line 1130
cudaDevAttrMaxTexture1DLinearWidth, 
#line 1131
cudaDevAttrMaxTexture2DLinearWidth, 
#line 1132
cudaDevAttrMaxTexture2DLinearHeight, 
#line 1133
cudaDevAttrMaxTexture2DLinearPitch, 
#line 1134
cudaDevAttrMaxTexture2DMipmappedWidth, 
#line 1135
cudaDevAttrMaxTexture2DMipmappedHeight, 
#line 1136
cudaDevAttrComputeCapabilityMajor, 
#line 1137
cudaDevAttrComputeCapabilityMinor, 
#line 1138
cudaDevAttrMaxTexture1DMipmappedWidth, 
#line 1139
cudaDevAttrStreamPrioritiesSupported
#line 1140
}; 
#endif
#line 1145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
#line 1145
struct cudaDeviceProp { 
#line 1147
char name[256]; 
#line 1148
size_t totalGlobalMem; 
#line 1149
size_t sharedMemPerBlock; 
#line 1150
int regsPerBlock; 
#line 1151
int warpSize; 
#line 1152
size_t memPitch; 
#line 1153
int maxThreadsPerBlock; 
#line 1154
int maxThreadsDim[3]; 
#line 1155
int maxGridSize[3]; 
#line 1156
int clockRate; 
#line 1157
size_t totalConstMem; 
#line 1158
int major; 
#line 1159
int minor; 
#line 1160
size_t textureAlignment; 
#line 1161
size_t texturePitchAlignment; 
#line 1162
int deviceOverlap; 
#line 1163
int multiProcessorCount; 
#line 1164
int kernelExecTimeoutEnabled; 
#line 1165
int integrated; 
#line 1166
int canMapHostMemory; 
#line 1167
int computeMode; 
#line 1168
int maxTexture1D; 
#line 1169
int maxTexture1DMipmap; 
#line 1170
int maxTexture1DLinear; 
#line 1171
int maxTexture2D[2]; 
#line 1172
int maxTexture2DMipmap[2]; 
#line 1173
int maxTexture2DLinear[3]; 
#line 1174
int maxTexture2DGather[2]; 
#line 1175
int maxTexture3D[3]; 
#line 1176
int maxTexture3DAlt[3]; 
#line 1177
int maxTextureCubemap; 
#line 1178
int maxTexture1DLayered[2]; 
#line 1179
int maxTexture2DLayered[3]; 
#line 1180
int maxTextureCubemapLayered[2]; 
#line 1181
int maxSurface1D; 
#line 1182
int maxSurface2D[2]; 
#line 1183
int maxSurface3D[3]; 
#line 1184
int maxSurface1DLayered[2]; 
#line 1185
int maxSurface2DLayered[3]; 
#line 1186
int maxSurfaceCubemap; 
#line 1187
int maxSurfaceCubemapLayered[2]; 
#line 1188
size_t surfaceAlignment; 
#line 1189
int concurrentKernels; 
#line 1190
int ECCEnabled; 
#line 1191
int pciBusID; 
#line 1192
int pciDeviceID; 
#line 1193
int pciDomainID; 
#line 1194
int tccDriver; 
#line 1195
int asyncEngineCount; 
#line 1196
int unifiedAddressing; 
#line 1197
int memoryClockRate; 
#line 1198
int memoryBusWidth; 
#line 1199
int l2CacheSize; 
#line 1200
int maxThreadsPerMultiProcessor; 
#line 1201
int streamPrioritiesSupported; 
#line 1202
}; 
#endif
#line 1274 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
typedef 
#line 1271
struct cudaIpcEventHandle_st { 
#line 1273
char reserved[64]; 
#line 1274
} cudaIpcEventHandle_t; 
#endif
#line 1282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
typedef 
#line 1279
struct cudaIpcMemHandle_st { 
#line 1281
char reserved[64]; 
#line 1282
} cudaIpcMemHandle_t; 
#endif
#line 1293 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
typedef cudaError 
#line 1293
cudaError_t; 
#endif
#line 1298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
typedef struct CUstream_st *
#line 1298
cudaStream_t; 
#endif
#line 1303 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
typedef struct CUevent_st *
#line 1303
cudaEvent_t; 
#endif
#line 1308 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
typedef cudaGraphicsResource *
#line 1308
cudaGraphicsResource_t; 
#endif
#line 1313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
typedef struct CUuuid_st 
#line 1313
cudaUUID_t; 
#endif
#line 1318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_types.h"
#if 0
typedef cudaOutputMode 
#line 1318
cudaOutputMode_t; 
#endif
#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#if 0
#line 84
enum cudaSurfaceBoundaryMode { 
#line 86
cudaBoundaryModeZero, 
#line 87
cudaBoundaryModeClamp, 
#line 88
cudaBoundaryModeTrap
#line 89
}; 
#endif
#line 94 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#if 0
#line 94
enum cudaSurfaceFormatMode { 
#line 96
cudaFormatModeForced, 
#line 97
cudaFormatModeAuto
#line 98
}; 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#if 0
#line 103
struct surfaceReference { 
#line 108
cudaChannelFormatDesc channelDesc; 
#line 109
}; 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_types.h"
#if 0
typedef unsigned __int64 
#line 114
cudaSurfaceObject_t; 
#endif
#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#if 0
#line 84
enum cudaTextureAddressMode { 
#line 86
cudaAddressModeWrap, 
#line 87
cudaAddressModeClamp, 
#line 88
cudaAddressModeMirror, 
#line 89
cudaAddressModeBorder
#line 90
}; 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#if 0
#line 95
enum cudaTextureFilterMode { 
#line 97
cudaFilterModePoint, 
#line 98
cudaFilterModeLinear
#line 99
}; 
#endif
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#if 0
#line 104
enum cudaTextureReadMode { 
#line 106
cudaReadModeElementType, 
#line 107
cudaReadModeNormalizedFloat
#line 108
}; 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#if 0
#line 113
struct textureReference { 
#line 118
int normalized; 
#line 122
cudaTextureFilterMode filterMode; 
#line 126
cudaTextureAddressMode addressMode[3]; 
#line 130
cudaChannelFormatDesc channelDesc; 
#line 134
int sRGB; 
#line 138
unsigned maxAnisotropy; 
#line 142
cudaTextureFilterMode mipmapFilterMode; 
#line 146
float mipmapLevelBias; 
#line 150
float minMipmapLevelClamp; 
#line 154
float maxMipmapLevelClamp; 
#line 155
int __cudaReserved[15]; 
#line 156
}; 
#endif
#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#if 0
#line 161
struct cudaTextureDesc { 
#line 166
cudaTextureAddressMode addressMode[3]; 
#line 170
cudaTextureFilterMode filterMode; 
#line 174
cudaTextureReadMode readMode; 
#line 178
int sRGB; 
#line 182
int normalizedCoords; 
#line 186
unsigned maxAnisotropy; 
#line 190
cudaTextureFilterMode mipmapFilterMode; 
#line 194
float mipmapLevelBias; 
#line 198
float minMipmapLevelClamp; 
#line 202
float maxMipmapLevelClamp; 
#line 203
}; 
#endif
#line 208 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_types.h"
#if 0
typedef unsigned __int64 
#line 208
cudaTextureObject_t; 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 96
struct char1 { 
#line 98
signed char x; 
#line 99
}; 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 101
struct uchar1 { 
#line 103
unsigned char x; 
#line 104
}; 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 107
struct __declspec(align(2)) char2 { 
#line 109
signed char x, y; 
#line 110
}; 
#endif
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 112
struct __declspec(align(2)) uchar2 { 
#line 114
unsigned char x, y; 
#line 115
}; 
#endif
#line 117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 117
struct char3 { 
#line 119
signed char x, y, z; 
#line 120
}; 
#endif
#line 122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 122
struct uchar3 { 
#line 124
unsigned char x, y, z; 
#line 125
}; 
#endif
#line 127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 127
struct __declspec(align(4)) char4 { 
#line 129
signed char x, y, z, w; 
#line 130
}; 
#endif
#line 132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 132
struct __declspec(align(4)) uchar4 { 
#line 134
unsigned char x, y, z, w; 
#line 135
}; 
#endif
#line 137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 137
struct short1 { 
#line 139
short x; 
#line 140
}; 
#endif
#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 142
struct ushort1 { 
#line 144
unsigned short x; 
#line 145
}; 
#endif
#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 147
struct __declspec(align(4)) short2 { 
#line 149
short x, y; 
#line 150
}; 
#endif
#line 152 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 152
struct __declspec(align(4)) ushort2 { 
#line 154
unsigned short x, y; 
#line 155
}; 
#endif
#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 157
struct short3 { 
#line 159
short x, y, z; 
#line 160
}; 
#endif
#line 162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 162
struct ushort3 { 
#line 164
unsigned short x, y, z; 
#line 165
}; 
#endif
#line 167 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 167
struct __declspec(align(8)) short4 { short x; short y; short z; short w; }; 
#endif
#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 168
struct __declspec(align(8)) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; 
#endif
#line 170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 170
struct int1 { 
#line 172
int x; 
#line 173
}; 
#endif
#line 175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 175
struct uint1 { 
#line 177
unsigned x; 
#line 178
}; 
#endif
#line 180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 180
struct __declspec(align(8)) int2 { int x; int y; }; 
#endif
#line 181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 181
struct __declspec(align(8)) uint2 { unsigned x; unsigned y; }; 
#endif
#line 183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 183
struct int3 { 
#line 185
int x, y, z; 
#line 186
}; 
#endif
#line 188 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 188
struct uint3 { 
#line 190
unsigned x, y, z; 
#line 191
}; 
#endif
#line 193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 193
struct __declspec(align(16)) int4 { 
#line 195
int x, y, z, w; 
#line 196
}; 
#endif
#line 198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 198
struct __declspec(align(16)) uint4 { 
#line 200
unsigned x, y, z, w; 
#line 201
}; 
#endif
#line 203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 203
struct long1 { 
#line 205
long x; 
#line 206
}; 
#endif
#line 208 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 208
struct ulong1 { 
#line 210
unsigned long x; 
#line 211
}; 
#endif
#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 214
struct __declspec(align(8)) long2 { long x; long y; }; 
#endif
#line 215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 215
struct __declspec(align(8)) ulong2 { unsigned long x; unsigned long y; }; 
#endif
#line 230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 230
struct long3 { 
#line 232
long x, y, z; 
#line 233
}; 
#endif
#line 235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 235
struct ulong3 { 
#line 237
unsigned long x, y, z; 
#line 238
}; 
#endif
#line 240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 240
struct __declspec(align(16)) long4 { 
#line 242
long x, y, z, w; 
#line 243
}; 
#endif
#line 245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 245
struct __declspec(align(16)) ulong4 { 
#line 247
unsigned long x, y, z, w; 
#line 248
}; 
#endif
#line 250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 250
struct float1 { 
#line 252
float x; 
#line 253
}; 
#endif
#line 272 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 272
struct __declspec(align(8)) float2 { float x; float y; }; 
#endif
#line 277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 277
struct float3 { 
#line 279
float x, y, z; 
#line 280
}; 
#endif
#line 282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 282
struct __declspec(align(16)) float4 { 
#line 284
float x, y, z, w; 
#line 285
}; 
#endif
#line 287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 287
struct longlong1 { 
#line 289
__int64 x; 
#line 290
}; 
#endif
#line 292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 292
struct ulonglong1 { 
#line 294
unsigned __int64 x; 
#line 295
}; 
#endif
#line 297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 297
struct __declspec(align(16)) longlong2 { 
#line 299
__int64 x, y; 
#line 300
}; 
#endif
#line 302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 302
struct __declspec(align(16)) ulonglong2 { 
#line 304
unsigned __int64 x, y; 
#line 305
}; 
#endif
#line 307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 307
struct longlong3 { 
#line 309
__int64 x, y, z; 
#line 310
}; 
#endif
#line 312 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 312
struct ulonglong3 { 
#line 314
unsigned __int64 x, y, z; 
#line 315
}; 
#endif
#line 317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 317
struct __declspec(align(16)) longlong4 { 
#line 319
__int64 x, y, z, w; 
#line 320
}; 
#endif
#line 322 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 322
struct __declspec(align(16)) ulonglong4 { 
#line 324
unsigned __int64 x, y, z, w; 
#line 325
}; 
#endif
#line 327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 327
struct double1 { 
#line 329
double x; 
#line 330
}; 
#endif
#line 332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 332
struct __declspec(align(16)) double2 { 
#line 334
double x, y; 
#line 335
}; 
#endif
#line 337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 337
struct double3 { 
#line 339
double x, y, z; 
#line 340
}; 
#endif
#line 342 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 342
struct __declspec(align(16)) double4 { 
#line 344
double x, y, z, w; 
#line 345
}; 
#endif
#line 360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef char1 
#line 360
char1; 
#endif
#line 361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef uchar1 
#line 361
uchar1; 
#endif
#line 362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef char2 
#line 362
char2; 
#endif
#line 363 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef uchar2 
#line 363
uchar2; 
#endif
#line 364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef char3 
#line 364
char3; 
#endif
#line 365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef uchar3 
#line 365
uchar3; 
#endif
#line 366 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef char4 
#line 366
char4; 
#endif
#line 367 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef uchar4 
#line 367
uchar4; 
#endif
#line 368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef short1 
#line 368
short1; 
#endif
#line 369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef ushort1 
#line 369
ushort1; 
#endif
#line 370 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef short2 
#line 370
short2; 
#endif
#line 371 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef ushort2 
#line 371
ushort2; 
#endif
#line 372 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef short3 
#line 372
short3; 
#endif
#line 373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef ushort3 
#line 373
ushort3; 
#endif
#line 374 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef short4 
#line 374
short4; 
#endif
#line 375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef ushort4 
#line 375
ushort4; 
#endif
#line 376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef int1 
#line 376
int1; 
#endif
#line 377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef uint1 
#line 377
uint1; 
#endif
#line 378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef int2 
#line 378
int2; 
#endif
#line 379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef uint2 
#line 379
uint2; 
#endif
#line 380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef int3 
#line 380
int3; 
#endif
#line 381 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef uint3 
#line 381
uint3; 
#endif
#line 382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef int4 
#line 382
int4; 
#endif
#line 383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef uint4 
#line 383
uint4; 
#endif
#line 384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef long1 
#line 384
long1; 
#endif
#line 385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef ulong1 
#line 385
ulong1; 
#endif
#line 386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef long2 
#line 386
long2; 
#endif
#line 387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef ulong2 
#line 387
ulong2; 
#endif
#line 388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef long3 
#line 388
long3; 
#endif
#line 389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef ulong3 
#line 389
ulong3; 
#endif
#line 390 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef long4 
#line 390
long4; 
#endif
#line 391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef ulong4 
#line 391
ulong4; 
#endif
#line 392 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef float1 
#line 392
float1; 
#endif
#line 393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef float2 
#line 393
float2; 
#endif
#line 394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef float3 
#line 394
float3; 
#endif
#line 395 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef float4 
#line 395
float4; 
#endif
#line 396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef longlong1 
#line 396
longlong1; 
#endif
#line 397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef ulonglong1 
#line 397
ulonglong1; 
#endif
#line 398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef longlong2 
#line 398
longlong2; 
#endif
#line 399 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef ulonglong2 
#line 399
ulonglong2; 
#endif
#line 400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef longlong3 
#line 400
longlong3; 
#endif
#line 401 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef ulonglong3 
#line 401
ulonglong3; 
#endif
#line 402 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef longlong4 
#line 402
longlong4; 
#endif
#line 403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef ulonglong4 
#line 403
ulonglong4; 
#endif
#line 404 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef double1 
#line 404
double1; 
#endif
#line 405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef double2 
#line 405
double2; 
#endif
#line 406 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef double3 
#line 406
double3; 
#endif
#line 407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef double4 
#line 407
double4; 
#endif
#line 415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
#line 415
struct dim3 { 
#line 417
unsigned x, y, z; 
#line 423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
}; 
#endif
#line 425 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_types.h"
#if 0
typedef dim3 
#line 425
dim3; 
#endif
#line 86 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_device_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaDeviceGetAttribute(int * , cudaDeviceAttr , int ); } 
#line 87
extern "C" { extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * , cudaLimit ); } 
#line 88
extern "C" { extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * ); } 
#line 89
extern "C" { extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * ); } 
#line 90
extern "C" { extern cudaError_t __stdcall cudaDeviceSynchronize(); } 
#line 91
extern "C" { extern cudaError_t __stdcall cudaGetLastError(); } 
#line 92
extern "C" { extern cudaError_t __stdcall cudaPeekAtLastError(); } 
#line 93
extern "C" { extern const char *__stdcall cudaGetErrorString(cudaError_t ); } 
#line 94
extern "C" { extern cudaError_t __stdcall cudaGetDeviceCount(int * ); } 
#line 95
extern "C" { extern cudaError_t __stdcall cudaGetDevice(int * ); } 
#line 96
extern "C" { extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * , unsigned ); } 
#line 97
extern "C" { extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t ); } 
#line 98
extern "C" { extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t , cudaEvent_t , unsigned ); } 
#line 99
extern "C" { extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * , unsigned ); } 
#line 100
extern "C" { extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t , cudaStream_t ); } 
#line 101
extern "C" { extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t ); } 
#line 102
extern "C" { extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * , const void * ); } 
#line 103
extern "C" { extern cudaError_t __stdcall cudaFree(void * ); } 
#line 104
extern "C" { extern cudaError_t __stdcall cudaMalloc(void ** , size_t ); } 
#line 105
extern "C" { extern cudaError_t __stdcall cudaMemcpyAsync(void * , const void * , size_t , cudaMemcpyKind , cudaStream_t ); } 
#line 106
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DAsync(void * , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t ); } 
#line 107
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * , cudaStream_t ); } 
#line 108
extern "C" { extern cudaError_t __stdcall cudaMemsetAsync(void * , int , size_t , cudaStream_t ); } 
#line 109
extern "C" { extern cudaError_t __stdcall cudaMemset2DAsync(void * , size_t , int , size_t , size_t , cudaStream_t ); } 
#line 110
extern "C" { extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr , int , cudaExtent , cudaStream_t ); } 
#line 111
extern "C" { extern cudaError_t __stdcall cudaRuntimeGetVersion(int * ); } 
#line 113
extern "C" { extern void *__stdcall cudaGetParameterBuffer(size_t , size_t ); } 
#line 114
extern "C" { extern cudaError_t __stdcall cudaLaunchDevice(void * , void * , dim3 , dim3 , unsigned , cudaStream_t ); } 
#line 116
namespace _GLOBAL__N__14_kernel_cpp1_ii_b614c5e6 { }; using namespace _GLOBAL__N__14_kernel_cpp1_ii_b614c5e6; namespace _GLOBAL__N__14_kernel_cpp1_ii_b614c5e6 { 
#line 117
template< class T> __inline cudaError_t cudaMalloc(T ** , size_t ); 
#line 118
template< class T> __inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * , T * ); 
#line 119
}
#line 193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaDeviceReset(); } 
#line 210
extern "C" { extern cudaError_t __stdcall cudaDeviceSynchronize(); } 
#line 295
extern "C" { extern cudaError_t __stdcall cudaDeviceSetLimit(cudaLimit , size_t ); } 
#line 324
extern "C" { extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * , cudaLimit ); } 
#line 355
extern "C" { extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * ); } 
#line 390
extern "C" { extern cudaError_t __stdcall cudaDeviceGetStreamPriorityRange(int * , int * ); } 
#line 432
extern "C" { extern cudaError_t __stdcall cudaDeviceSetCacheConfig(cudaFuncCache ); } 
#line 461
extern "C" { extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * ); } 
#line 503
extern "C" { extern cudaError_t __stdcall cudaDeviceSetSharedMemConfig(cudaSharedMemConfig ); } 
#line 526
extern "C" { extern cudaError_t __stdcall cudaDeviceGetByPCIBusId(int * , char * ); } 
#line 553
extern "C" { extern cudaError_t __stdcall cudaDeviceGetPCIBusId(char * , int , int ); } 
#line 595
extern "C" { extern cudaError_t __stdcall cudaIpcGetEventHandle(cudaIpcEventHandle_t * , cudaEvent_t ); } 
#line 630
extern "C" { extern cudaError_t __stdcall cudaIpcOpenEventHandle(cudaEvent_t * , cudaIpcEventHandle_t ); } 
#line 668
extern "C" { extern cudaError_t __stdcall cudaIpcGetMemHandle(cudaIpcMemHandle_t * , void * ); } 
#line 718
extern "C" { extern cudaError_t __stdcall cudaIpcOpenMemHandle(void ** , cudaIpcMemHandle_t , unsigned ); } 
#line 748
extern "C" { extern cudaError_t __stdcall cudaIpcCloseMemHandle(void * ); } 
#line 784
extern "C" { extern cudaError_t __stdcall cudaThreadExit(); } 
#line 808
extern "C" { extern cudaError_t __stdcall cudaThreadSynchronize(); } 
#line 867
extern "C" { extern cudaError_t __stdcall cudaThreadSetLimit(cudaLimit , size_t ); } 
#line 898
extern "C" { extern cudaError_t __stdcall cudaThreadGetLimit(size_t * , cudaLimit ); } 
#line 933
extern "C" { extern cudaError_t __stdcall cudaThreadGetCacheConfig(cudaFuncCache * ); } 
#line 979
extern "C" { extern cudaError_t __stdcall cudaThreadSetCacheConfig(cudaFuncCache ); } 
#line 1029
extern "C" { extern cudaError_t __stdcall cudaGetLastError(); } 
#line 1070
extern "C" { extern cudaError_t __stdcall cudaPeekAtLastError(); } 
#line 1084
extern "C" { extern const char *__stdcall cudaGetErrorString(cudaError_t ); } 
#line 1114
extern "C" { extern cudaError_t __stdcall cudaGetDeviceCount(int * ); } 
#line 1329
extern "C" { extern cudaError_t __stdcall cudaGetDeviceProperties(cudaDeviceProp * , int ); } 
#line 1476
extern "C" { extern cudaError_t __stdcall cudaDeviceGetAttribute(int * , cudaDeviceAttr , int ); } 
#line 1495
extern "C" { extern cudaError_t __stdcall cudaChooseDevice(int * , const cudaDeviceProp * ); } 
#line 1529
extern "C" { extern cudaError_t __stdcall cudaSetDevice(int ); } 
#line 1546
extern "C" { extern cudaError_t __stdcall cudaGetDevice(int * ); } 
#line 1575
extern "C" { extern cudaError_t __stdcall cudaSetValidDevices(int * , int ); } 
#line 1635
extern "C" { extern cudaError_t __stdcall cudaSetDeviceFlags(unsigned ); } 
#line 1669
extern "C" { extern cudaError_t __stdcall cudaStreamCreate(cudaStream_t * ); } 
#line 1698
extern "C" { extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * , unsigned ); } 
#line 1741
extern "C" { extern cudaError_t __stdcall cudaStreamCreateWithPriority(cudaStream_t * , unsigned , int ); } 
#line 1765
extern "C" { extern cudaError_t __stdcall cudaStreamGetPriority(cudaStream_t , int * ); } 
#line 1786
extern "C" { extern cudaError_t __stdcall cudaStreamGetFlags(cudaStream_t , unsigned * ); } 
#line 1807
extern "C" { extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t ); } 
#line 1842
extern "C" { extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t , cudaEvent_t , unsigned ); } 
#line 1856 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_runtime_api.h"
extern "C" { typedef void (__stdcall *cudaStreamCallback_t)(cudaStream_t , cudaError_t , void * ); }
#line 1894
extern "C" { extern cudaError_t __stdcall cudaStreamAddCallback(cudaStream_t , cudaStreamCallback_t , void * , unsigned ); } 
#line 1914
extern "C" { extern cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t ); } 
#line 1932
extern "C" { extern cudaError_t __stdcall cudaStreamQuery(cudaStream_t ); } 
#line 1964
extern "C" { extern cudaError_t __stdcall cudaEventCreate(cudaEvent_t * ); } 
#line 1998
extern "C" { extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * , unsigned ); } 
#line 2031
extern "C" { extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t , cudaStream_t  = 0); } 
#line 2060
extern "C" { extern cudaError_t __stdcall cudaEventQuery(cudaEvent_t ); } 
#line 2092
extern "C" { extern cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t ); } 
#line 2117
extern "C" { extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t ); } 
#line 2158
extern "C" { extern cudaError_t __stdcall cudaEventElapsedTime(float * , cudaEvent_t , cudaEvent_t ); } 
#line 2200
extern "C" { extern cudaError_t __stdcall cudaConfigureCall(dim3 , dim3 , size_t  = 0, cudaStream_t  = 0); } 
#line 2227
extern "C" { extern cudaError_t __stdcall cudaSetupArgument(const void * , size_t , size_t ); } 
#line 2273
extern "C" { extern cudaError_t __stdcall cudaFuncSetCacheConfig(const void * , cudaFuncCache ); } 
#line 2324
extern "C" { extern cudaError_t __stdcall cudaFuncSetSharedMemConfig(const void * , cudaSharedMemConfig ); } 
#line 2359
extern "C" { extern cudaError_t __stdcall cudaLaunch(const void * ); } 
#line 2392
extern "C" { extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * , const void * ); } 
#line 2414
extern "C" { extern cudaError_t __stdcall cudaSetDoubleForDevice(double * ); } 
#line 2436
extern "C" { extern cudaError_t __stdcall cudaSetDoubleForHost(double * ); } 
#line 2471
extern "C" { extern cudaError_t __stdcall cudaMalloc(void ** , size_t ); } 
#line 2500
extern "C" { extern cudaError_t __stdcall cudaMallocHost(void ** , size_t ); } 
#line 2539
extern "C" { extern cudaError_t __stdcall cudaMallocPitch(void ** , size_t * , size_t , size_t ); } 
#line 2581
extern "C" { extern cudaError_t __stdcall cudaMallocArray(cudaArray_t * , const cudaChannelFormatDesc * , size_t , size_t  = 0, unsigned  = 0); } 
#line 2605
extern "C" { extern cudaError_t __stdcall cudaFree(void * ); } 
#line 2625
extern "C" { extern cudaError_t __stdcall cudaFreeHost(void * ); } 
#line 2647
extern "C" { extern cudaError_t __stdcall cudaFreeArray(cudaArray_t ); } 
#line 2669
extern "C" { extern cudaError_t __stdcall cudaFreeMipmappedArray(cudaMipmappedArray_t ); } 
#line 2728
extern "C" { extern cudaError_t __stdcall cudaHostAlloc(void ** , size_t , unsigned ); } 
#line 2781
extern "C" { extern cudaError_t __stdcall cudaHostRegister(void * , size_t , unsigned ); } 
#line 2800
extern "C" { extern cudaError_t __stdcall cudaHostUnregister(void * ); } 
#line 2827
extern "C" { extern cudaError_t __stdcall cudaHostGetDevicePointer(void ** , void * , unsigned ); } 
#line 2846
extern "C" { extern cudaError_t __stdcall cudaHostGetFlags(unsigned * , void * ); } 
#line 2881
extern "C" { extern cudaError_t __stdcall cudaMalloc3D(cudaPitchedPtr * , cudaExtent ); } 
#line 3016
extern "C" { extern cudaError_t __stdcall cudaMalloc3DArray(cudaArray_t * , const cudaChannelFormatDesc * , cudaExtent , unsigned  = 0); } 
#line 3137
extern "C" { extern cudaError_t __stdcall cudaMallocMipmappedArray(cudaMipmappedArray_t * , const cudaChannelFormatDesc * , cudaExtent , unsigned , unsigned  = 0); } 
#line 3163
extern "C" { extern cudaError_t __stdcall cudaGetMipmappedArrayLevel(cudaArray_t * , cudaMipmappedArray_const_t , unsigned ); } 
#line 3260
extern "C" { extern cudaError_t __stdcall cudaMemcpy3D(const cudaMemcpy3DParms * ); } 
#line 3288
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DPeer(const cudaMemcpy3DPeerParms * ); } 
#line 3392
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * , cudaStream_t  = 0); } 
#line 3414
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DPeerAsync(const cudaMemcpy3DPeerParms * , cudaStream_t  = 0); } 
#line 3433
extern "C" { extern cudaError_t __stdcall cudaMemGetInfo(size_t * , size_t * ); } 
#line 3454
extern "C" { extern cudaError_t __stdcall cudaArrayGetInfo(cudaChannelFormatDesc * , cudaExtent * , unsigned * , cudaArray_t ); } 
#line 3489
extern "C" { extern cudaError_t __stdcall cudaMemcpy(void * , const void * , size_t , cudaMemcpyKind ); } 
#line 3521
extern "C" { extern cudaError_t __stdcall cudaMemcpyPeer(void * , int , const void * , int , size_t ); } 
#line 3555
extern "C" { extern cudaError_t __stdcall cudaMemcpyToArray(cudaArray_t , size_t , size_t , const void * , size_t , cudaMemcpyKind ); } 
#line 3589
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromArray(void * , cudaArray_const_t , size_t , size_t , size_t , cudaMemcpyKind ); } 
#line 3624
extern "C" { extern cudaError_t __stdcall cudaMemcpyArrayToArray(cudaArray_t , size_t , size_t , cudaArray_const_t , size_t , size_t , size_t , cudaMemcpyKind  = cudaMemcpyDeviceToDevice); } 
#line 3666
extern "C" { extern cudaError_t __stdcall cudaMemcpy2D(void * , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind ); } 
#line 3708
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DToArray(cudaArray_t , size_t , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind ); } 
#line 3750
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DFromArray(void * , size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , cudaMemcpyKind ); } 
#line 3790
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DArrayToArray(cudaArray_t , size_t , size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , cudaMemcpyKind  = cudaMemcpyDeviceToDevice); } 
#line 3825
extern "C" { extern cudaError_t __stdcall cudaMemcpyToSymbol(const void * , const void * , size_t , size_t  = 0, cudaMemcpyKind  = cudaMemcpyHostToDevice); } 
#line 3860
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromSymbol(void * , const void * , size_t , size_t  = 0, cudaMemcpyKind  = cudaMemcpyDeviceToHost); } 
#line 3902
extern "C" { extern cudaError_t __stdcall cudaMemcpyAsync(void * , const void * , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 3933
extern "C" { extern cudaError_t __stdcall cudaMemcpyPeerAsync(void * , int , const void * , int , size_t , cudaStream_t  = 0); } 
#line 3974
extern "C" { extern cudaError_t __stdcall cudaMemcpyToArrayAsync(cudaArray_t , size_t , size_t , const void * , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4015
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromArrayAsync(void * , cudaArray_const_t , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4066
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DAsync(void * , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4116
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DToArrayAsync(cudaArray_t , size_t , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4165
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void * , size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4207
extern "C" { extern cudaError_t __stdcall cudaMemcpyToSymbolAsync(const void * , const void * , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4249
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void * , const void * , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4275
extern "C" { extern cudaError_t __stdcall cudaMemset(void * , int , size_t ); } 
#line 4305
extern "C" { extern cudaError_t __stdcall cudaMemset2D(void * , size_t , int , size_t , size_t ); } 
#line 4348
extern "C" { extern cudaError_t __stdcall cudaMemset3D(cudaPitchedPtr , int , cudaExtent ); } 
#line 4376
extern "C" { extern cudaError_t __stdcall cudaMemsetAsync(void * , int , size_t , cudaStream_t  = 0); } 
#line 4409
extern "C" { extern cudaError_t __stdcall cudaMemset2DAsync(void * , size_t , int , size_t , size_t , cudaStream_t  = 0); } 
#line 4455
extern "C" { extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr , int , cudaExtent , cudaStream_t  = 0); } 
#line 4478
extern "C" { extern cudaError_t __stdcall cudaGetSymbolAddress(void ** , const void * ); } 
#line 4500
extern "C" { extern cudaError_t __stdcall cudaGetSymbolSize(size_t * , const void * ); } 
#line 4644
extern "C" { extern cudaError_t __stdcall cudaPointerGetAttributes(cudaPointerAttributes * , const void * ); } 
#line 4678
extern "C" { extern cudaError_t __stdcall cudaDeviceCanAccessPeer(int * , int , int ); } 
#line 4715
extern "C" { extern cudaError_t __stdcall cudaDeviceEnablePeerAccess(int , unsigned ); } 
#line 4734
extern "C" { extern cudaError_t __stdcall cudaDeviceDisablePeerAccess(int ); } 
#line 4788
extern "C" { extern cudaError_t __stdcall cudaGraphicsUnregisterResource(cudaGraphicsResource_t ); } 
#line 4820
extern "C" { extern cudaError_t __stdcall cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t , unsigned ); } 
#line 4855
extern "C" { extern cudaError_t __stdcall cudaGraphicsMapResources(int , cudaGraphicsResource_t * , cudaStream_t  = 0); } 
#line 4886
extern "C" { extern cudaError_t __stdcall cudaGraphicsUnmapResources(int , cudaGraphicsResource_t * , cudaStream_t  = 0); } 
#line 4915
extern "C" { extern cudaError_t __stdcall cudaGraphicsResourceGetMappedPointer(void ** , size_t * , cudaGraphicsResource_t ); } 
#line 4949
extern "C" { extern cudaError_t __stdcall cudaGraphicsSubResourceGetMappedArray(cudaArray_t * , cudaGraphicsResource_t , unsigned , unsigned ); } 
#line 4974
extern "C" { extern cudaError_t __stdcall cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * , cudaGraphicsResource_t ); } 
#line 5010
extern "C" { extern cudaError_t __stdcall cudaGetChannelDesc(cudaChannelFormatDesc * , cudaArray_const_t ); } 
#line 5045
extern "C" { extern cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int , int , int , int , cudaChannelFormatKind ); } 
#line 5092
extern "C" { extern cudaError_t __stdcall cudaBindTexture(size_t * , const textureReference * , const void * , const cudaChannelFormatDesc * , size_t  = 4294967295U); } 
#line 5143
extern "C" { extern cudaError_t __stdcall cudaBindTexture2D(size_t * , const textureReference * , const void * , const cudaChannelFormatDesc * , size_t , size_t , size_t ); } 
#line 5171
extern "C" { extern cudaError_t __stdcall cudaBindTextureToArray(const textureReference * , cudaArray_const_t , const cudaChannelFormatDesc * ); } 
#line 5199
extern "C" { extern cudaError_t __stdcall cudaBindTextureToMipmappedArray(const textureReference * , cudaMipmappedArray_const_t , const cudaChannelFormatDesc * ); } 
#line 5220
extern "C" { extern cudaError_t __stdcall cudaUnbindTexture(const textureReference * ); } 
#line 5245
extern "C" { extern cudaError_t __stdcall cudaGetTextureAlignmentOffset(size_t * , const textureReference * ); } 
#line 5270
extern "C" { extern cudaError_t __stdcall cudaGetTextureReference(const textureReference ** , const void * ); } 
#line 5306
extern "C" { extern cudaError_t __stdcall cudaBindSurfaceToArray(const surfaceReference * , cudaArray_const_t , const cudaChannelFormatDesc * ); } 
#line 5325
extern "C" { extern cudaError_t __stdcall cudaGetSurfaceReference(const surfaceReference ** , const void * ); } 
#line 5536
extern "C" { extern cudaError_t __stdcall cudaCreateTextureObject(cudaTextureObject_t * , const cudaResourceDesc * , const cudaTextureDesc * , const cudaResourceViewDesc * ); } 
#line 5551
extern "C" { extern cudaError_t __stdcall cudaDestroyTextureObject(cudaTextureObject_t ); } 
#line 5567
extern "C" { extern cudaError_t __stdcall cudaGetTextureObjectResourceDesc(cudaResourceDesc * , cudaTextureObject_t ); } 
#line 5583
extern "C" { extern cudaError_t __stdcall cudaGetTextureObjectTextureDesc(cudaTextureDesc * , cudaTextureObject_t ); } 
#line 5600
extern "C" { extern cudaError_t __stdcall cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc * , cudaTextureObject_t ); } 
#line 5633
extern "C" { extern cudaError_t __stdcall cudaCreateSurfaceObject(cudaSurfaceObject_t * , const cudaResourceDesc * ); } 
#line 5648
extern "C" { extern cudaError_t __stdcall cudaDestroySurfaceObject(cudaSurfaceObject_t ); } 
#line 5663
extern "C" { extern cudaError_t __stdcall cudaGetSurfaceObjectResourceDesc(cudaResourceDesc * , cudaSurfaceObject_t ); } 
#line 5690
extern "C" { extern cudaError_t __stdcall cudaDriverGetVersion(int * ); } 
#line 5707
extern "C" { extern cudaError_t __stdcall cudaRuntimeGetVersion(int * ); } 
#line 5712
extern "C" { extern cudaError_t __stdcall cudaGetExportTable(const void ** , const cudaUUID_t * ); } 
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"
template< class T> __inline ::cudaChannelFormatDesc cudaCreateChannelDesc() 
#line 108
{ 
#line 109
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
#line 110
} 
#line 112
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf() 
#line 113
{ 
#line 114
int e = (((int)sizeof(unsigned short)) * 8); 
#line 116
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 117
} 
#line 119
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf1() 
#line 120
{ 
#line 121
int e = (((int)sizeof(unsigned short)) * 8); 
#line 123
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 124
} 
#line 126
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf2() 
#line 127
{ 
#line 128
int e = (((int)sizeof(unsigned short)) * 8); 
#line 130
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 131
} 
#line 133
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf4() 
#line 134
{ 
#line 135
int e = (((int)sizeof(unsigned short)) * 8); 
#line 137
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 138
} 
#line 140
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
#line 141
{ 
#line 142
int e = (((int)sizeof(char)) * 8); 
#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"
} 
#line 151
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
#line 152
{ 
#line 153
int e = (((int)sizeof(signed char)) * 8); 
#line 155
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 156
} 
#line 158
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
#line 159
{ 
#line 160
int e = (((int)sizeof(unsigned char)) * 8); 
#line 162
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 163
} 
#line 165
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
#line 166
{ 
#line 167
int e = (((int)sizeof(signed char)) * 8); 
#line 169
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 170
} 
#line 172
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
#line 173
{ 
#line 174
int e = (((int)sizeof(unsigned char)) * 8); 
#line 176
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 177
} 
#line 179
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
#line 180
{ 
#line 181
int e = (((int)sizeof(signed char)) * 8); 
#line 183
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 184
} 
#line 186
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
#line 187
{ 
#line 188
int e = (((int)sizeof(unsigned char)) * 8); 
#line 190
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 191
} 
#line 193
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
#line 194
{ 
#line 195
int e = (((int)sizeof(signed char)) * 8); 
#line 197
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 198
} 
#line 200
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
#line 201
{ 
#line 202
int e = (((int)sizeof(unsigned char)) * 8); 
#line 204
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 205
} 
#line 207
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
#line 208
{ 
#line 209
int e = (((int)sizeof(short)) * 8); 
#line 211
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 212
} 
#line 214
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
#line 215
{ 
#line 216
int e = (((int)sizeof(unsigned short)) * 8); 
#line 218
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 219
} 
#line 221
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
#line 222
{ 
#line 223
int e = (((int)sizeof(short)) * 8); 
#line 225
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 226
} 
#line 228
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
#line 229
{ 
#line 230
int e = (((int)sizeof(unsigned short)) * 8); 
#line 232
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 233
} 
#line 235
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
#line 236
{ 
#line 237
int e = (((int)sizeof(short)) * 8); 
#line 239
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 240
} 
#line 242
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
#line 243
{ 
#line 244
int e = (((int)sizeof(unsigned short)) * 8); 
#line 246
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 247
} 
#line 249
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
#line 250
{ 
#line 251
int e = (((int)sizeof(short)) * 8); 
#line 253
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 254
} 
#line 256
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
#line 257
{ 
#line 258
int e = (((int)sizeof(unsigned short)) * 8); 
#line 260
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 261
} 
#line 263
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
#line 264
{ 
#line 265
int e = (((int)sizeof(int)) * 8); 
#line 267
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 268
} 
#line 270
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
#line 271
{ 
#line 272
int e = (((int)sizeof(unsigned)) * 8); 
#line 274
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 275
} 
#line 277
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
#line 278
{ 
#line 279
int e = (((int)sizeof(int)) * 8); 
#line 281
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 282
} 
#line 284
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
#line 285
{ 
#line 286
int e = (((int)sizeof(unsigned)) * 8); 
#line 288
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 289
} 
#line 291
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
#line 292
{ 
#line 293
int e = (((int)sizeof(int)) * 8); 
#line 295
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 296
} 
#line 298
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
#line 299
{ 
#line 300
int e = (((int)sizeof(unsigned)) * 8); 
#line 302
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 303
} 
#line 305
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
#line 306
{ 
#line 307
int e = (((int)sizeof(int)) * 8); 
#line 309
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 310
} 
#line 312
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
#line 313
{ 
#line 314
int e = (((int)sizeof(unsigned)) * 8); 
#line 316
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 317
} 
#line 321
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long> () 
#line 322
{ 
#line 323
int e = (((int)sizeof(long)) * 8); 
#line 325
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 326
} 
#line 328
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned long> () 
#line 329
{ 
#line 330
int e = (((int)sizeof(unsigned long)) * 8); 
#line 332
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 333
} 
#line 335
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long1> () 
#line 336
{ 
#line 337
int e = (((int)sizeof(long)) * 8); 
#line 339
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 340
} 
#line 342
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong1> () 
#line 343
{ 
#line 344
int e = (((int)sizeof(unsigned long)) * 8); 
#line 346
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 347
} 
#line 349
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long2> () 
#line 350
{ 
#line 351
int e = (((int)sizeof(long)) * 8); 
#line 353
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 354
} 
#line 356
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong2> () 
#line 357
{ 
#line 358
int e = (((int)sizeof(unsigned long)) * 8); 
#line 360
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 361
} 
#line 363
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long4> () 
#line 364
{ 
#line 365
int e = (((int)sizeof(long)) * 8); 
#line 367
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 368
} 
#line 370
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong4> () 
#line 371
{ 
#line 372
int e = (((int)sizeof(unsigned long)) * 8); 
#line 374
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 375
} 
#line 379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\channel_descriptor.h"
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
#line 380
{ 
#line 381
int e = (((int)sizeof(float)) * 8); 
#line 383
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 384
} 
#line 386
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
#line 387
{ 
#line 388
int e = (((int)sizeof(float)) * 8); 
#line 390
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 391
} 
#line 393
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
#line 394
{ 
#line 395
int e = (((int)sizeof(float)) * 8); 
#line 397
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 398
} 
#line 400
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
#line 401
{ 
#line 402
int e = (((int)sizeof(float)) * 8); 
#line 404
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 405
} 
#line 79 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\driver_functions.h"
static __inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
#line 80
{ 
#line 81
cudaPitchedPtr s; 
#line 83
(s.ptr) = d; 
#line 84
(s.pitch) = p; 
#line 85
(s.xsize) = xsz; 
#line 86
(s.ysize) = ysz; 
#line 88
return s; 
#line 89
} 
#line 106
static __inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
#line 107
{ 
#line 108
cudaPos p; 
#line 110
(p.x) = x; 
#line 111
(p.y) = y; 
#line 112
(p.z) = z; 
#line 114
return p; 
#line 115
} 
#line 132
static __inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
#line 133
{ 
#line 134
cudaExtent e; 
#line 136
(e.width) = w; 
#line 137
(e.height) = h; 
#line 138
(e.depth) = d; 
#line 140
return e; 
#line 141
} 
#line 69 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\vector_functions.h"
static __inline char1 make_char1(signed char x) 
#line 70
{ 
#line 71
char1 t; (t.x) = x; return t; 
#line 72
} 
#line 74
static __inline uchar1 make_uchar1(unsigned char x) 
#line 75
{ 
#line 76
uchar1 t; (t.x) = x; return t; 
#line 77
} 
#line 79
static __inline char2 make_char2(signed char x, signed char y) 
#line 80
{ 
#line 81
char2 t; (t.x) = x; (t.y) = y; return t; 
#line 82
} 
#line 84
static __inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
#line 85
{ 
#line 86
uchar2 t; (t.x) = x; (t.y) = y; return t; 
#line 87
} 
#line 89
static __inline char3 make_char3(signed char x, signed char y, signed char z) 
#line 90
{ 
#line 91
char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 92
} 
#line 94
static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
#line 95
{ 
#line 96
uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 97
} 
#line 99
static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
#line 100
{ 
#line 101
char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 102
} 
#line 104
static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
#line 105
{ 
#line 106
uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 107
} 
#line 109
static __inline short1 make_short1(short x) 
#line 110
{ 
#line 111
short1 t; (t.x) = x; return t; 
#line 112
} 
#line 114
static __inline ushort1 make_ushort1(unsigned short x) 
#line 115
{ 
#line 116
ushort1 t; (t.x) = x; return t; 
#line 117
} 
#line 119
static __inline short2 make_short2(short x, short y) 
#line 120
{ 
#line 121
short2 t; (t.x) = x; (t.y) = y; return t; 
#line 122
} 
#line 124
static __inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
#line 125
{ 
#line 126
ushort2 t; (t.x) = x; (t.y) = y; return t; 
#line 127
} 
#line 129
static __inline short3 make_short3(short x, short y, short z) 
#line 130
{ 
#line 131
short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 132
} 
#line 134
static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
#line 135
{ 
#line 136
ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 137
} 
#line 139
static __inline short4 make_short4(short x, short y, short z, short w) 
#line 140
{ 
#line 141
short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 142
} 
#line 144
static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
#line 145
{ 
#line 146
ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 147
} 
#line 149
static __inline int1 make_int1(int x) 
#line 150
{ 
#line 151
int1 t; (t.x) = x; return t; 
#line 152
} 
#line 154
static __inline uint1 make_uint1(unsigned x) 
#line 155
{ 
#line 156
uint1 t; (t.x) = x; return t; 
#line 157
} 
#line 159
static __inline int2 make_int2(int x, int y) 
#line 160
{ 
#line 161
int2 t; (t.x) = x; (t.y) = y; return t; 
#line 162
} 
#line 164
static __inline uint2 make_uint2(unsigned x, unsigned y) 
#line 165
{ 
#line 166
uint2 t; (t.x) = x; (t.y) = y; return t; 
#line 167
} 
#line 169
static __inline int3 make_int3(int x, int y, int z) 
#line 170
{ 
#line 171
int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 172
} 
#line 174
static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
#line 175
{ 
#line 176
uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 177
} 
#line 179
static __inline int4 make_int4(int x, int y, int z, int w) 
#line 180
{ 
#line 181
int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 182
} 
#line 184
static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
#line 185
{ 
#line 186
uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 187
} 
#line 189
static __inline long1 make_long1(long x) 
#line 190
{ 
#line 191
long1 t; (t.x) = x; return t; 
#line 192
} 
#line 194
static __inline ulong1 make_ulong1(unsigned long x) 
#line 195
{ 
#line 196
ulong1 t; (t.x) = x; return t; 
#line 197
} 
#line 199
static __inline long2 make_long2(long x, long y) 
#line 200
{ 
#line 201
long2 t; (t.x) = x; (t.y) = y; return t; 
#line 202
} 
#line 204
static __inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
#line 205
{ 
#line 206
ulong2 t; (t.x) = x; (t.y) = y; return t; 
#line 207
} 
#line 209
static __inline long3 make_long3(long x, long y, long z) 
#line 210
{ 
#line 211
long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 212
} 
#line 214
static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
#line 215
{ 
#line 216
ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 217
} 
#line 219
static __inline long4 make_long4(long x, long y, long z, long w) 
#line 220
{ 
#line 221
long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 222
} 
#line 224
static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
#line 225
{ 
#line 226
ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 227
} 
#line 229
static __inline float1 make_float1(float x) 
#line 230
{ 
#line 231
float1 t; (t.x) = x; return t; 
#line 232
} 
#line 234
static __inline float2 make_float2(float x, float y) 
#line 235
{ 
#line 236
float2 t; (t.x) = x; (t.y) = y; return t; 
#line 237
} 
#line 239
static __inline float3 make_float3(float x, float y, float z) 
#line 240
{ 
#line 241
float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 242
} 
#line 244
static __inline float4 make_float4(float x, float y, float z, float w) 
#line 245
{ 
#line 246
float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 247
} 
#line 249
static __inline longlong1 make_longlong1(__int64 x) 
#line 250
{ 
#line 251
longlong1 t; (t.x) = x; return t; 
#line 252
} 
#line 254
static __inline ulonglong1 make_ulonglong1(unsigned __int64 x) 
#line 255
{ 
#line 256
ulonglong1 t; (t.x) = x; return t; 
#line 257
} 
#line 259
static __inline longlong2 make_longlong2(__int64 x, __int64 y) 
#line 260
{ 
#line 261
longlong2 t; (t.x) = x; (t.y) = y; return t; 
#line 262
} 
#line 264
static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y) 
#line 265
{ 
#line 266
ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
#line 267
} 
#line 269
static __inline longlong3 make_longlong3(__int64 x, __int64 y, __int64 z) 
#line 270
{ 
#line 271
longlong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 272
} 
#line 274
static __inline ulonglong3 make_ulonglong3(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z) 
#line 275
{ 
#line 276
ulonglong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 277
} 
#line 279
static __inline longlong4 make_longlong4(__int64 x, __int64 y, __int64 z, __int64 w) 
#line 280
{ 
#line 281
longlong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 282
} 
#line 284
static __inline ulonglong4 make_ulonglong4(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z, unsigned __int64 w) 
#line 285
{ 
#line 286
ulonglong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 287
} 
#line 289
static __inline double1 make_double1(double x) 
#line 290
{ 
#line 291
double1 t; (t.x) = x; return t; 
#line 292
} 
#line 294
static __inline double2 make_double2(double x, double y) 
#line 295
{ 
#line 296
double2 t; (t.x) = x; (t.y) = y; return t; 
#line 297
} 
#line 299
static __inline double3 make_double3(double x, double y, double z) 
#line 300
{ 
#line 301
double3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 302
} 
#line 304
static __inline double4 make_double4(double x, double y, double z, double w) 
#line 305
{ 
#line 306
double4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 307
} 
#line 46 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) void *__cdecl _memccpy(void * , const void * , int , size_t ); } 
#line 47
extern "C" { __declspec(dllimport) const void *__cdecl memchr(const void * , int , size_t ); } 
#line 48
extern "C" { __declspec(dllimport) int __cdecl _memicmp(const void * , const void * , size_t ); } 
#line 49
extern "C" { __declspec(dllimport) int __cdecl _memicmp_l(const void * , const void * , size_t , _locale_t ); } 
#line 50
extern "C" { int __cdecl memcmp(const void * , const void * , size_t ); } 
#line 54
extern "C" { void *__cdecl memcpy(void * , const void * , size_t ); } 
#line 56
extern "C" { __declspec(dllimport) errno_t __cdecl memcpy_s(void * , rsize_t , const void * , rsize_t ); } 
#line 93 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { void *__cdecl memset(void * , int , size_t ); } 
#line 97
extern "C" { __declspec(dllimport) void *__cdecl memccpy(void * , const void * , int , size_t ); } 
#line 98
extern "C" { __declspec(dllimport) int __cdecl memicmp(const void * , const void * , size_t ); } 
#line 103 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _strset_s(char * , size_t , int ); } 
#line 104
template < size_t _Size > inline errno_t __cdecl _strset_s ( char ( & _Dest ) [ _Size ], int _Value ) throw ( ) { return _strset_s ( _Dest, _Size, _Value ); }
#line 105
extern "C" { char *__cdecl _strset(char * , int ); } 
#line 107
extern "C" { __declspec(dllimport) errno_t __cdecl strcpy_s(char * , rsize_t , const char * ); } 
#line 109 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl strcpy_s ( char ( & _Dest ) [ _Size ], const char * _Source ) throw ( ) { return strcpy_s ( _Dest, _Size, _Source ); }
#line 110
extern "C" { char *__cdecl strcpy(char * , const char * ); } 
#line 112
extern "C" { __declspec(dllimport) errno_t __cdecl strcat_s(char * , rsize_t , const char * ); } 
#line 114 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl strcat_s ( char ( & _Dest ) [ _Size ], const char * _Source ) throw ( ) { return strcat_s ( _Dest, _Size, _Source ); }
#line 115
extern "C" { char *__cdecl strcat(char * , const char * ); } 
#line 116
extern "C" { int __cdecl strcmp(const char * , const char * ); } 
#line 117
extern "C" { size_t __cdecl strlen(const char * ); } 
#line 121
extern "C" { 
#line 118
__declspec(dllimport) size_t __cdecl 
#line 121
strnlen(const char * , size_t ); } 
#line 126
extern "C" { static __inline size_t __cdecl strnlen_s(const char *_Str, size_t _MaxCount) 
#line 127
{ 
#line 128
return (_Str == (0)) ? (0) : strnlen(_Str, _MaxCount); 
#line 129
} } 
#line 132 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl memmove_s(void * , rsize_t , const void * , rsize_t ); } 
#line 135 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) void *__cdecl memmove(void * , const void * , size_t ); } 
#line 142 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) char *__cdecl _strdup(const char * ); } 
#line 148 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) const char *__cdecl strchr(const char * , int ); } 
#line 149
extern "C" { __declspec(dllimport) int __cdecl _stricmp(const char * , const char * ); } 
#line 150
extern "C" { __declspec(dllimport) int __cdecl _strcmpi(const char * , const char * ); } 
#line 151
extern "C" { __declspec(dllimport) int __cdecl _stricmp_l(const char * , const char * , _locale_t ); } 
#line 152
extern "C" { __declspec(dllimport) int __cdecl strcoll(const char * , const char * ); } 
#line 153
extern "C" { __declspec(dllimport) int __cdecl _strcoll_l(const char * , const char * , _locale_t ); } 
#line 154
extern "C" { __declspec(dllimport) int __cdecl _stricoll(const char * , const char * ); } 
#line 155
extern "C" { __declspec(dllimport) int __cdecl _stricoll_l(const char * , const char * , _locale_t ); } 
#line 156
extern "C" { __declspec(dllimport) int __cdecl _strncoll(const char * , const char * , size_t ); } 
#line 157
extern "C" { __declspec(dllimport) int __cdecl _strncoll_l(const char * , const char * , size_t , _locale_t ); } 
#line 158
extern "C" { __declspec(dllimport) int __cdecl _strnicoll(const char * , const char * , size_t ); } 
#line 159
extern "C" { __declspec(dllimport) int __cdecl _strnicoll_l(const char * , const char * , size_t , _locale_t ); } 
#line 160
extern "C" { __declspec(dllimport) size_t __cdecl strcspn(const char * , const char * ); } 
#line 161
extern "C" { __declspec(dllimport) char *__cdecl _strerror(const char * ); } 
#line 162
extern "C" { __declspec(dllimport) errno_t __cdecl _strerror_s(char * , size_t , const char * ); } 
#line 163
template < size_t _Size > inline errno_t __cdecl _strerror_s ( char ( & _Buffer ) [ _Size ], const char * _ErrorMessage ) throw ( ) { return _strerror_s ( _Buffer, _Size, _ErrorMessage ); }
#line 164
extern "C" { __declspec(dllimport) char *__cdecl strerror(int); } 
#line 166
extern "C" { __declspec(dllimport) errno_t __cdecl strerror_s(char * , size_t , int ); } 
#line 168 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl strerror_s ( char ( & _Buffer ) [ _Size ], int _ErrorMessage ) throw ( ) { return strerror_s ( _Buffer, _Size, _ErrorMessage ); }
#line 169
extern "C" { __declspec(dllimport) errno_t __cdecl _strlwr_s(char * , size_t ); } 
#line 170
template < size_t _Size > inline errno_t __cdecl _strlwr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strlwr_s ( _String, _Size ); }
#line 171
extern "C" { __declspec(dllimport) char *__cdecl _strlwr(char * ); } 
#line 172
extern "C" { __declspec(dllimport) errno_t __cdecl _strlwr_s_l(char * , size_t , _locale_t ); } 
#line 173
template < size_t _Size > inline errno_t __cdecl _strlwr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strlwr_s_l ( _String, _Size, _Locale ); }
#line 174
extern "C" { __declspec(dllimport) char *__cdecl _strlwr_l(char * , _locale_t ); } 
#line 176
extern "C" { __declspec(dllimport) errno_t __cdecl strncat_s(char * , rsize_t , const char * , rsize_t ); } 
#line 178 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl strncat_s ( char ( & _Dest ) [ _Size ], const char * _Source, size_t _Count ) throw ( ) { return strncat_s ( _Dest, _Size, _Source, _Count ); }
#pragma warning(push)
#pragma warning(disable:6059)
#line 182
extern "C" { __declspec(dllimport) char *__cdecl strncat(char * , const char * , size_t ); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) int __cdecl strncmp(const char * , const char * , size_t ); } 
#line 185
extern "C" { __declspec(dllimport) int __cdecl _strnicmp(const char * , const char * , size_t ); } 
#line 186
extern "C" { __declspec(dllimport) int __cdecl _strnicmp_l(const char * , const char * , size_t , _locale_t ); } 
#line 188
extern "C" { __declspec(dllimport) errno_t __cdecl strncpy_s(char * , rsize_t , const char * , rsize_t ); } 
#line 190 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl strncpy_s ( char ( & _Dest ) [ _Size ], const char * _Source, size_t _Count ) throw ( ) { return strncpy_s ( _Dest, _Size, _Source, _Count ); }
#line 191
extern "C" { __declspec(dllimport) char *__cdecl strncpy(char * , const char * , size_t ); } 
#line 192
extern "C" { __declspec(dllimport) errno_t __cdecl _strnset_s(char * , size_t , int , size_t ); } 
#line 193
template < size_t _Size > inline errno_t __cdecl _strnset_s ( char ( & _Dest ) [ _Size ], int _Val, size_t _Count ) throw ( ) { return _strnset_s ( _Dest, _Size, _Val, _Count ); }
#line 194
extern "C" { __declspec(dllimport) char *__cdecl _strnset(char * , int , size_t ); } 
#line 195
extern "C" { __declspec(dllimport) const char *__cdecl strpbrk(const char * , const char * ); } 
#line 196
extern "C" { __declspec(dllimport) const char *__cdecl strrchr(const char * , int ); } 
#line 197
extern "C" { __declspec(dllimport) char *__cdecl _strrev(char * ); } 
#line 198
extern "C" { __declspec(dllimport) size_t __cdecl strspn(const char * , const char * ); } 
#line 199
extern "C" { __declspec(dllimport) const char *__cdecl strstr(const char * , const char * ); } 
#line 200
extern "C" { __declspec(dllimport) char *__cdecl strtok(char * , const char * ); } 
#line 202
extern "C" { __declspec(dllimport) char *__cdecl strtok_s(char * , const char * , char ** ); } 
#line 204 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _strupr_s(char * , size_t ); } 
#line 205
template < size_t _Size > inline errno_t __cdecl _strupr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strupr_s ( _String, _Size ); }
#line 206
extern "C" { __declspec(dllimport) char *__cdecl _strupr(char * ); } 
#line 207
extern "C" { __declspec(dllimport) errno_t __cdecl _strupr_s_l(char * , size_t , _locale_t ); } 
#line 208
template < size_t _Size > inline errno_t __cdecl _strupr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strupr_s_l ( _String, _Size, _Locale ); }
#line 209
extern "C" { __declspec(dllimport) char *__cdecl _strupr_l(char * , _locale_t ); } 
#line 210
extern "C" { __declspec(dllimport) size_t __cdecl strxfrm(char * , const char * , size_t ); } 
#line 211
extern "C" { __declspec(dllimport) size_t __cdecl _strxfrm_l(char * , const char * , size_t , _locale_t ); } 
#line 217
inline char *__cdecl strchr(char *_Str, int _Ch) 
#line 218
{ return (char *)strchr((const char *)_Str, _Ch); } 
#line 219
inline char *__cdecl strpbrk(char *_Str, const char *_Control) 
#line 220
{ return (char *)strpbrk((const char *)_Str, _Control); } 
#line 221
inline char *__cdecl strrchr(char *_Str, int _Ch) 
#line 222
{ return (char *)strrchr((const char *)_Str, _Ch); } 
#line 223
inline char *__cdecl strstr(char *_Str, const char *_SubStr) 
#line 224
{ return (char *)strstr((const char *)_Str, _SubStr); } 
#line 228 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
inline void *__cdecl memchr(void *_Pv, int _C, size_t _N) 
#line 229
{ return (void *)memchr((const void *)_Pv, _C, _N); } 
#line 241 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) char *__cdecl strdup(const char * ); } 
#line 248 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) int __cdecl strcmpi(const char * , const char * ); } 
#line 249
extern "C" { __declspec(dllimport) int __cdecl stricmp(const char * , const char * ); } 
#line 250
extern "C" { __declspec(dllimport) char *__cdecl strlwr(char * ); } 
#line 251
extern "C" { __declspec(dllimport) int __cdecl strnicmp(const char * , const char * , size_t ); } 
#line 252
extern "C" { __declspec(dllimport) char *__cdecl strnset(char * , int , size_t ); } 
#line 253
extern "C" { __declspec(dllimport) char *__cdecl strrev(char * ); } 
#line 254
extern "C" { char *__cdecl strset(char * , int ); } 
#line 255
extern "C" { __declspec(dllimport) char *__cdecl strupr(char * ); } 
#line 269 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsdup(const __wchar_t * ); } 
#line 276 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl wcscat_s(__wchar_t * , rsize_t , const __wchar_t * ); } 
#line 278 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl wcscat_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source ) throw ( ) { return wcscat_s ( _Dest, _Size, _Source ); }
#line 279
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcscat(__wchar_t * , const __wchar_t * ); } 
#line 282
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcschr(const __wchar_t * , __wchar_t ); } 
#line 283
extern "C" { __declspec(dllimport) int __cdecl wcscmp(const __wchar_t * , const __wchar_t * ); } 
#line 285
extern "C" { __declspec(dllimport) errno_t __cdecl wcscpy_s(__wchar_t * , rsize_t , const __wchar_t * ); } 
#line 287 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl wcscpy_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source ) throw ( ) { return wcscpy_s ( _Dest, _Size, _Source ); }
#line 288
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcscpy(__wchar_t * , const __wchar_t * ); } 
#line 289
extern "C" { __declspec(dllimport) size_t __cdecl wcscspn(const __wchar_t * , const __wchar_t * ); } 
#line 290
extern "C" { __declspec(dllimport) size_t __cdecl wcslen(const __wchar_t * ); } 
#line 294
extern "C" { 
#line 291
__declspec(dllimport) size_t __cdecl 
#line 294
wcsnlen(const __wchar_t * , size_t ); } 
#line 299
extern "C" { static __inline size_t __cdecl wcsnlen_s(const __wchar_t *_Src, size_t _MaxCount) 
#line 300
{ 
#line 301
return (_Src == (0)) ? (0) : wcsnlen(_Src, _MaxCount); 
#line 302
} } 
#line 305 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl wcsncat_s(__wchar_t * , rsize_t , const __wchar_t * , rsize_t ); } 
#line 307 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl wcsncat_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _Count ) throw ( ) { return wcsncat_s ( _Dest, _Size, _Source, _Count ); }
#pragma warning(push)
#pragma warning(disable:6059)
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsncat(__wchar_t * , const __wchar_t * , size_t ); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) int __cdecl wcsncmp(const __wchar_t * , const __wchar_t * , size_t ); } 
#line 314
extern "C" { __declspec(dllimport) errno_t __cdecl wcsncpy_s(__wchar_t * , rsize_t , const __wchar_t * , rsize_t ); } 
#line 316 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl wcsncpy_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _Count ) throw ( ) { return wcsncpy_s ( _Dest, _Size, _Source, _Count ); }
#line 317
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsncpy(__wchar_t * , const __wchar_t * , size_t ); } 
#line 318
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcspbrk(const __wchar_t * , const __wchar_t * ); } 
#line 319
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcsrchr(const __wchar_t * , __wchar_t ); } 
#line 320
extern "C" { __declspec(dllimport) size_t __cdecl wcsspn(const __wchar_t * , const __wchar_t * ); } 
#line 323
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcsstr(const __wchar_t * , const __wchar_t * ); } 
#line 324
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcstok(__wchar_t * , const __wchar_t * ); } 
#line 326
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcstok_s(__wchar_t * , const __wchar_t * , __wchar_t ** ); } 
#line 328 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcserror(int ); } 
#line 329
extern "C" { __declspec(dllimport) errno_t __cdecl _wcserror_s(__wchar_t * , size_t , int ); } 
#line 330
template < size_t _Size > inline errno_t __cdecl _wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], int _Error ) throw ( ) { return _wcserror_s ( _Buffer, _Size, _Error ); }
#line 331
extern "C" { __declspec(dllimport) __wchar_t *__cdecl __wcserror(const __wchar_t * ); } 
#line 332
extern "C" { __declspec(dllimport) errno_t __cdecl __wcserror_s(__wchar_t * , size_t , const __wchar_t * ); } 
#line 333
template < size_t _Size > inline errno_t __cdecl __wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], const wchar_t * _ErrorMessage ) throw ( ) { return __wcserror_s ( _Buffer, _Size, _ErrorMessage ); }
#line 335
extern "C" { __declspec(dllimport) int __cdecl _wcsicmp(const __wchar_t * , const __wchar_t * ); } 
#line 336
extern "C" { __declspec(dllimport) int __cdecl _wcsicmp_l(const __wchar_t * , const __wchar_t * , _locale_t ); } 
#line 337
extern "C" { __declspec(dllimport) int __cdecl _wcsnicmp(const __wchar_t * , const __wchar_t * , size_t ); } 
#line 338
extern "C" { __declspec(dllimport) int __cdecl _wcsnicmp_l(const __wchar_t * , const __wchar_t * , size_t , _locale_t ); } 
#line 339
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsnset_s(__wchar_t * , size_t , __wchar_t , size_t ); } 
#line 340
template < size_t _Size > inline errno_t __cdecl _wcsnset_s ( wchar_t ( & _Dst ) [ _Size ], wchar_t _Val, size_t _MaxCount ) throw ( ) { return _wcsnset_s ( _Dst, _Size, _Val, _MaxCount ); }
#line 341
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsnset(__wchar_t * , __wchar_t , size_t ); } 
#line 342
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsrev(__wchar_t * ); } 
#line 343
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsset_s(__wchar_t * , size_t , __wchar_t ); } 
#line 344
template < size_t _Size > inline errno_t __cdecl _wcsset_s ( wchar_t ( & _Str ) [ _Size ], wchar_t _Val ) throw ( ) { return _wcsset_s ( _Str, _Size, _Val ); }
#line 345
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsset(__wchar_t * , __wchar_t ); } 
#line 347
extern "C" { __declspec(dllimport) errno_t __cdecl _wcslwr_s(__wchar_t * , size_t ); } 
#line 348
template < size_t _Size > inline errno_t __cdecl _wcslwr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcslwr_s ( _String, _Size ); }
#line 349
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcslwr(__wchar_t * ); } 
#line 350
extern "C" { __declspec(dllimport) errno_t __cdecl _wcslwr_s_l(__wchar_t * , size_t , _locale_t ); } 
#line 351
template < size_t _Size > inline errno_t __cdecl _wcslwr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcslwr_s_l ( _String, _Size, _Locale ); }
#line 352
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcslwr_l(__wchar_t * , _locale_t ); } 
#line 353
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsupr_s(__wchar_t * , size_t ); } 
#line 354
template < size_t _Size > inline errno_t __cdecl _wcsupr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcsupr_s ( _String, _Size ); }
#line 355
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsupr(__wchar_t * ); } 
#line 356
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsupr_s_l(__wchar_t * , size_t , _locale_t ); } 
#line 357
template < size_t _Size > inline errno_t __cdecl _wcsupr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcsupr_s_l ( _String, _Size, _Locale ); }
#line 358
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsupr_l(__wchar_t * , _locale_t ); } 
#line 359
extern "C" { __declspec(dllimport) size_t __cdecl wcsxfrm(__wchar_t * , const __wchar_t * , size_t ); } 
#line 360
extern "C" { __declspec(dllimport) size_t __cdecl _wcsxfrm_l(__wchar_t * , const __wchar_t * , size_t , _locale_t ); } 
#line 361
extern "C" { __declspec(dllimport) int __cdecl wcscoll(const __wchar_t * , const __wchar_t * ); } 
#line 362
extern "C" { __declspec(dllimport) int __cdecl _wcscoll_l(const __wchar_t * , const __wchar_t * , _locale_t ); } 
#line 363
extern "C" { __declspec(dllimport) int __cdecl _wcsicoll(const __wchar_t * , const __wchar_t * ); } 
#line 364
extern "C" { __declspec(dllimport) int __cdecl _wcsicoll_l(const __wchar_t * , const __wchar_t * , _locale_t ); } 
#line 365
extern "C" { __declspec(dllimport) int __cdecl _wcsncoll(const __wchar_t * , const __wchar_t * , size_t ); } 
#line 366
extern "C" { __declspec(dllimport) int __cdecl _wcsncoll_l(const __wchar_t * , const __wchar_t * , size_t , _locale_t ); } 
#line 367
extern "C" { __declspec(dllimport) int __cdecl _wcsnicoll(const __wchar_t * , const __wchar_t * , size_t ); } 
#line 368
extern "C" { __declspec(dllimport) int __cdecl _wcsnicoll_l(const __wchar_t * , const __wchar_t * , size_t , _locale_t ); } 
#line 376
inline __wchar_t *__cdecl wcschr(__wchar_t *_Str, __wchar_t _Ch) 
#line 377
{ return (__wchar_t *)wcschr((const __wchar_t *)_Str, _Ch); } 
#line 378
inline __wchar_t *__cdecl wcspbrk(__wchar_t *_Str, const __wchar_t *_Control) 
#line 379
{ return (__wchar_t *)wcspbrk((const __wchar_t *)_Str, _Control); } 
#line 380
inline __wchar_t *__cdecl wcsrchr(__wchar_t *_Str, __wchar_t _Ch) 
#line 381
{ return (__wchar_t *)wcsrchr((const __wchar_t *)_Str, _Ch); } 
#line 384
inline __wchar_t *__cdecl wcsstr(__wchar_t *_Str, const __wchar_t *_SubStr) 
#line 385
{ return (__wchar_t *)wcsstr((const __wchar_t *)_Str, _SubStr); } 
#line 397 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsdup(const __wchar_t * ); } 
#line 407 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) int __cdecl wcsicmp(const __wchar_t * , const __wchar_t * ); } 
#line 408
extern "C" { __declspec(dllimport) int __cdecl wcsnicmp(const __wchar_t * , const __wchar_t * , size_t ); } 
#line 409
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsnset(__wchar_t * , __wchar_t , size_t ); } 
#line 410
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsrev(__wchar_t * ); } 
#line 411
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsset(__wchar_t * , __wchar_t ); } 
#line 412
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcslwr(__wchar_t * ); } 
#line 413
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsupr(__wchar_t * ); } 
#line 414
extern "C" { __declspec(dllimport) int __cdecl wcsicoll(const __wchar_t * , const __wchar_t * ); } 
#line 32 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
#pragma pack ( push, 8 )
#line 82 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
extern "C" { typedef long clock_t; }
#line 106 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
extern "C" { struct tm { 
#line 107
int tm_sec; 
#line 108
int tm_min; 
#line 109
int tm_hour; 
#line 110
int tm_mday; 
#line 111
int tm_mon; 
#line 112
int tm_year; 
#line 113
int tm_wday; 
#line 114
int tm_yday; 
#line 115
int tm_isdst; 
#line 116
}; }
#line 131 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
extern "C" { __declspec(dllimport) int *__cdecl __daylight(); } 
#line 135
extern "C" { __declspec(dllimport) long *__cdecl __dstbias(); } 
#line 139
extern "C" { __declspec(dllimport) long *__cdecl __timezone(); } 
#line 143
extern "C" { __declspec(dllimport) char **__cdecl __tzname(); } 
#line 146
extern "C" { __declspec(dllimport) errno_t __cdecl _get_daylight(int * ); } 
#line 147
extern "C" { __declspec(dllimport) errno_t __cdecl _get_dstbias(long * ); } 
#line 148
extern "C" { __declspec(dllimport) errno_t __cdecl _get_timezone(long * ); } 
#line 149
extern "C" { __declspec(dllimport) errno_t __cdecl _get_tzname(size_t * , char * , size_t , int ); } 
#line 153
extern "C" { __declspec(dllimport) char *__cdecl asctime(const tm * ); } 
#line 155
extern "C" { __declspec(dllimport) errno_t __cdecl asctime_s(char * , size_t , const tm * ); } 
#line 157 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
template < size_t _Size > inline errno_t __cdecl asctime_s ( char ( & _Buffer ) [ _Size ], const struct tm * _Time ) throw ( ) { return asctime_s ( _Buffer, _Size, _Time ); }
#line 159
extern "C" { __declspec(dllimport) char *__cdecl _ctime32(const __time32_t * ); } 
#line 160
extern "C" { __declspec(dllimport) errno_t __cdecl _ctime32_s(char * , size_t , const __time32_t * ); } 
#line 161
template < size_t _Size > inline errno_t __cdecl _ctime32_s ( char ( & _Buffer ) [ _Size ], const __time32_t * _Time ) throw ( ) { return _ctime32_s ( _Buffer, _Size, _Time ); }
#line 163
extern "C" { __declspec(dllimport) clock_t __cdecl clock(); } 
#line 164
extern "C" { __declspec(dllimport) double __cdecl _difftime32(__time32_t , __time32_t ); } 
#line 166
extern "C" { __declspec(dllimport) tm *__cdecl _gmtime32(const __time32_t * ); } 
#line 167
extern "C" { __declspec(dllimport) errno_t __cdecl _gmtime32_s(tm * , const __time32_t * ); } 
#line 169
extern "C" { __declspec(dllimport) tm *__cdecl _localtime32(const __time32_t * ); } 
#line 170
extern "C" { __declspec(dllimport) errno_t __cdecl _localtime32_s(tm * , const __time32_t * ); } 
#line 172
extern "C" { __declspec(dllimport) size_t __cdecl strftime(char * , size_t , const char * , const tm * ); } 
#line 173
extern "C" { __declspec(dllimport) size_t __cdecl _strftime_l(char * , size_t , const char * , const tm * , _locale_t ); } 
#line 175
extern "C" { __declspec(dllimport) errno_t __cdecl _strdate_s(char * , size_t ); } 
#line 176
template < size_t _Size > inline errno_t __cdecl _strdate_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strdate_s ( _Buffer, _Size ); }
#line 177
extern "C" { __declspec(dllimport) char *__cdecl _strdate(char * ); } 
#line 179
extern "C" { __declspec(dllimport) errno_t __cdecl _strtime_s(char * , size_t ); } 
#line 180
template < size_t _Size > inline errno_t __cdecl _strtime_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strtime_s ( _Buffer, _Size ); }
#line 181
extern "C" { __declspec(dllimport) char *__cdecl _strtime(char * ); } 
#line 183
extern "C" { __declspec(dllimport) __time32_t __cdecl _time32(__time32_t * ); } 
#line 184
extern "C" { __declspec(dllimport) __time32_t __cdecl _mktime32(tm * ); } 
#line 185
extern "C" { __declspec(dllimport) __time32_t __cdecl _mkgmtime32(tm * ); } 
#line 192
extern "C" { __declspec(dllimport) void __cdecl _tzset(); } 
#line 197 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
extern "C" { __declspec(dllimport) double __cdecl _difftime64(__time64_t , __time64_t ); } 
#line 198
extern "C" { __declspec(dllimport) char *__cdecl _ctime64(const __time64_t * ); } 
#line 199
extern "C" { __declspec(dllimport) errno_t __cdecl _ctime64_s(char * , size_t , const __time64_t * ); } 
#line 200
template < size_t _Size > inline errno_t __cdecl _ctime64_s ( char ( & _Buffer ) [ _Size ], const __time64_t * _Time ) throw ( ) { return _ctime64_s ( _Buffer, _Size, _Time ); }
#line 202
extern "C" { __declspec(dllimport) tm *__cdecl _gmtime64(const __time64_t * ); } 
#line 203
extern "C" { __declspec(dllimport) errno_t __cdecl _gmtime64_s(tm * , const __time64_t * ); } 
#line 205
extern "C" { __declspec(dllimport) tm *__cdecl _localtime64(const __time64_t * ); } 
#line 206
extern "C" { __declspec(dllimport) errno_t __cdecl _localtime64_s(tm * , const __time64_t * ); } 
#line 208
extern "C" { __declspec(dllimport) __time64_t __cdecl _mktime64(tm * ); } 
#line 209
extern "C" { __declspec(dllimport) __time64_t __cdecl _mkgmtime64(tm * ); } 
#line 210
extern "C" { __declspec(dllimport) __time64_t __cdecl _time64(__time64_t * ); } 
#line 214
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using GetLocalTime in" "stead. See online help for details.")) unsigned __cdecl _getsystime(tm * ); } 
#line 215
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetLocalTime in" "stead. See online help for details.")) unsigned __cdecl _setsystime(tm * , unsigned ); } 
#line 228 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wasctime(const tm * ); } 
#line 229
extern "C" { __declspec(dllimport) errno_t __cdecl _wasctime_s(__wchar_t * , size_t , const tm * ); } 
#line 230
template < size_t _Size > inline errno_t __cdecl _wasctime_s ( wchar_t ( & _Buffer ) [ _Size ], const struct tm * _Time ) throw ( ) { return _wasctime_s ( _Buffer, _Size, _Time ); }
#line 232
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wctime32(const __time32_t * ); } 
#line 233
extern "C" { __declspec(dllimport) errno_t __cdecl _wctime32_s(__wchar_t * , size_t , const __time32_t * ); } 
#line 234
template < size_t _Size > inline errno_t __cdecl _wctime32_s ( wchar_t ( & _Buffer ) [ _Size ], const __time32_t * _Time ) throw ( ) { return _wctime32_s ( _Buffer, _Size, _Time ); }
#line 236
extern "C" { __declspec(dllimport) size_t __cdecl wcsftime(__wchar_t * , size_t , const __wchar_t * , const tm * ); } 
#line 237
extern "C" { __declspec(dllimport) size_t __cdecl _wcsftime_l(__wchar_t * , size_t , const __wchar_t * , const tm * , _locale_t ); } 
#line 239
extern "C" { __declspec(dllimport) errno_t __cdecl _wstrdate_s(__wchar_t * , size_t ); } 
#line 240
template < size_t _Size > inline errno_t __cdecl _wstrdate_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrdate_s ( _Buffer, _Size ); }
#line 241
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wstrdate(__wchar_t * ); } 
#line 243
extern "C" { __declspec(dllimport) errno_t __cdecl _wstrtime_s(__wchar_t * , size_t ); } 
#line 244
template < size_t _Size > inline errno_t __cdecl _wstrtime_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrtime_s ( _Buffer, _Size ); }
#line 245
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wstrtime(__wchar_t * ); } 
#line 247
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wctime64(const __time64_t * ); } 
#line 248
extern "C" { __declspec(dllimport) errno_t __cdecl _wctime64_s(__wchar_t * , size_t , const __time64_t * ); } 
#line 249
template < size_t _Size > inline errno_t __cdecl _wctime64_s ( wchar_t ( & _Buffer ) [ _Size ], const __time64_t * _Time ) throw ( ) { return _wctime64_s ( _Buffer, _Size, _Time ); }
#line 27 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\wtime.inl"
#pragma warning(push)
#pragma warning(disable:4996)
#line 44
extern "C" { static __inline __wchar_t *__cdecl _wctime(const time_t *_Time) 
#line 45
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _wctime64(_Time); 
#pragma warning( pop )
} } 
#line 52
extern "C" { static __inline errno_t __cdecl _wctime_s(__wchar_t *_Buffer, size_t _SizeInWords, const time_t *_Time) 
#line 53
{ 
#line 54
return _wctime64_s(_Buffer, _SizeInWords, _Time); 
#line 55
} } 
#line 58 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\wtime.inl"
#pragma warning(pop)
#line 82 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.inl"
extern "C" { static __inline double __cdecl difftime(time_t _Time1, time_t _Time2) 
#line 83
{ 
#line 84
return _difftime64(_Time1, _Time2); 
#line 85
} } 
#line 86
extern "C" { static __inline char *__cdecl ctime(const time_t *_Time) 
#line 87
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _ctime64(_Time); 
#pragma warning( pop )
} } 
#line 94
extern "C" { static __inline errno_t __cdecl ctime_s(char *_Buffer, size_t _SizeInBytes, const time_t *_Time) 
#line 95
{ 
#line 96
return _ctime64_s(_Buffer, _SizeInBytes, _Time); 
#line 97
} } 
#line 99 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.inl"
extern "C" { static __inline tm *__cdecl gmtime(const time_t *_Time) 
#line 100
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _gmtime64(_Time); 
#pragma warning( pop )
} } 
#line 107
extern "C" { static __inline errno_t __cdecl gmtime_s(tm *_Tm, const time_t *_Time) 
#line 108
{ 
#line 109
return _gmtime64_s(_Tm, _Time); 
#line 110
} } 
#line 112 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.inl"
extern "C" { static __inline tm *__cdecl localtime(const time_t *_Time) 
#line 113
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _localtime64(_Time); 
#pragma warning( pop )
} } 
#line 119
extern "C" { static __inline errno_t __cdecl localtime_s(tm *_Tm, const time_t *_Time) 
#line 120
{ 
#line 121
return _localtime64_s(_Tm, _Time); 
#line 122
} } 
#line 123
extern "C" { static __inline time_t __cdecl mktime(tm *_Tm) 
#line 124
{ 
#line 125
return _mktime64(_Tm); 
#line 126
} } 
#line 127
extern "C" { static __inline time_t __cdecl _mkgmtime(tm *_Tm) 
#line 128
{ 
#line 129
return _mkgmtime64(_Tm); 
#line 130
} } 
#line 131
extern "C" { static __inline time_t __cdecl time(time_t *_Time) 
#line 132
{ 
#line 133
return _time64(_Time); 
#line 134
} } 
#line 274 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
extern "C" __declspec(dllimport) int daylight; 
#line 275
extern "C" __declspec(dllimport) long timezone; 
#line 276
extern "C" __declspec(dllimport) char *tzname[2]; 
#line 280 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
extern "C" { __declspec(dllimport) void __cdecl tzset(); } 
#line 290 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\time.h"
#pragma pack ( pop )
#line 69 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\common_functions.h"
extern "C" { __declspec(dllimport) extern clock_t __cdecl clock(); } 
#line 70
extern "C" { extern void *__cdecl memset(void *, int, size_t); } 
#line 71
extern "C" { extern void *__cdecl memcpy(void *, const void *, size_t); } 
#line 141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern "C" { extern int __cdecl abs(int); } 
#line 142
extern "C" { extern long __cdecl labs(long); } 
#line 143
extern "C" { extern __int64 llabs(__int64); } 
#line 186 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern "C" { extern double __cdecl fabs(double ); } 
#line 227
extern "C" { extern inline float fabsf(float ); } 
#line 228
extern "C" { extern int min(int, int); } 
#line 229
extern "C" { extern unsigned umin(unsigned, unsigned); } 
#line 230
extern "C" { extern __int64 llmin(__int64, __int64); } 
#line 231
extern "C" { extern unsigned __int64 ullmin(unsigned __int64, unsigned __int64); } 
#line 247
extern "C" { extern float fminf(float , float ); } 
#line 263
extern "C" { extern double fmin(double , double ); } 
#line 264
extern "C" { extern int max(int, int); } 
#line 265
extern "C" { extern unsigned umax(unsigned, unsigned); } 
#line 266
extern "C" { extern __int64 llmax(__int64, __int64); } 
#line 267
extern "C" { extern unsigned __int64 ullmax(unsigned __int64, unsigned __int64); } 
#line 283
extern "C" { extern float fmaxf(float , float ); } 
#line 299
extern "C" { extern double fmax(double, double); } 
#line 340
extern "C" double __cdecl sin(double ); 
#line 373
extern "C" double __cdecl cos(double ); 
#line 388
extern "C" { extern void sincos(double , double * , double * ); } 
#line 404
extern "C" { extern void sincosf(float , float * , float * ); } 
#line 445
extern "C" double __cdecl tan(double ); 
#line 514
extern "C" double __cdecl sqrt(double ); 
#line 583
extern "C" { extern double rsqrt(double ); } 
#line 652
extern "C" { extern float rsqrtf(float ); } 
#line 703
extern "C" { extern double log2(double ); } 
#line 724
extern "C" { extern double exp2(double ); } 
#line 745
extern "C" { extern float exp2f(float ); } 
#line 766
extern "C" { extern double exp10(double ); } 
#line 788
extern "C" { extern float exp10f(float ); } 
#line 829
extern "C" { extern double expm1(double ); } 
#line 870
extern "C" { extern float expm1f(float ); } 
#line 921
extern "C" { extern float log2f(float ); } 
#line 972
extern "C" double __cdecl log10(double ); 
#line 1043
extern "C" double __cdecl log(double ); 
#line 1136
extern "C" { extern double log1p(double ); } 
#line 1229
extern "C" { extern float log1pf(float ); } 
#line 1301
extern "C" __declspec(dllimport) double __cdecl floor(double ); 
#line 1340
extern "C" double __cdecl exp(double ); 
#line 1371
extern "C" double __cdecl cosh(double ); 
#line 1401
extern "C" double __cdecl sinh(double ); 
#line 1431
extern "C" double __cdecl tanh(double ); 
#line 1465
extern "C" { extern double acosh(double ); } 
#line 1499
extern "C" { extern float acoshf(float ); } 
#line 1511
extern "C" { extern double asinh(double ); } 
#line 1523
extern "C" { extern float asinhf(float ); } 
#line 1573
extern "C" { extern double atanh(double ); } 
#line 1623
extern "C" { extern float atanhf(float ); } 
#line 1679
extern "C" __declspec(dllimport) double __cdecl ldexp(double , int ); 
#line 1735
extern "C" { extern inline float ldexpf(float , int ); } 
#line 1786
extern "C" { extern double logb(double ); } 
#line 1837
extern "C" { extern float logbf(float ); } 
#line 1863
extern "C" { extern int ilogb(double ); } 
#line 1889
extern "C" { extern int ilogbf(float ); } 
#line 1961
extern "C" { extern double scalbn(double , int ); } 
#line 2033
extern "C" { extern float scalbnf(float , int ); } 
#line 2105
extern "C" { extern double scalbln(double , long ); } 
#line 2177
extern "C" { extern float scalblnf(float , long ); } 
#line 2252
extern "C" __declspec(dllimport) double __cdecl frexp(double , int * ); 
#line 2327
extern "C" { extern inline float frexpf(float , int * ); } 
#line 2340
extern "C" { extern double round(double ); } 
#line 2353
extern "C" { extern float roundf(float ); } 
#line 2367
extern "C" { extern long lround(double ); } 
#line 2381
extern "C" { extern long lroundf(float ); } 
#line 2395
extern "C" { extern __int64 llround(double ); } 
#line 2409
extern "C" { extern __int64 llroundf(float ); } 
#line 2420
extern "C" { extern double rint(double ); } 
#line 2431
extern "C" { extern float rintf(float ); } 
#line 2443
extern "C" { extern long lrint(double ); } 
#line 2455
extern "C" { extern long lrintf(float ); } 
#line 2467
extern "C" { extern __int64 llrint(double ); } 
#line 2479
extern "C" { extern __int64 llrintf(float ); } 
#line 2528
extern "C" { extern double nearbyint(double ); } 
#line 2577
extern "C" { extern float nearbyintf(float ); } 
#line 2636
extern "C" __declspec(dllimport) double __cdecl ceil(double ); 
#line 2647
extern "C" { extern double trunc(double ); } 
#line 2658
extern "C" { extern float truncf(float ); } 
#line 2680
extern "C" { extern double fdim(double , double ); } 
#line 2702
extern "C" { extern float fdimf(float , float ); } 
#line 2735
extern "C" double __cdecl atan2(double , double ); 
#line 2766
extern "C" double __cdecl atan(double ); 
#line 2789
extern "C" double __cdecl acos(double ); 
#line 2821
extern "C" double __cdecl asin(double ); 
#line 2863 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern "C" { static __inline double __cdecl hypot(double , double ); } 
#line 2906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern "C" { static __inline float __cdecl hypotf(float , float ); } 
#line 2989 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern "C" { extern double cbrt(double ); } 
#line 3071
extern "C" { extern float cbrtf(float ); } 
#line 3120
extern "C" { extern double rcbrt(double ); } 
#line 3169
extern "C" { extern float rcbrtf(float ); } 
#line 3229
extern "C" { extern double sinpi(double ); } 
#line 3289
extern "C" { extern float sinpif(float ); } 
#line 3341
extern "C" { extern double cospi(double ); } 
#line 3393
extern "C" { extern float cospif(float ); } 
#line 3423
extern "C" { extern void sincospi(double , double * , double * ); } 
#line 3453
extern "C" { extern void sincospif(float , float * , float * ); } 
#line 3761
extern "C" double __cdecl pow(double , double ); 
#line 3817
extern "C" { __declspec(dllimport) extern double __cdecl modf(double , double * ); } 
#line 3876
extern "C" double __cdecl fmod(double , double ); 
#line 3961
extern "C" { extern double remainder(double , double ); } 
#line 4047
extern "C" { extern float remainderf(float , float ); } 
#line 4097
extern "C" { extern double remquo(double , double , int * ); } 
#line 4147
extern "C" { extern float remquof(float , float , int * ); } 
#line 4185
extern "C" { __declspec(dllimport) extern double __cdecl j0(double ); } 
#line 4223
extern "C" { extern float j0f(float ); } 
#line 4280
extern "C" { __declspec(dllimport) extern double __cdecl j1(double ); } 
#line 4337
extern "C" { extern float j1f(float ); } 
#line 4376
extern "C" { __declspec(dllimport) extern double __cdecl jn(int , double ); } 
#line 4415
extern "C" { extern float jnf(int , float ); } 
#line 4463
extern "C" { __declspec(dllimport) extern double __cdecl y0(double ); } 
#line 4511
extern "C" { extern float y0f(float ); } 
#line 4559
extern "C" { __declspec(dllimport) extern double __cdecl y1(double ); } 
#line 4607
extern "C" { extern float y1f(float ); } 
#line 4656
extern "C" { __declspec(dllimport) extern double __cdecl yn(int , double ); } 
#line 4705
extern "C" { extern float ynf(int , float ); } 
#line 4783
extern "C" { extern double erf(double ); } 
#line 4861
extern "C" { extern float erff(float ); } 
#line 4918
extern "C" { extern double erfinv(double ); } 
#line 4975
extern "C" { extern float erfinvf(float ); } 
#line 5009
extern "C" { extern double erfc(double ); } 
#line 5043
extern "C" { extern float erfcf(float ); } 
#line 5167
extern "C" { extern double lgamma(double ); } 
#line 5223
extern "C" { extern double erfcinv(double ); } 
#line 5279
extern "C" { extern float erfcinvf(float ); } 
#line 5337
extern "C" { extern double normcdfinv(double ); } 
#line 5395
extern "C" { extern float normcdfinvf(float ); } 
#line 5438
extern "C" { extern double normcdf(double ); } 
#line 5481
extern "C" { extern float normcdff(float ); } 
#line 5556
extern "C" { extern double erfcx(double ); } 
#line 5631
extern "C" { extern float erfcxf(float ); } 
#line 5760
extern "C" { extern float lgammaf(float ); } 
#line 5865
extern "C" { extern double tgamma(double ); } 
#line 5970
extern "C" { extern float tgammaf(float ); } 
#line 5979
extern "C" { extern double copysign(double , double ); } 
#line 5988
extern "C" { extern float copysignf(float , float ); } 
#line 6021
extern "C" { extern double nextafter(double , double ); } 
#line 6054
extern "C" { extern float nextafterf(float , float ); } 
#line 6066
extern "C" { extern double nan(const char * ); } 
#line 6078
extern "C" { extern float nanf(const char * ); } 
#line 6079
extern "C" { extern int __isinff(float); } 
#line 6080
extern "C" { extern int __isnanf(float); } 
#line 6089 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern "C" { extern int __finite(double); } 
#line 6090
extern "C" { extern int __finitef(float); } 
#line 6091
extern "C" { extern int __signbit(double); } 
#line 6092
extern "C" { extern int __isnan(double); } 
#line 6093
extern "C" { extern int __isinf(double); } 
#line 6096 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern "C" { extern int __signbitf(float); } 
#line 6250
extern "C" { extern double fma(double , double , double ); } 
#line 6404
extern "C" { extern float fmaf(float , float , float ); } 
#line 6409
extern "C" { extern int __signbitl(long double); } 
#line 6415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern "C" { extern int __finitel(long double); } 
#line 6416
extern "C" { extern int __isinfl(long double); } 
#line 6417
extern "C" { extern int __isnanl(long double); } 
#line 6464 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern "C" { extern inline float acosf(float ); } 
#line 6504
extern "C" { extern inline float asinf(float ); } 
#line 6544
extern "C" { extern inline float atanf(float ); } 
#line 6577
extern "C" { extern inline float atan2f(float , float ); } 
#line 6601
extern "C" { extern inline float cosf(float ); } 
#line 6643
extern "C" { extern inline float sinf(float ); } 
#line 6685
extern "C" { extern inline float tanf(float ); } 
#line 6709
extern "C" { extern inline float coshf(float ); } 
#line 6750
extern "C" { extern inline float sinhf(float ); } 
#line 6780
extern "C" { extern inline float tanhf(float ); } 
#line 6831
extern "C" { extern inline float logf(float ); } 
#line 6881
extern "C" { extern inline float expf(float ); } 
#line 6932
extern "C" { extern inline float log10f(float ); } 
#line 6987
extern "C" { extern inline float modff(float , float * ); } 
#line 7295
extern "C" { extern inline float powf(float , float ); } 
#line 7364
extern "C" { extern inline float sqrtf(float ); } 
#line 7423
extern "C" { extern inline float ceilf(float ); } 
#line 7495
extern "C" { extern inline float floorf(float ); } 
#line 7554
extern "C" { extern inline float fmodf(float , float ); } 
#line 24 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
#pragma pack ( push, 8 )
#line 37 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" { struct _exception { 
#line 38
int type; 
#line 39
char *name; 
#line 40
double arg1; 
#line 41
double arg2; 
#line 42
double retval; 
#line 43
}; }
#line 54 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" { struct _complex { 
#line 55
double x, y; 
#line 56
}; }
#line 88 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" __declspec(dllimport) double _HUGE; 
#line 101 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" { int __cdecl abs(int ); } 
#line 102
extern "C" { long __cdecl labs(long ); } 
#line 103
extern "C" { __int64 __cdecl llabs(__int64 ); } 
#line 106 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" double __cdecl acos(double ); 
#line 107
extern "C" double __cdecl asin(double ); 
#line 108
extern "C" double __cdecl atan(double ); 
#line 109
extern "C" double __cdecl atan2(double , double ); 
#line 111
extern "C" { __declspec(dllimport) double __cdecl _copysign(double , double ); } 
#line 112
extern "C" { __declspec(dllimport) double __cdecl _chgsign(double ); } 
#line 115 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" double __cdecl cos(double ); 
#line 116
extern "C" double __cdecl cosh(double ); 
#line 117
extern "C" double __cdecl exp(double ); 
#line 118
extern "C" { double __cdecl fabs(double ); } 
#line 119
extern "C" double __cdecl fmod(double , double ); 
#line 120
extern "C" double __cdecl log(double ); 
#line 121
extern "C" double __cdecl log10(double ); 
#line 122
extern "C" double __cdecl pow(double , double ); 
#line 123
extern "C" double __cdecl sin(double ); 
#line 124
extern "C" double __cdecl sinh(double ); 
#line 125
extern "C" double __cdecl tan(double ); 
#line 126
extern "C" double __cdecl tanh(double ); 
#line 127
extern "C" double __cdecl sqrt(double ); 
#line 130
extern "C" { __declspec(dllimport) double __cdecl atof(const char * ); } 
#line 131
extern "C" { __declspec(dllimport) double __cdecl _atof_l(const char * , _locale_t ); } 
#line 134 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" { __declspec(dllimport) double __cdecl _cabs(_complex ); } 
#line 135
extern "C" __declspec(dllimport) double __cdecl ceil(double ); 
#line 136
extern "C" __declspec(dllimport) double __cdecl floor(double ); 
#line 137
extern "C" __declspec(dllimport) double __cdecl frexp(double , int * ); 
#line 138
extern "C" { __declspec(dllimport) double __cdecl _hypot(double , double ); } 
#line 139
extern "C" { __declspec(dllimport) float __cdecl _hypotf(float , float ); } 
#line 140
extern "C" { __declspec(dllimport) double __cdecl _j0(double ); } 
#line 141
extern "C" { __declspec(dllimport) double __cdecl _j1(double ); } 
#line 142
extern "C" { __declspec(dllimport) double __cdecl _jn(int , double ); } 
#line 143
extern "C" __declspec(dllimport) double __cdecl ldexp(double , int ); 
#line 149 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" { int __cdecl _matherr(_exception * ); } 
#line 152 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" { __declspec(dllimport) double __cdecl modf(double , double * ); } 
#line 154
extern "C" { __declspec(dllimport) double __cdecl _y0(double ); } 
#line 155
extern "C" { __declspec(dllimport) double __cdecl _y1(double ); } 
#line 156
extern "C" { __declspec(dllimport) double __cdecl _yn(int , double ); } 
#line 161
extern "C" { static __inline double __cdecl hypot(double _X, double _Y) 
#line 162
{ 
#line 163
return _hypot(_X, _Y); 
#line 164
} } 
#line 166
extern "C" { static __inline float __cdecl hypotf(float _X, float _Y) 
#line 167
{ 
#line 168
return _hypotf(_X, _Y); 
#line 169
} } 
#line 175 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" { __declspec(dllimport) int __cdecl _set_SSE2_enable(int ); } 
#line 329 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" { inline long double acosl(long double _X) 
#line 330
{ return acos((double)_X); } } 
#line 331
extern "C" { inline long double asinl(long double _X) 
#line 332
{ return asin((double)_X); } } 
#line 333
extern "C" { inline long double atanl(long double _X) 
#line 334
{ return atan((double)_X); } } 
#line 335
extern "C" { inline long double atan2l(long double _Y, long double _X) 
#line 336
{ return atan2((double)_Y, (double)_X); } } 
#line 337
extern "C" { inline long double ceill(long double _X) 
#line 338
{ return ceil((double)_X); } } 
#line 339
extern "C" { inline long double cosl(long double _X) 
#line 340
{ return cos((double)_X); } } 
#line 341
extern "C" { inline long double coshl(long double _X) 
#line 342
{ return cosh((double)_X); } } 
#line 343
extern "C" { inline long double expl(long double _X) 
#line 344
{ return exp((double)_X); } } 
#line 345
extern "C" { inline long double fabsl(long double _X) 
#line 346
{ return fabs((double)_X); } } 
#line 347
extern "C" { inline long double floorl(long double _X) 
#line 348
{ return floor((double)_X); } } 
#line 349
extern "C" { inline long double fmodl(long double _X, long double _Y) 
#line 350
{ return fmod((double)_X, (double)_Y); } } 
#line 351
extern "C" { inline long double frexpl(long double _X, int *_Y) 
#line 352
{ return frexp((double)_X, _Y); } } 
#line 353
extern "C" { inline long double ldexpl(long double _X, int _Y) 
#line 354
{ return ldexp((double)_X, _Y); } } 
#line 355
extern "C" { inline long double logl(long double _X) 
#line 356
{ return log((double)_X); } } 
#line 357
extern "C" { inline long double log10l(long double _X) 
#line 358
{ return log10((double)_X); } } 
#line 359
extern "C" { inline long double modfl(long double _X, long double *_Y) 
#line 360
{ double _Di, _Df = modf((double)_X, &_Di); 
#line 361
(*_Y) = ((long double)_Di); 
#line 362
return _Df; } } 
#line 363
extern "C" { inline long double powl(long double _X, long double _Y) 
#line 364
{ return pow((double)_X, (double)_Y); } } 
#line 365
extern "C" { inline long double sinl(long double _X) 
#line 366
{ return sin((double)_X); } } 
#line 367
extern "C" { inline long double sinhl(long double _X) 
#line 368
{ return sinh((double)_X); } } 
#line 369
extern "C" { inline long double sqrtl(long double _X) 
#line 370
{ return sqrt((double)_X); } } 
#line 371
extern "C" { inline long double tanl(long double _X) 
#line 372
{ return tan((double)_X); } } 
#line 374
extern "C" { inline long double tanhl(long double _X) 
#line 375
{ return tanh((double)_X); } } 
#line 377
extern "C" { inline long double _chgsignl(long double _Number) 
#line 378
{ 
#line 379
return _chgsign(static_cast< double>(_Number)); 
#line 380
} } 
#line 382
extern "C" { inline long double _copysignl(long double _Number, long double _Sign) 
#line 383
{ 
#line 384
return _copysign(static_cast< double>(_Number), static_cast< double>(_Sign)); 
#line 385
} } 
#line 387
extern "C" { inline float frexpf(float _X, int *_Y) 
#line 388
{ return (float)frexp((double)_X, _Y); } } 
#line 391
extern "C" { inline float fabsf(float _X) 
#line 392
{ return (float)fabs((double)_X); } } 
#line 395 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" { inline float ldexpf(float _X, int _Y) 
#line 396
{ return (float)ldexp((double)_X, _Y); } } 
#line 399
extern "C" { inline float acosf(float _X) 
#line 400
{ return (float)acos((double)_X); } } 
#line 401
extern "C" { inline float asinf(float _X) 
#line 402
{ return (float)asin((double)_X); } } 
#line 403
extern "C" { inline float atanf(float _X) 
#line 404
{ return (float)atan((double)_X); } } 
#line 405
extern "C" { inline float atan2f(float _Y, float _X) 
#line 406
{ return (float)atan2((double)_Y, (double)_X); } } 
#line 407
extern "C" { inline float ceilf(float _X) 
#line 408
{ return (float)ceil((double)_X); } } 
#line 409
extern "C" { inline float cosf(float _X) 
#line 410
{ return (float)cos((double)_X); } } 
#line 411
extern "C" { inline float coshf(float _X) 
#line 412
{ return (float)cosh((double)_X); } } 
#line 413
extern "C" { inline float expf(float _X) 
#line 414
{ return (float)exp((double)_X); } } 
#line 415
extern "C" { inline float floorf(float _X) 
#line 416
{ return (float)floor((double)_X); } } 
#line 417
extern "C" { inline float fmodf(float _X, float _Y) 
#line 418
{ return (float)fmod((double)_X, (double)_Y); } } 
#line 419
extern "C" { inline float logf(float _X) 
#line 420
{ return (float)log((double)_X); } } 
#line 421
extern "C" { inline float log10f(float _X) 
#line 422
{ return (float)log10((double)_X); } } 
#line 423
extern "C" { inline float modff(float _X, float *_Y) 
#line 424
{ double _Di, _Df = modf((double)_X, &_Di); 
#line 425
(*_Y) = ((float)_Di); 
#line 426
return (float)_Df; } } 
#line 427
extern "C" { inline float powf(float _X, float _Y) 
#line 428
{ return (float)pow((double)_X, (double)_Y); } } 
#line 429
extern "C" { inline float sinf(float _X) 
#line 430
{ return (float)sin((double)_X); } } 
#line 431
extern "C" { inline float sinhf(float _X) 
#line 432
{ return (float)sinh((double)_X); } } 
#line 433
extern "C" { inline float sqrtf(float _X) 
#line 434
{ return (float)sqrt((double)_X); } } 
#line 435
extern "C" { inline float tanf(float _X) 
#line 436
{ return (float)tan((double)_X); } } 
#line 437
extern "C" { inline float tanhf(float _X) 
#line 438
{ return (float)tanh((double)_X); } } 
#line 459 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" __declspec(dllimport) double HUGE; 
#line 464 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
extern "C" { __declspec(dllimport) double __cdecl cabs(_complex ); } 
#line 465
extern "C" { __declspec(dllimport) double __cdecl j0(double ); } 
#line 466
extern "C" { __declspec(dllimport) double __cdecl j1(double ); } 
#line 467
extern "C" { __declspec(dllimport) double __cdecl jn(int , double ); } 
#line 468
extern "C" { __declspec(dllimport) double __cdecl y0(double ); } 
#line 469
extern "C" { __declspec(dllimport) double __cdecl y1(double ); } 
#line 470
extern "C" { __declspec(dllimport) double __cdecl yn(int , double ); } 
#line 481 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
template < class _Ty > inline
        _Ty _Pow_int ( _Ty _X, int _Y )
        { unsigned int _N;
        if ( _Y >= 0 )
                _N = ( unsigned int ) _Y;
        else
                _N = ( unsigned int ) ( - _Y );
        for ( _Ty _Z = _Ty ( 1 );; _X *= _X )
                { if ( ( _N & 1 ) != 0 )
                        _Z *= _X;
                if ( ( _N >>= 1 ) == 0 )
                        return ( _Y < 0 ? _Ty ( 1 ) / _Z : _Z ); } }
#line 494
inline double __cdecl abs(double _X) 
#line 495
{ return fabs(_X); } 
#line 496
inline double __cdecl pow(double _X, int _Y) 
#line 497
{ return _Pow_int(_X, _Y); } 
#line 498
inline float __cdecl abs(float _X) 
#line 499
{ return fabsf(_X); } 
#line 500
inline float __cdecl acos(float _X) 
#line 501
{ return acosf(_X); } 
#line 502
inline float __cdecl asin(float _X) 
#line 503
{ return asinf(_X); } 
#line 504
inline float __cdecl atan(float _X) 
#line 505
{ return atanf(_X); } 
#line 506
inline float __cdecl atan2(float _Y, float _X) 
#line 507
{ return atan2f(_Y, _X); } 
#line 508
inline float __cdecl ceil(float _X) 
#line 509
{ return ceilf(_X); } 
#line 510
inline float __cdecl cos(float _X) 
#line 511
{ return cosf(_X); } 
#line 512
inline float __cdecl cosh(float _X) 
#line 513
{ return coshf(_X); } 
#line 514
inline float __cdecl exp(float _X) 
#line 515
{ return expf(_X); } 
#line 516
inline float __cdecl fabs(float _X) 
#line 517
{ return fabsf(_X); } 
#line 518
inline float __cdecl floor(float _X) 
#line 519
{ return floorf(_X); } 
#line 520
inline float __cdecl fmod(float _X, float _Y) 
#line 521
{ return fmodf(_X, _Y); } 
#line 522
inline float __cdecl frexp(float _X, int *_Y) 
#line 523
{ return frexpf(_X, _Y); } 
#line 524
inline float __cdecl ldexp(float _X, int _Y) 
#line 525
{ return ldexpf(_X, _Y); } 
#line 526
inline float __cdecl log(float _X) 
#line 527
{ return logf(_X); } 
#line 528
inline float __cdecl log10(float _X) 
#line 529
{ return log10f(_X); } 
#line 530
inline float __cdecl modf(float _X, float *_Y) 
#line 531
{ return modff(_X, _Y); } 
#line 532
inline float __cdecl pow(float _X, float _Y) 
#line 533
{ return powf(_X, _Y); } 
#line 534
inline float __cdecl pow(float _X, int _Y) 
#line 535
{ return _Pow_int(_X, _Y); } 
#line 536
inline float __cdecl sin(float _X) 
#line 537
{ return sinf(_X); } 
#line 538
inline float __cdecl sinh(float _X) 
#line 539
{ return sinhf(_X); } 
#line 540
inline float __cdecl sqrt(float _X) 
#line 541
{ return sqrtf(_X); } 
#line 542
inline float __cdecl tan(float _X) 
#line 543
{ return tanf(_X); } 
#line 544
inline float __cdecl tanh(float _X) 
#line 545
{ return tanhf(_X); } 
#line 546
inline long double __cdecl abs(long double _X) 
#line 547
{ return fabsl(_X); } 
#line 548
inline long double __cdecl acos(long double _X) 
#line 549
{ return acosl(_X); } 
#line 550
inline long double __cdecl asin(long double _X) 
#line 551
{ return asinl(_X); } 
#line 552
inline long double __cdecl atan(long double _X) 
#line 553
{ return atanl(_X); } 
#line 554
inline long double __cdecl atan2(long double _Y, long double _X) 
#line 555
{ return atan2l(_Y, _X); } 
#line 556
inline long double __cdecl ceil(long double _X) 
#line 557
{ return ceill(_X); } 
#line 558
inline long double __cdecl cos(long double _X) 
#line 559
{ return cosl(_X); } 
#line 560
inline long double __cdecl cosh(long double _X) 
#line 561
{ return coshl(_X); } 
#line 562
inline long double __cdecl exp(long double _X) 
#line 563
{ return expl(_X); } 
#line 564
inline long double __cdecl fabs(long double _X) 
#line 565
{ return fabsl(_X); } 
#line 566
inline long double __cdecl floor(long double _X) 
#line 567
{ return floorl(_X); } 
#line 568
inline long double __cdecl fmod(long double _X, long double _Y) 
#line 569
{ return fmodl(_X, _Y); } 
#line 570
inline long double __cdecl frexp(long double _X, int *_Y) 
#line 571
{ return frexpl(_X, _Y); } 
#line 572
inline long double __cdecl ldexp(long double _X, int _Y) 
#line 573
{ return ldexpl(_X, _Y); } 
#line 574
inline long double __cdecl log(long double _X) 
#line 575
{ return logl(_X); } 
#line 576
inline long double __cdecl log10(long double _X) 
#line 577
{ return log10l(_X); } 
#line 578
inline long double __cdecl modf(long double _X, long double *_Y) 
#line 579
{ return modfl(_X, _Y); } 
#line 580
inline long double __cdecl pow(long double _X, long double _Y) 
#line 581
{ return powl(_X, _Y); } 
#line 582
inline long double __cdecl pow(long double _X, int _Y) 
#line 583
{ return _Pow_int(_X, _Y); } 
#line 584
inline long double __cdecl sin(long double _X) 
#line 585
{ return sinl(_X); } 
#line 586
inline long double __cdecl sinh(long double _X) 
#line 587
{ return sinhl(_X); } 
#line 588
inline long double __cdecl sqrt(long double _X) 
#line 589
{ return sqrtl(_X); } 
#line 590
inline long double __cdecl tan(long double _X) 
#line 591
{ return tanl(_X); } 
#line 592
inline long double __cdecl tanh(long double _X) 
#line 593
{ return tanhl(_X); } 
#line 598 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
#pragma pack ( pop )
#line 28 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
#pragma pack ( push, 8 )
#line 52 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { typedef int (__cdecl *_onexit_t)(void); }
#line 78 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { typedef 
#line 75
struct _div_t { 
#line 76
int quot; 
#line 77
int rem; 
#line 78
} div_t; }
#line 83
extern "C" { typedef 
#line 80
struct _ldiv_t { 
#line 81
long quot; 
#line 82
long rem; 
#line 83
} ldiv_t; }
#line 88
extern "C" { typedef 
#line 85
struct _lldiv_t { 
#line 86
__int64 quot; 
#line 87
__int64 rem; 
#line 88
} lldiv_t; }
#line 102 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
#pragma pack ( 4 )
#line 105
extern "C" { typedef 
#line 103
struct { 
#line 104
unsigned char ld[10]; 
#line 105
} _LDOUBLE; }
#pragma pack ( )
#line 124 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { typedef 
#line 122
struct { 
#line 123
double x; 
#line 124
} _CRT_DOUBLE; }
#line 128
extern "C" { typedef 
#line 126
struct { 
#line 127
float f; 
#line 128
} _CRT_FLOAT; }
#line 139
extern "C" { typedef 
#line 134
struct { 
#line 138
long double x; 
#line 139
} _LONGDOUBLE; }
#line 143
#pragma pack ( 4 )
#line 146
extern "C" { typedef 
#line 144
struct { 
#line 145
unsigned char ld12[12]; 
#line 146
} _LDBL12; }
#pragma pack ( )
#line 163 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" __declspec(dllimport) int __mb_cur_max; 
#line 168 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl ___mb_cur_max_func(); } 
#line 169
extern "C" { __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t); } 
#line 208 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { typedef void (__cdecl *_purecall_handler)(void); }
#line 211
extern "C" { __declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(_purecall_handler ); } 
#line 212
extern "C" { __declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(); } 
#line 228 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { typedef void (__cdecl *_invalid_parameter_handler)(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); }
#line 231
extern "C" { __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler ); } 
#line 232
extern "C" { __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(); } 
#line 245 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) unsigned long *__cdecl __doserrno(); } 
#line 248
extern "C" { errno_t __cdecl _set_doserrno(unsigned long ); } 
#line 249
extern "C" { errno_t __cdecl _get_doserrno(unsigned long * ); } 
#line 252
extern "C" { __declspec(dllimport) char **__cdecl __sys_errlist(); } 
#line 255
extern "C" { __declspec(dllimport) int *__cdecl __sys_nerr(); } 
#line 261
extern "C" { __declspec(dllimport) int *__cdecl __p___argc(); } 
#line 262
extern "C" { __declspec(dllimport) char ***__cdecl __p___argv(); } 
#line 263
extern "C" { __declspec(dllimport) __wchar_t ***__cdecl __p___wargv(); } 
#line 264
extern "C" { __declspec(dllimport) char ***__cdecl __p__environ(); } 
#line 265
extern "C" { __declspec(dllimport) __wchar_t ***__cdecl __p__wenviron(); } 
#line 268 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) char **__cdecl __p__pgmptr(); } 
#line 269
extern "C" { __declspec(dllimport) __wchar_t **__cdecl __p__wpgmptr(); } 
#line 277 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" __declspec(dllimport) int __argc; 
#line 278
extern "C" __declspec(dllimport) char **__argv; 
#line 279
extern "C" __declspec(dllimport) __wchar_t **__wargv; 
#line 298 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" __declspec(dllimport) char **_environ; 
#line 299
extern "C" __declspec(dllimport) __wchar_t **_wenviron; 
#line 304 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" __declspec(dllimport) char *_pgmptr; 
#line 305
extern "C" __declspec(dllimport) __wchar_t *_wpgmptr; 
#line 328 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { errno_t __cdecl _get_pgmptr(char ** ); } 
#line 329
extern "C" { errno_t __cdecl _get_wpgmptr(__wchar_t ** ); } 
#line 333
extern "C" __declspec(dllimport) int _fmode; 
#line 339 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _set_fmode(int ); } 
#line 340
extern "C" { __declspec(dllimport) errno_t __cdecl _get_fmode(int * ); } 
#line 349 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
template< class _CountofType, size_t _SizeOfArray> char (*__countof_helper(_CountofType (& )[_SizeOfArray]))[_SizeOfArray]; 
#line 360 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl exit(int ); } 
#line 361
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(int ); } 
#line 362
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl abort(); } 
#line 365 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) unsigned __cdecl _set_abort_behavior(unsigned , unsigned ); } 
#line 374
extern "C" { __int64 __cdecl _abs64(__int64); } 
#line 412 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { int __cdecl atexit(void (__cdecl *)(void)); } 
#line 419 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl atoi(const char * ); } 
#line 420
extern "C" { __declspec(dllimport) int __cdecl _atoi_l(const char * , _locale_t ); } 
#line 421
extern "C" { __declspec(dllimport) long __cdecl atol(const char * ); } 
#line 422
extern "C" { __declspec(dllimport) long __cdecl _atol_l(const char * , _locale_t ); } 
#line 426
extern "C" { __declspec(dllimport) void *__cdecl bsearch_s(const void * , const void * , rsize_t , rsize_t , int (__cdecl * )(void *, const void *, const void *), void * ); } 
#line 430 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) void *__cdecl bsearch(const void * , const void * , size_t , size_t , int (__cdecl * )(const void *, const void *)); } 
#line 435
extern "C" { __declspec(dllimport) void __cdecl qsort_s(void * , rsize_t , rsize_t , int (__cdecl * )(void *, const void *, const void *), void * ); } 
#line 439 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) void __cdecl qsort(void * , size_t , size_t , int (__cdecl * )(const void *, const void *)); } 
#line 443 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { unsigned short __cdecl _byteswap_ushort(unsigned short ); } 
#line 444
extern "C" { unsigned long __cdecl _byteswap_ulong(unsigned long ); } 
#line 445
extern "C" { unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 ); } 
#line 446
extern "C" { __declspec(dllimport) div_t __cdecl div(int , int ); } 
#line 449
extern "C" { __declspec(dllimport) char *__cdecl getenv(const char * ); } 
#line 451
extern "C" { __declspec(dllimport) errno_t __cdecl getenv_s(size_t * , char * , rsize_t , const char * ); } 
#line 453 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
template < size_t _Size > inline errno_t __cdecl getenv_s ( size_t * _ReturnSize, char ( & _Dest ) [ _Size ], const char * _VarName ) throw ( ) { return getenv_s ( _ReturnSize, _Dest, _Size, _VarName ); }
#line 459 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _dupenv_s(char ** , size_t * , const char * ); } 
#line 466 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _itoa_s(int , char * , size_t , int ); } 
#line 467
template < size_t _Size > inline errno_t __cdecl _itoa_s ( int _Value, char ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _itoa_s ( _Value, _Dest, _Size, _Radix ); }
#line 468
extern "C" { __declspec(dllimport) char *__cdecl _itoa(int , char * , int ); } 
#line 469
extern "C" { __declspec(dllimport) errno_t __cdecl _i64toa_s(__int64 , char * , size_t , int ); } 
#line 470
extern "C" { __declspec(dllimport) char *__cdecl _i64toa(__int64 , char * , int ); } 
#line 471
extern "C" { __declspec(dllimport) errno_t __cdecl _ui64toa_s(unsigned __int64 , char * , size_t , int ); } 
#line 472
extern "C" { __declspec(dllimport) char *__cdecl _ui64toa(unsigned __int64 , char * , int ); } 
#line 473
extern "C" { __declspec(dllimport) __int64 __cdecl _atoi64(const char * ); } 
#line 474
extern "C" { __declspec(dllimport) __int64 __cdecl _atoi64_l(const char * , _locale_t ); } 
#line 475
extern "C" { __declspec(dllimport) __int64 __cdecl _strtoi64(const char * , char ** , int ); } 
#line 476
extern "C" { __declspec(dllimport) __int64 __cdecl _strtoi64_l(const char * , char ** , int , _locale_t ); } 
#line 477
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _strtoui64(const char * , char ** , int ); } 
#line 478
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(const char * , char ** , int , _locale_t ); } 
#line 479
extern "C" { __declspec(dllimport) ldiv_t __cdecl ldiv(long , long ); } 
#line 480
extern "C" { __declspec(dllimport) lldiv_t __cdecl lldiv(__int64 , __int64 ); } 
#line 484
inline long abs(long _X) 
#line 485
{ 
#line 486
return labs(_X); 
#line 487
} 
#line 488
inline __int64 abs(__int64 _X) 
#line 489
{ 
#line 490
return llabs(_X); 
#line 491
} 
#line 492
inline ldiv_t div(long _A1, long _A2) 
#line 493
{ 
#line 494
return ldiv(_A1, _A2); 
#line 495
} 
#line 496
inline lldiv_t div(__int64 _A1, __int64 _A2) 
#line 497
{ 
#line 498
return lldiv(_A1, _A2); 
#line 499
} 
#line 502 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _ltoa_s(long , char * , size_t , int ); } 
#line 503
template < size_t _Size > inline errno_t __cdecl _ltoa_s ( long _Value, char ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ltoa_s ( _Value, _Dest, _Size, _Radix ); }
#line 504
extern "C" { __declspec(dllimport) char *__cdecl _ltoa(long , char * , int ); } 
#line 505
extern "C" { __declspec(dllimport) int __cdecl mblen(const char * , size_t ); } 
#line 506
extern "C" { __declspec(dllimport) int __cdecl _mblen_l(const char * , size_t , _locale_t ); } 
#line 507
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrlen(const char * ); } 
#line 508
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrlen_l(const char * , _locale_t ); } 
#line 509
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrnlen(const char * , size_t ); } 
#line 510
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrnlen_l(const char * , size_t , _locale_t ); } 
#line 511
extern "C" { __declspec(dllimport) int __cdecl mbtowc(__wchar_t * , const char * , size_t ); } 
#line 512
extern "C" { __declspec(dllimport) int __cdecl _mbtowc_l(__wchar_t * , const char * , size_t , _locale_t ); } 
#line 513
extern "C" { __declspec(dllimport) errno_t __cdecl mbstowcs_s(size_t * , __wchar_t * , size_t , const char * , size_t ); } 
#line 514
template < size_t _Size > inline errno_t __cdecl mbstowcs_s ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], const char * _Source, size_t _MaxCount ) throw ( ) { return mbstowcs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }
#line 515
extern "C" { __declspec(dllimport) size_t __cdecl mbstowcs(__wchar_t * , const char * , size_t ); } 
#line 517
extern "C" { __declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(size_t * , __wchar_t * , size_t , const char * , size_t , _locale_t ); } 
#line 518
template < size_t _Size > inline errno_t __cdecl _mbstowcs_s_l ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], const char * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _mbstowcs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }
#line 519
extern "C" { __declspec(dllimport) size_t __cdecl _mbstowcs_l(__wchar_t * , const char * , size_t , _locale_t ); } 
#line 521
extern "C" { __declspec(dllimport) int __cdecl rand(); } 
#line 526 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl _set_error_mode(int ); } 
#line 528
extern "C" { __declspec(dllimport) void __cdecl srand(unsigned ); } 
#line 529
extern "C" { __declspec(dllimport) double __cdecl strtod(const char * , char ** ); } 
#line 530
extern "C" { __declspec(dllimport) double __cdecl _strtod_l(const char * , char ** , _locale_t ); } 
#line 531
extern "C" { __declspec(dllimport) long __cdecl strtol(const char * , char ** , int ); } 
#line 532
extern "C" { __declspec(dllimport) long __cdecl _strtol_l(const char * , char ** , int , _locale_t ); } 
#line 533
extern "C" { __declspec(dllimport) unsigned long __cdecl strtoul(const char * , char ** , int ); } 
#line 534
extern "C" { __declspec(dllimport) unsigned long __cdecl _strtoul_l(const char * , char ** , int , _locale_t ); } 
#line 539
extern "C" { __declspec(dllimport) int __cdecl system(const char * ); } 
#line 543 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _ultoa_s(unsigned long , char * , size_t , int ); } 
#line 544
template < size_t _Size > inline errno_t __cdecl _ultoa_s ( unsigned long _Value, char ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ultoa_s ( _Value, _Dest, _Size, _Radix ); }
#line 545
extern "C" { __declspec(dllimport) char *__cdecl _ultoa(unsigned long , char * , int ); } 
#line 546
extern "C" { __declspec(dllimport) int __cdecl wctomb(char * , __wchar_t ); } 
#line 547
extern "C" { __declspec(dllimport) int __cdecl _wctomb_l(char * , __wchar_t , _locale_t ); } 
#line 549
extern "C" { __declspec(dllimport) errno_t __cdecl wctomb_s(int * , char * , rsize_t , __wchar_t ); } 
#line 551 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _wctomb_s_l(int * , char * , size_t , __wchar_t , _locale_t ); } 
#line 552
extern "C" { __declspec(dllimport) errno_t __cdecl wcstombs_s(size_t * , char * , size_t , const __wchar_t * , size_t ); } 
#line 553
template < size_t _Size > inline errno_t __cdecl wcstombs_s ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _MaxCount ) throw ( ) { return wcstombs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }
#line 554
extern "C" { __declspec(dllimport) size_t __cdecl wcstombs(char * , const __wchar_t * , size_t ); } 
#line 555
extern "C" { __declspec(dllimport) errno_t __cdecl _wcstombs_s_l(size_t * , char * , size_t , const __wchar_t * , size_t , _locale_t ); } 
#line 556
template < size_t _Size > inline errno_t __cdecl _wcstombs_s_l ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _wcstombs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }
#line 557
extern "C" { __declspec(dllimport) size_t __cdecl _wcstombs_l(char * , const __wchar_t * , size_t , _locale_t ); } 
#line 619 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl calloc(size_t , size_t ); } 
#line 620
extern "C" { __declspec(dllimport) __declspec(noalias) void __cdecl free(void * ); } 
#line 621
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl malloc(size_t ); } 
#line 623
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl realloc(void * , size_t ); } 
#line 625
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _recalloc(void * , size_t , size_t ); } 
#line 626
extern "C" { __declspec(dllimport) __declspec(noalias) void __cdecl _aligned_free(void * ); } 
#line 627
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_malloc(size_t , size_t ); } 
#line 628
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_offset_malloc(size_t , size_t , size_t ); } 
#line 630
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_realloc(void * , size_t , size_t ); } 
#line 632
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_recalloc(void * , size_t , size_t , size_t ); } 
#line 634
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_offset_realloc(void * , size_t , size_t , size_t ); } 
#line 636
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_offset_recalloc(void * , size_t , size_t , size_t , size_t ); } 
#line 637
extern "C" { __declspec(dllimport) size_t __cdecl _aligned_msize(void * , size_t , size_t ); } 
#line 664 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _itow_s(int , __wchar_t * , size_t , int ); } 
#line 665
template < size_t _Size > inline errno_t __cdecl _itow_s ( int _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _itow_s ( _Value, _Dest, _Size, _Radix ); }
#line 666
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _itow(int , __wchar_t * , int ); } 
#line 667
extern "C" { __declspec(dllimport) errno_t __cdecl _ltow_s(long , __wchar_t * , size_t , int ); } 
#line 668
template < size_t _Size > inline errno_t __cdecl _ltow_s ( long _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ltow_s ( _Value, _Dest, _Size, _Radix ); }
#line 669
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _ltow(long , __wchar_t * , int ); } 
#line 670
extern "C" { __declspec(dllimport) errno_t __cdecl _ultow_s(unsigned long , __wchar_t * , size_t , int ); } 
#line 671
template < size_t _Size > inline errno_t __cdecl _ultow_s ( unsigned long _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ultow_s ( _Value, _Dest, _Size, _Radix ); }
#line 672
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _ultow(unsigned long , __wchar_t * , int ); } 
#line 673
extern "C" { __declspec(dllimport) double __cdecl wcstod(const __wchar_t * , __wchar_t ** ); } 
#line 674
extern "C" { __declspec(dllimport) double __cdecl _wcstod_l(const __wchar_t * , __wchar_t ** , _locale_t ); } 
#line 675
extern "C" { __declspec(dllimport) long __cdecl wcstol(const __wchar_t * , __wchar_t ** , int ); } 
#line 676
extern "C" { __declspec(dllimport) long __cdecl _wcstol_l(const __wchar_t * , __wchar_t ** , int , _locale_t ); } 
#line 677
extern "C" { __declspec(dllimport) unsigned long __cdecl wcstoul(const __wchar_t * , __wchar_t ** , int ); } 
#line 678
extern "C" { __declspec(dllimport) unsigned long __cdecl _wcstoul_l(const __wchar_t * , __wchar_t ** , int , _locale_t ); } 
#line 682
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wgetenv(const __wchar_t * ); } 
#line 683
extern "C" { __declspec(dllimport) errno_t __cdecl _wgetenv_s(size_t * , __wchar_t * , size_t , const __wchar_t * ); } 
#line 684
template < size_t _Size > inline errno_t __cdecl _wgetenv_s ( size_t * _ReturnSize, wchar_t ( & _Dest ) [ _Size ], const wchar_t * _VarName ) throw ( ) { return _wgetenv_s ( _ReturnSize, _Dest, _Size, _VarName ); }
#line 691 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _wdupenv_s(__wchar_t ** , size_t * , const __wchar_t * ); } 
#line 699 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl _wsystem(const __wchar_t * ); } 
#line 704 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) double __cdecl _wtof(const __wchar_t * ); } 
#line 705
extern "C" { __declspec(dllimport) double __cdecl _wtof_l(const __wchar_t * , _locale_t ); } 
#line 706
extern "C" { __declspec(dllimport) int __cdecl _wtoi(const __wchar_t * ); } 
#line 707
extern "C" { __declspec(dllimport) int __cdecl _wtoi_l(const __wchar_t * , _locale_t ); } 
#line 708
extern "C" { __declspec(dllimport) long __cdecl _wtol(const __wchar_t * ); } 
#line 709
extern "C" { __declspec(dllimport) long __cdecl _wtol_l(const __wchar_t * , _locale_t ); } 
#line 711
extern "C" { __declspec(dllimport) errno_t __cdecl _i64tow_s(__int64 , __wchar_t * , size_t , int ); } 
#line 712
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _i64tow(__int64 , __wchar_t * , int ); } 
#line 713
extern "C" { __declspec(dllimport) errno_t __cdecl _ui64tow_s(unsigned __int64 , __wchar_t * , size_t , int ); } 
#line 714
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _ui64tow(unsigned __int64 , __wchar_t * , int ); } 
#line 715
extern "C" { __declspec(dllimport) __int64 __cdecl _wtoi64(const __wchar_t * ); } 
#line 716
extern "C" { __declspec(dllimport) __int64 __cdecl _wtoi64_l(const __wchar_t * , _locale_t ); } 
#line 717
extern "C" { __declspec(dllimport) __int64 __cdecl _wcstoi64(const __wchar_t * , __wchar_t ** , int ); } 
#line 718
extern "C" { __declspec(dllimport) __int64 __cdecl _wcstoi64_l(const __wchar_t * , __wchar_t ** , int , _locale_t ); } 
#line 719
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(const __wchar_t * , __wchar_t ** , int ); } 
#line 720
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(const __wchar_t * , __wchar_t ** , int , _locale_t ); } 
#line 740 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) char *__cdecl _fullpath(char * , const char * , size_t ); } 
#line 748 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _ecvt_s(char * , size_t , double , int , int * , int * ); } 
#line 749
template < size_t _Size > inline errno_t __cdecl _ecvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits, int * _PtDec, int * _PtSign ) throw ( ) { return _ecvt_s ( _Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign ); }
#line 750
extern "C" { __declspec(dllimport) char *__cdecl _ecvt(double , int , int * , int * ); } 
#line 751
extern "C" { __declspec(dllimport) errno_t __cdecl _fcvt_s(char * , size_t , double , int , int * , int * ); } 
#line 752
template < size_t _Size > inline errno_t __cdecl _fcvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits, int * _PtDec, int * _PtSign ) throw ( ) { return _fcvt_s ( _Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign ); }
#line 753
extern "C" { __declspec(dllimport) char *__cdecl _fcvt(double , int , int * , int * ); } 
#line 754
extern "C" { __declspec(dllimport) errno_t __cdecl _gcvt_s(char * , size_t , double , int ); } 
#line 755
template < size_t _Size > inline errno_t __cdecl _gcvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits ) throw ( ) { return _gcvt_s ( _Dest, _Size, _Value, _NumOfDigits ); }
#line 756
extern "C" { __declspec(dllimport) char *__cdecl _gcvt(double , int , char * ); } 
#line 758
extern "C" { __declspec(dllimport) int __cdecl _atodbl(_CRT_DOUBLE * , char * ); } 
#line 759
extern "C" { __declspec(dllimport) int __cdecl _atoldbl(_LDOUBLE * , char * ); } 
#line 760
extern "C" { __declspec(dllimport) int __cdecl _atoflt(_CRT_FLOAT * , char * ); } 
#line 761
extern "C" { __declspec(dllimport) int __cdecl _atodbl_l(_CRT_DOUBLE * , char * , _locale_t ); } 
#line 762
extern "C" { __declspec(dllimport) int __cdecl _atoldbl_l(_LDOUBLE * , char * , _locale_t ); } 
#line 763
extern "C" { __declspec(dllimport) int __cdecl _atoflt_l(_CRT_FLOAT * , char * , _locale_t ); } 
#line 764
extern "C" { unsigned long __cdecl _lrotl(unsigned long , int ); } 
#line 765
extern "C" { unsigned long __cdecl _lrotr(unsigned long , int ); } 
#line 766
extern "C" { __declspec(dllimport) errno_t __cdecl _makepath_s(char * , size_t , const char * , const char * , const char * , const char * ); } 
#line 768
template < size_t _Size > inline errno_t __cdecl _makepath_s ( char ( & _Path ) [ _Size ], const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext ) throw ( ) { return _makepath_s ( _Path, _Size, _Drive, _Dir, _Filename, _Ext ); }
#line 769
extern "C" { __declspec(dllimport) void __cdecl _makepath(char * , const char * , const char * , const char * , const char * ); } 
#line 796 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { _onexit_t __cdecl _onexit(_onexit_t ); } 
#line 801 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) void __cdecl perror(const char * ); } 
#line 804 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
#pragma warning (push)
#pragma warning (disable:6540)
#line 808
extern "C" { __declspec(dllimport) int __cdecl _putenv(const char * ); } 
#line 809
extern "C" { __declspec(dllimport) errno_t __cdecl _putenv_s(const char * , const char * ); } 
#line 812 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { unsigned __cdecl _rotl(unsigned , int ); } 
#line 813
extern "C" { unsigned __int64 __cdecl _rotl64(unsigned __int64 , int ); } 
#line 814
extern "C" { unsigned __cdecl _rotr(unsigned , int ); } 
#line 815
extern "C" { unsigned __int64 __cdecl _rotr64(unsigned __int64 , int ); } 
#pragma warning (pop)
#line 819
extern "C" { __declspec(dllimport) errno_t __cdecl _searchenv_s(const char * , const char * , char * , size_t ); } 
#line 820
template < size_t _Size > inline errno_t __cdecl _searchenv_s ( const char * _Filename, const char * _EnvVar, char ( & _ResultPath ) [ _Size ] ) throw ( ) { return _searchenv_s ( _Filename, _EnvVar, _ResultPath, _Size ); }
#line 821
extern "C" { __declspec(dllimport) void __cdecl _searchenv(const char * , const char * , char * ); } 
#line 824 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) void __cdecl _splitpath(const char * , char * , char * , char * , char * ); } 
#line 825
extern "C" { __declspec(dllimport) errno_t __cdecl _splitpath_s(const char * , char * , size_t , char * , size_t , char * , size_t , char * , size_t ); } 
#line 830
template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _splitpath_s ( const char * _Dest, char ( & _Drive ) [ _DriveSize ], char ( & _Dir ) [ _DirSize ], char ( & _Name ) [ _NameSize ], char ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _splitpath_s ( _Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }
#line 832
extern "C" { __declspec(dllimport) void __cdecl _swab(char * , char * , int ); } 
#line 843 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wfullpath(__wchar_t * , const __wchar_t * , size_t ); } 
#line 849 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _wmakepath_s(__wchar_t * , size_t , const __wchar_t * , const __wchar_t * , const __wchar_t * , const __wchar_t * ); } 
#line 851
template < size_t _Size > inline errno_t __cdecl _wmakepath_s ( wchar_t ( & _ResultPath ) [ _Size ], const wchar_t * _Drive, const wchar_t * _Dir, const wchar_t * _Filename, const wchar_t * _Ext ) throw ( ) { return _wmakepath_s ( _ResultPath, _Size, _Drive, _Dir, _Filename, _Ext ); }
#line 852
extern "C" { __declspec(dllimport) void __cdecl _wmakepath(__wchar_t * , const __wchar_t * , const __wchar_t * , const __wchar_t * , const __wchar_t * ); } 
#line 855
extern "C" { __declspec(dllimport) void __cdecl _wperror(const __wchar_t * ); } 
#line 859 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl _wputenv(const __wchar_t * ); } 
#line 860
extern "C" { __declspec(dllimport) errno_t __cdecl _wputenv_s(const __wchar_t * , const __wchar_t * ); } 
#line 861
extern "C" { __declspec(dllimport) errno_t __cdecl _wsearchenv_s(const __wchar_t * , const __wchar_t * , __wchar_t * , size_t ); } 
#line 862
template < size_t _Size > inline errno_t __cdecl _wsearchenv_s ( const wchar_t * _Filename, const wchar_t * _EnvVar, wchar_t ( & _ResultPath ) [ _Size ] ) throw ( ) { return _wsearchenv_s ( _Filename, _EnvVar, _ResultPath, _Size ); }
#line 863
extern "C" { __declspec(dllimport) void __cdecl _wsearchenv(const __wchar_t * , const __wchar_t * , __wchar_t * ); } 
#line 866 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) void __cdecl _wsplitpath(const __wchar_t * , __wchar_t * , __wchar_t * , __wchar_t * , __wchar_t * ); } 
#line 867
extern "C" { __declspec(dllimport) errno_t __cdecl _wsplitpath_s(const __wchar_t * , __wchar_t * , size_t , __wchar_t * , size_t , __wchar_t * , size_t , __wchar_t * , size_t ); } 
#line 872
template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _wsplitpath_s ( const wchar_t * _Path, wchar_t ( & _Drive ) [ _DriveSize ], wchar_t ( & _Dir ) [ _DirSize ], wchar_t ( & _Name ) [ _NameSize ], wchar_t ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _wsplitpath_s ( _Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }
#line 879 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode in" "stead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode(int ); } 
#line 880
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. S" "ee online help for details.")) __declspec(dllimport) void __cdecl _beep(unsigned , unsigned ); } 
#line 881
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. " "See online help for details.")) __declspec(dllimport) void __cdecl _sleep(unsigned long ); } 
#line 904 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 4141)
extern "C" { __declspec(dllimport) char *__cdecl ecvt(double , int , int * , int * ); } 
#line 907
extern "C" { __declspec(dllimport) char *__cdecl fcvt(double , int , int * , int * ); } 
#line 908
extern "C" { __declspec(dllimport) char *__cdecl gcvt(double , int , char * ); } 
#line 909
extern "C" { __declspec(dllimport) char *__cdecl itoa(int , char * , int ); } 
#line 910
extern "C" { __declspec(dllimport) char *__cdecl ltoa(long , char * , int ); } 
#line 913
extern "C" { __declspec(dllimport) int __cdecl putenv(const char * ); } 
#line 916 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) void __cdecl swab(char * , char * , int ); } 
#line 917
extern "C" { __declspec(dllimport) char *__cdecl ultoa(unsigned long , char * , int ); } 
#pragma warning(pop)
extern "C" { _onexit_t __cdecl onexit(_onexit_t ); } 
#line 185 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#pragma detect_mismatch("_MSC_VER", "1700")
#line 189 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
#line 200 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
#line 27 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"
#pragma comment(lib, "msvcprtd")
#line 930 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
#pragma pack ( pop )
#line 10 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#pragma pack ( push, 8 )
#line 491 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
namespace std { 
#line 492
typedef bool _Bool; 
#line 493
}
#line 509 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
typedef __int64 _Longlong; 
#line 510
typedef unsigned __int64 _ULonglong; 
#line 528 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
typedef unsigned short char16_t; 
#line 529
typedef unsigned char32_t; 
#line 542 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
namespace std { 
#line 543
enum _Uninitialized { 
#line 545
_Noinit
#line 546
}; 
#line 550
#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit { 
#line 575 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
public: __thiscall _Lockit(); 
#line 576
explicit __thiscall _Lockit(int); 
#line 577
__thiscall ~_Lockit() throw(); 
#line 580 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
static void __cdecl _Lockit_ctor(int); 
#line 581
static void __cdecl _Lockit_dtor(int); 
#line 584
private: static void __cdecl _Lockit_ctor(_Lockit *); 
#line 585
static void __cdecl _Lockit_ctor(_Lockit *, int); 
#line 586
static void __cdecl _Lockit_dtor(_Lockit *); 
#line 588
_Lockit(const _Lockit &); 
#line 589
_Lockit &operator=(const _Lockit &); 
#line 591
int _Locktype; 
#line 606 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
}; 
#line 693 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
class __declspec(dllimport) _Init_locks { 
#line 709 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
public: __thiscall _Init_locks(); 
#line 710
__thiscall ~_Init_locks() throw(); 
#line 714 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
private: static void __cdecl _Init_locks_ctor(_Init_locks *); 
#line 715
static void __cdecl _Init_locks_dtor(_Init_locks *); 
#line 726 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
}; 
#line 728
#pragma warning(pop)
}
#line 738 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void)); 
#line 740
typedef int _Mbstatet; 
#line 741
typedef unsigned long _Uint32t; 
#line 9 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"
#pragma warning(push,3)
#line 750 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#pragma pack ( pop )
#line 8 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 15
template< class _T1, class 
#line 16
_Ret> struct unary_function; 
#line 20
template< class _T1, class 
#line 21
_T2, class 
#line 22
_Ret> struct binary_function; 
#line 26
struct _Nil { 
#line 28
}; 
#line 29
static _Nil _Nil_obj; 
#line 32
template < class _Ty,
 _Ty _Val >
 struct integral_constant
 {
 static const _Ty value = _Val;

 typedef _Ty value_type;
 typedef integral_constant < _Ty, _Val > type;

 operator value_type ( ) const
  {
  return ( value );
  }
 };
#line 47
typedef integral_constant< bool, true>  true_type; 
#line 48
typedef integral_constant< bool, false>  false_type; 
#line 51
template< bool __T0> 
#line 52
struct _Cat_base : public false_type { 
#line 55
}; 
#line 58
template<> struct _Cat_base< true>  : public true_type { 
#line 61
}; 
#line 64
template< bool _Test, class 
#line 65
_Ty = void> 
#line 66
struct enable_if { 
#line 68
}; 
#line 70
template< class _Ty> 
#line 71
struct enable_if< true, _Ty>  { 
#line 73
typedef _Ty type; 
#line 74
}; 
#line 77
template< bool _Test, class 
#line 78
_Ty1, class 
#line 79
_Ty2> 
#line 80
struct conditional { 
#line 82
typedef _Ty2 type; 
#line 83
}; 
#line 85
template< class _Ty1, class 
#line 86
_Ty2> 
#line 87
struct conditional< true, _Ty1, _Ty2>  { 
#line 89
typedef _Ty1 type; 
#line 90
}; 
#line 93
template< class _Ty1, class _Ty2> 
#line 94
struct is_same : public false_type { 
#line 97
}; 
#line 99
template< class _Ty1> 
#line 100
struct is_same< _Ty1, _Ty1>  : public true_type { 
#line 103
}; 
#line 106
template< class _Ty> 
#line 107
struct remove_const { 
#line 109
typedef _Ty type; 
#line 110
}; 
#line 112
template< class _Ty> 
#line 113
struct remove_const< const _Ty>  { 
#line 115
typedef _Ty type; 
#line 116
}; 
#line 118
template< class _Ty> 
#line 119
struct remove_const< const _Ty []>  { 
#line 121
typedef _Ty type[]; 
#line 122
}; 
#line 124
template< class _Ty, unsigned _Nx> 
#line 125
struct remove_const< const _Ty [_Nx]>  { 
#line 127
typedef _Ty type[_Nx]; 
#line 128
}; 
#line 131
template< class _Ty> 
#line 132
struct remove_volatile { 
#line 134
typedef _Ty type; 
#line 135
}; 
#line 137
template< class _Ty> 
#line 138
struct remove_volatile< volatile _Ty>  { 
#line 140
typedef _Ty type; 
#line 141
}; 
#line 143
template< class _Ty> 
#line 144
struct remove_volatile< volatile _Ty []>  { 
#line 146
typedef _Ty type[]; 
#line 147
}; 
#line 149
template< class _Ty, unsigned _Nx> 
#line 150
struct remove_volatile< volatile _Ty [_Nx]>  { 
#line 152
typedef _Ty type[_Nx]; 
#line 153
}; 
#line 156
template< class _Ty> 
#line 157
struct remove_cv { 
#line 160
typedef typename remove_const< typename remove_volatile< _Ty> ::type> ::type type; 
#line 161
}; 
#line 164
template< class _Ty> 
#line 165
struct _Is_integral : public false_type { 
#line 168
}; 
#line 171
template<> struct _Is_integral< bool>  : public true_type { 
#line 174
}; 
#line 177
template<> struct _Is_integral< char>  : public true_type { 
#line 180
}; 
#line 183
template<> struct _Is_integral< unsigned char>  : public true_type { 
#line 186
}; 
#line 189
template<> struct _Is_integral< signed char>  : public true_type { 
#line 192
}; 
#line 196
template<> struct _Is_integral< __wchar_t>  : public true_type { 
#line 199
}; 
#line 203 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"
template<> struct _Is_integral< unsigned short>  : public true_type { 
#line 206
}; 
#line 209
template<> struct _Is_integral< signed short>  : public true_type { 
#line 212
}; 
#line 215
template<> struct _Is_integral< unsigned>  : public true_type { 
#line 218
}; 
#line 221
template<> struct _Is_integral< signed int>  : public true_type { 
#line 224
}; 
#line 227
template<> struct _Is_integral< unsigned long>  : public true_type { 
#line 230
}; 
#line 233
template<> struct _Is_integral< signed long>  : public true_type { 
#line 236
}; 
#line 254 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"
template<> struct _Is_integral< __int64>  : public true_type { 
#line 257
}; 
#line 260
template<> struct _Is_integral< unsigned __int64>  : public true_type { 
#line 263
}; 
#line 267 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"
template< class _Ty> 
#line 268
struct is_integral : public _Is_integral< typename remove_cv< _Ty> ::type>  { 
#line 271
}; 
#line 274
template< class _Ty> 
#line 275
struct _Is_floating_point : public false_type { 
#line 278
}; 
#line 281
template<> struct _Is_floating_point< float>  : public true_type { 
#line 284
}; 
#line 287
template<> struct _Is_floating_point< double>  : public true_type { 
#line 290
}; 
#line 293
template<> struct _Is_floating_point< long double>  : public true_type { 
#line 296
}; 
#line 299
template< class _Ty> 
#line 300
struct is_floating_point : public _Is_floating_point< typename remove_cv< _Ty> ::type>  { 
#line 303
}; 
#line 305
template< class _Ty> 
#line 306
struct _Is_numeric : public _Cat_base< is_integral< _Ty> ::value || is_floating_point< _Ty> ::value>  { 
#line 310
}; 
#line 313
template< class _Ty> 
#line 314
struct remove_reference { 
#line 316
typedef _Ty type; 
#line 317
}; 
#line 319
template< class _Ty> 
#line 320
struct remove_reference< _Ty &>  { 
#line 322
typedef _Ty type; 
#line 323
}; 
#line 325
template< class _Ty> 
#line 326
struct remove_reference< _Ty &&>  { 
#line 328
typedef _Ty type; 
#line 329
}; 
#line 332
template< class _Tgt, class 
#line 333
_Src> 
#line 334
struct _Copy_cv { 
#line 336
typedef typename remove_reference< _Tgt> ::type _Tgtx; 
#line 337
typedef _Tgtx &type; 
#line 338
}; 
#line 340
template< class _Tgt, class 
#line 341
_Src> 
#line 342
struct _Copy_cv< _Tgt, const _Src>  { 
#line 344
typedef typename remove_reference< _Tgt> ::type _Tgtx; 
#line 345
typedef const _Tgtx &type; 
#line 346
}; 
#line 348
template< class _Tgt, class 
#line 349
_Src> 
#line 350
struct _Copy_cv< _Tgt, volatile _Src>  { 
#line 352
typedef typename remove_reference< _Tgt> ::type _Tgtx; 
#line 353
typedef volatile _Tgtx &type; 
#line 354
}; 
#line 356
template< class _Tgt, class 
#line 357
_Src> 
#line 358
struct _Copy_cv< _Tgt, const volatile _Src>  { 
#line 360
typedef typename remove_reference< _Tgt> ::type _Tgtx; 
#line 361
typedef const volatile _Tgtx &type; 
#line 362
}; 
#line 364
template< class _Tgt, class 
#line 365
_Src> 
#line 366
struct _Copy_cv< _Tgt, _Src &>  { 
#line 368
typedef typename std::_Copy_cv< _Tgt, _Src> ::type type; 
#line 369
}; 
#line 372
struct _Wrap_int { 
#line 374
_Wrap_int(int) 
#line 375
{ 
#line 376
} 
#line 377
}; 
#line 412
template< class _Ty> 
#line 413
struct _Has_result_type { 
#line 414
template< class _Uty> static auto _Fn(int, typename remove_reference< typename _Uty::result_type> ::type * = 0, typename remove_reference< typename _Uty::result_type> ::type * = 0, typename remove_reference< typename _Uty::result_type> ::type * = 0)->true_type; template< class _Uty> static auto _Fn(_Wrap_int)->false_type; typedef decltype((_Fn< _Ty> (0))) type; }; 
#line 415
}
#line 417
#pragma warning(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"
#pragma warning(push,3)
#line 418 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"
#pragma pack ( pop )
#line 10 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"
#pragma pack ( push, 8 )
#line 15
namespace std { 
#line 16
template< class _Ty> 
#line 17
struct _Promote_to_float { 
#line 20
typedef typename conditional< is_integral< _Ty> ::value, double, _Ty> ::type type; 
#line 21
}; 
#line 23
template< class _Ty1, class 
#line 24
_Ty2> 
#line 25
struct _Common_float_type { 
#line 27
typedef typename _Promote_to_float< _Ty1> ::type _Ty1f; 
#line 28
typedef typename _Promote_to_float< _Ty2> ::type _Ty2f; 
#line 33
typedef typename conditional< is_same< typename _Promote_to_float< _Ty1> ::type, long double> ::value || is_same< typename _Promote_to_float< _Ty2> ::type, long double> ::value, long double, typename conditional< is_same< typename _Promote_to_float< _Ty1> ::type, double> ::value || is_same< typename _Promote_to_float< _Ty2> ::type, double> ::value, double, float> ::type> ::type type; 
#line 34
}; 
#line 35
}
#line 70
extern "C" double __cdecl pow(double, double); 
#line 71
inline float __cdecl pow(float, float); 
#line 72
inline long double __cdecl pow(long double, long double); 
#line 74
template < class _Ty1,
 class _Ty2 > inline
 typename :: std :: enable_if < :: std :: _Is_numeric < _Ty1 > :: value
  && :: std :: _Is_numeric < _Ty2 > :: value,
  typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type
 pow ( const _Ty1 _Left, const _Ty2 _Right )
 {
 typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type;
 return ( :: pow ( type ( _Left ), type ( _Right ) ) );
 }
#line 86
extern "C" double __cdecl acos(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type acos ( _Ty _Left ) { return ( :: acos ( ( double ) _Left ) ); }
#line 87
extern "C" double __cdecl asin(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type asin ( _Ty _Left ) { return ( :: asin ( ( double ) _Left ) ); }
#line 88
extern "C" double __cdecl atan(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type atan ( _Ty _Left ) { return ( :: atan ( ( double ) _Left ) ); }
#line 89
extern "C" double __cdecl atan2(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type atan2 ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: atan2 ( ( type ) _Left, ( type ) _Right ) ); }
#line 90
extern "C" __declspec(dllimport) double __cdecl ceil(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type ceil ( _Ty _Left ) { return ( :: ceil ( ( double ) _Left ) ); }
#line 91
extern "C" double __cdecl cos(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type cos ( _Ty _Left ) { return ( :: cos ( ( double ) _Left ) ); }
#line 92
extern "C" double __cdecl cosh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type cosh ( _Ty _Left ) { return ( :: cosh ( ( double ) _Left ) ); }
#line 93
extern "C" double __cdecl exp(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type exp ( _Ty _Left ) { return ( :: exp ( ( double ) _Left ) ); }
#line 95
extern "C" __declspec(dllimport) double __cdecl floor(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type floor ( _Ty _Left ) { return ( :: floor ( ( double ) _Left ) ); }
#line 96
extern "C" double __cdecl fmod(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type fmod ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: fmod ( ( type ) _Left, ( type ) _Right ) ); }
#line 97
extern "C" __declspec(dllimport) double __cdecl frexp(double, int *); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type frexp ( _Ty _Left, int * _Arg2 ) { return ( :: frexp ( ( double ) _Left, _Arg2 ) ); }
#line 98
extern "C" __declspec(dllimport) double __cdecl ldexp(double, int); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type ldexp ( _Ty _Left, int _Arg2 ) { return ( :: ldexp ( ( double ) _Left, _Arg2 ) ); }
#line 99
extern "C" double __cdecl log(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type log ( _Ty _Left ) { return ( :: log ( ( double ) _Left ) ); }
#line 100
extern "C" double __cdecl log10(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type log10 ( _Ty _Left ) { return ( :: log10 ( ( double ) _Left ) ); }
#line 103
extern "C" double __cdecl sin(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type sin ( _Ty _Left ) { return ( :: sin ( ( double ) _Left ) ); }
#line 104
extern "C" double __cdecl sinh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type sinh ( _Ty _Left ) { return ( :: sinh ( ( double ) _Left ) ); }
#line 105
extern "C" double __cdecl sqrt(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type sqrt ( _Ty _Left ) { return ( :: sqrt ( ( double ) _Left ) ); }
#line 106
extern "C" double __cdecl tan(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type tan ( _Ty _Left ) { return ( :: tan ( ( double ) _Left ) ); }
#line 107
extern "C" double __cdecl tanh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type tanh ( _Ty _Left ) { return ( :: tanh ( ( double ) _Left ) ); }
#line 112 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"
#pragma warning(pop)
#pragma pack ( pop )
#line 27 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"
namespace std { 
#line 28
using ::acosf;using ::asinf;
#line 29
using ::atanf;using ::atan2f;using ::ceilf;
#line 30
using ::cosf;using ::coshf;using ::expf;
#line 31
using ::fabsf;using ::floorf;using ::fmodf;
#line 32
using ::frexpf;using ::ldexpf;using ::logf;
#line 33
using ::log10f;using ::modff;using ::powf;
#line 34
using ::sinf;using ::sinhf;using ::sqrtf;
#line 35
using ::tanf;using ::tanhf;
#line 37
using ::acosl;using ::asinl;
#line 38
using ::atanl;using ::atan2l;using ::ceill;
#line 39
using ::cosl;using ::coshl;using ::expl;
#line 40
using ::fabsl;using ::floorl;using ::fmodl;
#line 41
using ::frexpl;using ::ldexpl;using ::logl;
#line 42
using ::log10l;using ::modfl;using ::powl;
#line 43
using ::sinl;using ::sinhl;using ::sqrtl;
#line 44
using ::tanl;using ::tanhl;
#line 46
using ::abs;
#line 48
using ::acos;using ::asin;
#line 49
using ::atan;using ::atan2;using ::ceil;
#line 50
using ::cos;using ::cosh;using ::exp;
#line 51
using ::fabs;using ::floor;using ::fmod;
#line 52
using ::frexp;using ::ldexp;using ::log;
#line 53
using ::log10;using ::modf;using ::pow;
#line 54
using ::sin;using ::sinh;using ::sqrt;
#line 55
using ::tan;using ::tanh;
#line 57
using ::hypot;using ::hypotf;
#line 58
}
#line 18 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"
namespace std { 
#line 19
using ::size_t;using ::div_t;using ::ldiv_t;
#line 21
using ::abort;using ::abs;using ::atexit;
#line 22
using ::atof;using ::atoi;using ::atol;
#line 23
using ::bsearch;using ::calloc;using ::div;
#line 24
using ::exit;using ::free;
#line 25
using ::labs;using ::ldiv;using ::malloc;
#line 26
using ::mblen;using ::mbstowcs;using ::mbtowc;
#line 27
using ::qsort;using ::rand;using ::realloc;
#line 28
using ::srand;using ::strtod;using ::strtol;
#line 29
using ::strtoul;
#line 30
using ::wcstombs;using ::wctomb;
#line 32
using ::lldiv_t;
#line 33
using ::llabs;using ::lldiv;
#line 36
using ::getenv;
#line 37
using ::system;
#line 39 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"
}
#line 7661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern double __cdecl _hypot(double , double ); } 
#line 7662
extern "C" { __declspec(dllimport) extern float __cdecl _hypotf(float , float ); } 
#line 7666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
static __inline int signbit(long double a) 
#line 7667
{ 
#line 7668
return __signbitl(a); 
#line 7669
} 
#line 7682
static __inline int signbit(double a) 
#line 7683
{ 
#line 7684
return __signbit(a); 
#line 7685
} 
#line 7698
static __inline int signbit(float a) 
#line 7699
{ 
#line 7700
return __signbitf(a); 
#line 7701
} 
#line 7703
static __inline int isinf(long double a) 
#line 7704
{ 
#line 7705
return __isinfl(a); 
#line 7706
} 
#line 7719
static __inline int isinf(double a) 
#line 7720
{ 
#line 7721
return __isinf(a); 
#line 7722
} 
#line 7735
static __inline int isinf(float a) 
#line 7736
{ 
#line 7737
return __isinff(a); 
#line 7738
} 
#line 7740
static __inline int isnan(long double a) 
#line 7741
{ 
#line 7742
return __isnanl(a); 
#line 7743
} 
#line 7755
static __inline int isnan(double a) 
#line 7756
{ 
#line 7757
return __isnan(a); 
#line 7758
} 
#line 7770
static __inline int isnan(float a) 
#line 7771
{ 
#line 7772
return __isnanf(a); 
#line 7773
} 
#line 7775
static __inline int isfinite(long double a) 
#line 7776
{ 
#line 7777
return __finitel(a); 
#line 7778
} 
#line 7791
static __inline int isfinite(double a) 
#line 7792
{ 
#line 7793
return __finite(a); 
#line 7794
} 
#line 7807
static __inline int isfinite(float a) 
#line 7808
{ 
#line 7809
return __finitef(a); 
#line 7810
} 
#line 7812
template< class T> extern inline T _Pow_int(T, int); 
#line 7813
extern inline __int64 abs(__int64); 
#line 7828 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
extern inline long __cdecl abs(long); 
#line 7829
extern inline float __cdecl abs(float); 
#line 7830
extern inline double __cdecl abs(double); 
#line 7831
extern inline float __cdecl fabs(float); 
#line 7832
extern inline float __cdecl ceil(float); 
#line 7833
extern inline float __cdecl floor(float); 
#line 7834
extern inline float __cdecl sqrt(float); 
#line 7835
extern inline float __cdecl pow(float, float); 
#line 7836
extern inline float __cdecl pow(float, int); 
#line 7837
extern inline double __cdecl pow(double, int); 
#line 7838
extern inline float __cdecl log(float); 
#line 7839
extern inline float __cdecl log10(float); 
#line 7840
extern inline float __cdecl fmod(float, float); 
#line 7841
extern inline float __cdecl modf(float, float *); 
#line 7842
extern inline float __cdecl exp(float); 
#line 7843
extern inline float __cdecl frexp(float, int *); 
#line 7844
extern inline float __cdecl ldexp(float, int); 
#line 7845
extern inline float __cdecl asin(float); 
#line 7846
extern inline float __cdecl sin(float); 
#line 7847
extern inline float __cdecl sinh(float); 
#line 7848
extern inline float __cdecl acos(float); 
#line 7849
extern inline float __cdecl cos(float); 
#line 7850
extern inline float __cdecl cosh(float); 
#line 7851
extern inline float __cdecl atan(float); 
#line 7852
extern inline float __cdecl atan2(float, float); 
#line 7853
extern inline float __cdecl tan(float); 
#line 7854
extern inline float __cdecl tanh(float); 
#line 7860 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\math_functions.h"
static __inline float logb(float a) 
#line 7861
{ 
#line 7862
return logbf(a); 
#line 7863
} 
#line 7865
static __inline int ilogb(float a) 
#line 7866
{ 
#line 7867
return ilogbf(a); 
#line 7868
} 
#line 7870
static __inline float scalbn(float a, int b) 
#line 7871
{ 
#line 7872
return scalbnf(a, b); 
#line 7873
} 
#line 7875
static __inline float scalbln(float a, long b) 
#line 7876
{ 
#line 7877
return scalblnf(a, b); 
#line 7878
} 
#line 7880
static __inline float exp2(float a) 
#line 7881
{ 
#line 7882
return exp2f(a); 
#line 7883
} 
#line 7885
static __inline float exp10(float a) 
#line 7886
{ 
#line 7887
return exp10f(a); 
#line 7888
} 
#line 7890
static __inline float expm1(float a) 
#line 7891
{ 
#line 7892
return expm1f(a); 
#line 7893
} 
#line 7895
static __inline float log2(float a) 
#line 7896
{ 
#line 7897
return log2f(a); 
#line 7898
} 
#line 7900
static __inline float log1p(float a) 
#line 7901
{ 
#line 7902
return log1pf(a); 
#line 7903
} 
#line 7905
static __inline float rsqrt(float a) 
#line 7906
{ 
#line 7907
return rsqrtf(a); 
#line 7908
} 
#line 7910
static __inline float acosh(float a) 
#line 7911
{ 
#line 7912
return acoshf(a); 
#line 7913
} 
#line 7915
static __inline float asinh(float a) 
#line 7916
{ 
#line 7917
return asinhf(a); 
#line 7918
} 
#line 7920
static __inline float atanh(float a) 
#line 7921
{ 
#line 7922
return atanhf(a); 
#line 7923
} 
#line 7925
static __inline float hypot(float a, float b) 
#line 7926
{ 
#line 7927
return hypotf(a, b); 
#line 7928
} 
#line 7930
static __inline float cbrt(float a) 
#line 7931
{ 
#line 7932
return cbrtf(a); 
#line 7933
} 
#line 7935
static __inline float rcbrt(float a) 
#line 7936
{ 
#line 7937
return rcbrtf(a); 
#line 7938
} 
#line 7940
static __inline float sinpi(float a) 
#line 7941
{ 
#line 7942
return sinpif(a); 
#line 7943
} 
#line 7945
static __inline float cospi(float a) 
#line 7946
{ 
#line 7947
return cospif(a); 
#line 7948
} 
#line 7950
static __inline void sincospi(float a, float *sptr, float *cptr) 
#line 7951
{ 
#line 7952
sincospif(a, sptr, cptr); 
#line 7953
} 
#line 7955
static __inline void sincos(float a, float *sptr, float *cptr) 
#line 7956
{ 
#line 7957
sincosf(a, sptr, cptr); 
#line 7958
} 
#line 7960
static __inline float j0(float a) 
#line 7961
{ 
#line 7962
return j0f(a); 
#line 7963
} 
#line 7965
static __inline float j1(float a) 
#line 7966
{ 
#line 7967
return j1f(a); 
#line 7968
} 
#line 7970
static __inline float jn(int n, float a) 
#line 7971
{ 
#line 7972
return jnf(n, a); 
#line 7973
} 
#line 7975
static __inline float y0(float a) 
#line 7976
{ 
#line 7977
return y0f(a); 
#line 7978
} 
#line 7980
static __inline float y1(float a) 
#line 7981
{ 
#line 7982
return y1f(a); 
#line 7983
} 
#line 7985
static __inline float yn(int n, float a) 
#line 7986
{ 
#line 7987
return ynf(n, a); 
#line 7988
} 
#line 7990
static __inline float erf(float a) 
#line 7991
{ 
#line 7992
return erff(a); 
#line 7993
} 
#line 7995
static __inline float erfinv(float a) 
#line 7996
{ 
#line 7997
return erfinvf(a); 
#line 7998
} 
#line 8000
static __inline float erfc(float a) 
#line 8001
{ 
#line 8002
return erfcf(a); 
#line 8003
} 
#line 8005
static __inline float erfcinv(float a) 
#line 8006
{ 
#line 8007
return erfcinvf(a); 
#line 8008
} 
#line 8010
static __inline float normcdfinv(float a) 
#line 8011
{ 
#line 8012
return normcdfinvf(a); 
#line 8013
} 
#line 8015
static __inline float normcdf(float a) 
#line 8016
{ 
#line 8017
return normcdff(a); 
#line 8018
} 
#line 8020
static __inline float erfcx(float a) 
#line 8021
{ 
#line 8022
return erfcxf(a); 
#line 8023
} 
#line 8025
static __inline float lgamma(float a) 
#line 8026
{ 
#line 8027
return lgammaf(a); 
#line 8028
} 
#line 8030
static __inline float tgamma(float a) 
#line 8031
{ 
#line 8032
return tgammaf(a); 
#line 8033
} 
#line 8035
static __inline float copysign(float a, float b) 
#line 8036
{ 
#line 8037
return copysignf(a, b); 
#line 8038
} 
#line 8040
static __inline double copysign(double a, float b) 
#line 8041
{ 
#line 8042
return copysign(a, (double)b); 
#line 8043
} 
#line 8045
static __inline float copysign(float a, double b) 
#line 8046
{ 
#line 8047
return copysignf(a, (float)b); 
#line 8048
} 
#line 8050
static __inline float nextafter(float a, float b) 
#line 8051
{ 
#line 8052
return nextafterf(a, b); 
#line 8053
} 
#line 8055
static __inline float remainder(float a, float b) 
#line 8056
{ 
#line 8057
return remainderf(a, b); 
#line 8058
} 
#line 8060
static __inline float remquo(float a, float b, int *quo) 
#line 8061
{ 
#line 8062
return remquof(a, b, quo); 
#line 8063
} 
#line 8065
static __inline float round(float a) 
#line 8066
{ 
#line 8067
return roundf(a); 
#line 8068
} 
#line 8070
static __inline long lround(float a) 
#line 8071
{ 
#line 8072
return lroundf(a); 
#line 8073
} 
#line 8075
static __inline __int64 llround(float a) 
#line 8076
{ 
#line 8077
return llroundf(a); 
#line 8078
} 
#line 8080
static __inline float trunc(float a) 
#line 8081
{ 
#line 8082
return truncf(a); 
#line 8083
} 
#line 8085
static __inline float rint(float a) 
#line 8086
{ 
#line 8087
return rintf(a); 
#line 8088
} 
#line 8090
static __inline long lrint(float a) 
#line 8091
{ 
#line 8092
return lrintf(a); 
#line 8093
} 
#line 8095
static __inline __int64 llrint(float a) 
#line 8096
{ 
#line 8097
return llrintf(a); 
#line 8098
} 
#line 8100
static __inline float nearbyint(float a) 
#line 8101
{ 
#line 8102
return nearbyintf(a); 
#line 8103
} 
#line 8105
static __inline float fdim(float a, float b) 
#line 8106
{ 
#line 8107
return fdimf(a, b); 
#line 8108
} 
#line 8110
static __inline float fma(float a, float b, float c) 
#line 8111
{ 
#line 8112
return fmaf(a, b, c); 
#line 8113
} 
#line 8115
static __inline float fmax(float a, float b) 
#line 8116
{ 
#line 8117
return fmaxf(a, b); 
#line 8118
} 
#line 8120
static __inline float fmin(float a, float b) 
#line 8121
{ 
#line 8122
return fminf(a, b); 
#line 8123
} 
#line 8125
static __inline unsigned min(unsigned a, unsigned b) 
#line 8126
{ 
#line 8127
return umin(a, b); 
#line 8128
} 
#line 8130
static __inline unsigned min(int a, unsigned b) 
#line 8131
{ 
#line 8132
return umin((unsigned)a, b); 
#line 8133
} 
#line 8135
static __inline unsigned min(unsigned a, int b) 
#line 8136
{ 
#line 8137
return umin(a, (unsigned)b); 
#line 8138
} 
#line 8140
static __inline __int64 min(__int64 a, __int64 b) 
#line 8141
{ 
#line 8142
return llmin(a, b); 
#line 8143
} 
#line 8145
static __inline unsigned __int64 min(unsigned __int64 a, unsigned __int64 b) 
#line 8146
{ 
#line 8147
return ullmin(a, b); 
#line 8148
} 
#line 8150
static __inline unsigned __int64 min(__int64 a, unsigned __int64 b) 
#line 8151
{ 
#line 8152
return ullmin((unsigned __int64)a, b); 
#line 8153
} 
#line 8155
static __inline unsigned __int64 min(unsigned __int64 a, __int64 b) 
#line 8156
{ 
#line 8157
return ullmin(a, (unsigned __int64)b); 
#line 8158
} 
#line 8160
static __inline float min(float a, float b) 
#line 8161
{ 
#line 8162
return fminf(a, b); 
#line 8163
} 
#line 8165
static __inline double min(double a, double b) 
#line 8166
{ 
#line 8167
return fmin(a, b); 
#line 8168
} 
#line 8170
static __inline double min(float a, double b) 
#line 8171
{ 
#line 8172
return fmin((double)a, b); 
#line 8173
} 
#line 8175
static __inline double min(double a, float b) 
#line 8176
{ 
#line 8177
return fmin(a, (double)b); 
#line 8178
} 
#line 8180
static __inline unsigned max(unsigned a, unsigned b) 
#line 8181
{ 
#line 8182
return umax(a, b); 
#line 8183
} 
#line 8185
static __inline unsigned max(int a, unsigned b) 
#line 8186
{ 
#line 8187
return umax((unsigned)a, b); 
#line 8188
} 
#line 8190
static __inline unsigned max(unsigned a, int b) 
#line 8191
{ 
#line 8192
return umax(a, (unsigned)b); 
#line 8193
} 
#line 8195
static __inline __int64 max(__int64 a, __int64 b) 
#line 8196
{ 
#line 8197
return llmax(a, b); 
#line 8198
} 
#line 8200
static __inline unsigned __int64 max(unsigned __int64 a, unsigned __int64 b) 
#line 8201
{ 
#line 8202
return ullmax(a, b); 
#line 8203
} 
#line 8205
static __inline unsigned __int64 max(__int64 a, unsigned __int64 b) 
#line 8206
{ 
#line 8207
return ullmax((unsigned __int64)a, b); 
#line 8208
} 
#line 8210
static __inline unsigned __int64 max(unsigned __int64 a, __int64 b) 
#line 8211
{ 
#line 8212
return ullmax(a, (unsigned __int64)b); 
#line 8213
} 
#line 8215
static __inline float max(float a, float b) 
#line 8216
{ 
#line 8217
return fmaxf(a, b); 
#line 8218
} 
#line 8220
static __inline double max(double a, double b) 
#line 8221
{ 
#line 8222
return fmax(a, b); 
#line 8223
} 
#line 8225
static __inline double max(float a, double b) 
#line 8226
{ 
#line 8227
return fmax((double)a, b); 
#line 8228
} 
#line 8230
static __inline double max(double a, float b) 
#line 8231
{ 
#line 8232
return fmax(a, (double)b); 
#line 8233
} 
#line 73 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_surface_types.h"
template< class T, int dim = 1> 
#line 74
struct surface : public surfaceReference { 
#line 76
surface() 
#line 77
{ 
#line 78
(channelDesc) = cudaCreateChannelDesc< T> (); 
#line 79
} 
#line 81
surface(::cudaChannelFormatDesc desc) 
#line 82
{ 
#line 83
(channelDesc) = desc; 
#line 84
} 
#line 85
}; 
#line 87
template< int dim> 
#line 88
struct surface< void, dim>  : public surfaceReference { 
#line 90
surface() 
#line 91
{ 
#line 92
(channelDesc) = cudaCreateChannelDesc< void> (); 
#line 93
} 
#line 94
}; 
#line 73 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_texture_types.h"
template< class T, int texType = 1, cudaTextureReadMode mode = cudaReadModeElementType> 
#line 74
struct texture : public textureReference { 
#line 76
texture(int norm = 0, ::cudaTextureFilterMode 
#line 77
fMode = cudaFilterModePoint, ::cudaTextureAddressMode 
#line 78
aMode = cudaAddressModeClamp) 
#line 79
{ 
#line 80
(normalized) = norm; 
#line 81
(filterMode) = fMode; 
#line 82
((addressMode)[0]) = aMode; 
#line 83
((addressMode)[1]) = aMode; 
#line 84
((addressMode)[2]) = aMode; 
#line 85
(channelDesc) = cudaCreateChannelDesc< T> (); 
#line 86
(sRGB) = 0; 
#line 87
} 
#line 89
texture(int norm, ::cudaTextureFilterMode 
#line 90
fMode, ::cudaTextureAddressMode 
#line 91
aMode, ::cudaChannelFormatDesc 
#line 92
desc) 
#line 93
{ 
#line 94
(normalized) = norm; 
#line 95
(filterMode) = fMode; 
#line 96
((addressMode)[0]) = aMode; 
#line 97
((addressMode)[1]) = aMode; 
#line 98
((addressMode)[2]) = aMode; 
#line 99
(channelDesc) = desc; 
#line 100
(sRGB) = 0; 
#line 101
} 
#line 102
}; 
#line 2285 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline int mulhi(int a, int b) 
#line 2286
{int volatile ___ = 1;(void)a;(void)b;
#line 2288
::exit(___);}
#if 0
#line 2286
{ 
#line 2287
return __mulhi(a, b); 
#line 2288
} 
#endif
#line 2290 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline unsigned mulhi(unsigned a, unsigned b) 
#line 2291
{int volatile ___ = 1;(void)a;(void)b;
#line 2293
::exit(___);}
#if 0
#line 2291
{ 
#line 2292
return __umulhi(a, b); 
#line 2293
} 
#endif
#line 2295 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline unsigned mulhi(int a, unsigned b) 
#line 2296
{int volatile ___ = 1;(void)a;(void)b;
#line 2298
::exit(___);}
#if 0
#line 2296
{ 
#line 2297
return __umulhi((unsigned)a, b); 
#line 2298
} 
#endif
#line 2300 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline unsigned mulhi(unsigned a, int b) 
#line 2301
{int volatile ___ = 1;(void)a;(void)b;
#line 2303
::exit(___);}
#if 0
#line 2301
{ 
#line 2302
return __umulhi(a, (unsigned)b); 
#line 2303
} 
#endif
#line 2305 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline __int64 mul64hi(__int64 a, __int64 b) 
#line 2306
{int volatile ___ = 1;(void)a;(void)b;
#line 2308
::exit(___);}
#if 0
#line 2306
{ 
#line 2307
return __mul64hi(a, b); 
#line 2308
} 
#endif
#line 2310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline unsigned __int64 mul64hi(unsigned __int64 a, unsigned __int64 b) 
#line 2311
{int volatile ___ = 1;(void)a;(void)b;
#line 2313
::exit(___);}
#if 0
#line 2311
{ 
#line 2312
return __umul64hi(a, b); 
#line 2313
} 
#endif
#line 2315 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline unsigned __int64 mul64hi(__int64 a, unsigned __int64 b) 
#line 2316
{int volatile ___ = 1;(void)a;(void)b;
#line 2318
::exit(___);}
#if 0
#line 2316
{ 
#line 2317
return __umul64hi((unsigned __int64)a, b); 
#line 2318
} 
#endif
#line 2320 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline unsigned __int64 mul64hi(unsigned __int64 a, __int64 b) 
#line 2321
{int volatile ___ = 1;(void)a;(void)b;
#line 2323
::exit(___);}
#if 0
#line 2321
{ 
#line 2322
return __umul64hi(a, (unsigned __int64)b); 
#line 2323
} 
#endif
#line 2325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline int float_as_int(float a) 
#line 2326
{int volatile ___ = 1;(void)a;
#line 2328
::exit(___);}
#if 0
#line 2326
{ 
#line 2327
return __float_as_int(a); 
#line 2328
} 
#endif
#line 2330 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline float int_as_float(int a) 
#line 2331
{int volatile ___ = 1;(void)a;
#line 2333
::exit(___);}
#if 0
#line 2331
{ 
#line 2332
return __int_as_float(a); 
#line 2333
} 
#endif
#line 2335 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline float saturate(float a) 
#line 2336
{int volatile ___ = 1;(void)a;
#line 2338
::exit(___);}
#if 0
#line 2336
{ 
#line 2337
return __saturatef(a); 
#line 2338
} 
#endif
#line 2340 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline int mul24(int a, int b) 
#line 2341
{int volatile ___ = 1;(void)a;(void)b;
#line 2343
::exit(___);}
#if 0
#line 2341
{ 
#line 2342
return __mul24(a, b); 
#line 2343
} 
#endif
#line 2345 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline unsigned umul24(unsigned a, unsigned b) 
#line 2346
{int volatile ___ = 1;(void)a;(void)b;
#line 2348
::exit(___);}
#if 0
#line 2346
{ 
#line 2347
return __umul24(a, b); 
#line 2348
} 
#endif
#line 2350 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline void trap() 
#line 2351
{int volatile ___ = 1;
#line 2353
::exit(___);}
#if 0
#line 2351
{ 
#line 2352
__trap(); 
#line 2353
} 
#endif
#line 2356 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline void brkpt(int c = 0) 
#line 2357
{int volatile ___ = 1;(void)c;
#line 2359
::exit(___);}
#if 0
#line 2357
{ 
#line 2358
__brkpt(c); 
#line 2359
} 
#endif
#line 2361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline void syncthreads() 
#line 2362
{int volatile ___ = 1;
#line 2364
::exit(___);}
#if 0
#line 2362
{ 
#line 2363
__syncthreads(); 
#line 2364
} 
#endif
#line 2366 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline void prof_trigger(int e) 
#line 2367
{int volatile ___ = 1;(void)e;
#line 2384
::exit(___);}
#if 0
#line 2367
{ 
#line 2368
if (e == 0) { __prof_trigger(0); } else { 
#line 2369
if (e == 1) { __prof_trigger(1); } else { 
#line 2370
if (e == 2) { __prof_trigger(2); } else { 
#line 2371
if (e == 3) { __prof_trigger(3); } else { 
#line 2372
if (e == 4) { __prof_trigger(4); } else { 
#line 2373
if (e == 5) { __prof_trigger(5); } else { 
#line 2374
if (e == 6) { __prof_trigger(6); } else { 
#line 2375
if (e == 7) { __prof_trigger(7); } else { 
#line 2376
if (e == 8) { __prof_trigger(8); } else { 
#line 2377
if (e == 9) { __prof_trigger(9); } else { 
#line 2378
if (e == 10) { __prof_trigger(10); } else { 
#line 2379
if (e == 11) { __prof_trigger(11); } else { 
#line 2380
if (e == 12) { __prof_trigger(12); } else { 
#line 2381
if (e == 13) { __prof_trigger(13); } else { 
#line 2382
if (e == 14) { __prof_trigger(14); } else { 
#line 2383
if (e == 15) { __prof_trigger(15); }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  
#line 2384
} 
#endif
#line 2386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline void threadfence(bool global = true) 
#line 2387
{int volatile ___ = 1;(void)global;
#line 2389
::exit(___);}
#if 0
#line 2387
{ 
#line 2388
global ? __threadfence() : __threadfence_block(); 
#line 2389
} 
#endif
#line 2391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline int float2int(float a, cudaRoundMode mode = cudaRoundZero) 
#line 2392
{int volatile ___ = 1;(void)a;(void)mode;
#line 2397
::exit(___);}
#if 0
#line 2392
{ 
#line 2393
return (mode == (cudaRoundNearest)) ? __float2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2int_rd(a) : __float2int_rz(a))); 
#line 2397
} 
#endif
#line 2399 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline unsigned float2uint(float a, cudaRoundMode mode = cudaRoundZero) 
#line 2400
{int volatile ___ = 1;(void)a;(void)mode;
#line 2405
::exit(___);}
#if 0
#line 2400
{ 
#line 2401
return (mode == (cudaRoundNearest)) ? __float2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2uint_rd(a) : __float2uint_rz(a))); 
#line 2405
} 
#endif
#line 2407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline float int2float(int a, cudaRoundMode mode = cudaRoundNearest) 
#line 2408
{int volatile ___ = 1;(void)a;(void)mode;
#line 2413
::exit(___);}
#if 0
#line 2408
{ 
#line 2409
return (mode == (cudaRoundZero)) ? __int2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __int2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __int2float_rd(a) : __int2float_rn(a))); 
#line 2413
} 
#endif
#line 2415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_functions.h"
static __inline float uint2float(unsigned a, cudaRoundMode mode = cudaRoundNearest) 
#line 2416
{int volatile ___ = 1;(void)a;(void)mode;
#line 2421
::exit(___);}
#if 0
#line 2416
{ 
#line 2417
return (mode == (cudaRoundZero)) ? __uint2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __uint2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __uint2float_rd(a) : __uint2float_rn(a))); 
#line 2421
} 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline int atomicAdd(int *address, int val) 
#line 97
{int volatile ___ = 1;(void)address;(void)val;
#line 99
::exit(___);}
#if 0
#line 97
{ 
#line 98
return __iAtomicAdd(address, val); 
#line 99
} 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicAdd(unsigned *address, unsigned val) 
#line 102
{int volatile ___ = 1;(void)address;(void)val;
#line 104
::exit(___);}
#if 0
#line 102
{ 
#line 103
return __uAtomicAdd(address, val); 
#line 104
} 
#endif
#line 106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline int atomicSub(int *address, int val) 
#line 107
{int volatile ___ = 1;(void)address;(void)val;
#line 109
::exit(___);}
#if 0
#line 107
{ 
#line 108
return __iAtomicAdd(address, (unsigned)(-val)); 
#line 109
} 
#endif
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicSub(unsigned *address, unsigned val) 
#line 112
{int volatile ___ = 1;(void)address;(void)val;
#line 114
::exit(___);}
#if 0
#line 112
{ 
#line 113
return __uAtomicAdd(address, (unsigned)(-((int)val))); 
#line 114
} 
#endif
#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline int atomicExch(int *address, int val) 
#line 117
{int volatile ___ = 1;(void)address;(void)val;
#line 119
::exit(___);}
#if 0
#line 117
{ 
#line 118
return __iAtomicExch(address, val); 
#line 119
} 
#endif
#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicExch(unsigned *address, unsigned val) 
#line 122
{int volatile ___ = 1;(void)address;(void)val;
#line 124
::exit(___);}
#if 0
#line 122
{ 
#line 123
return __uAtomicExch(address, val); 
#line 124
} 
#endif
#line 126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline float atomicExch(float *address, float val) 
#line 127
{int volatile ___ = 1;(void)address;(void)val;
#line 129
::exit(___);}
#if 0
#line 127
{ 
#line 128
return __fAtomicExch(address, val); 
#line 129
} 
#endif
#line 131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline int atomicMin(int *address, int val) 
#line 132
{int volatile ___ = 1;(void)address;(void)val;
#line 134
::exit(___);}
#if 0
#line 132
{ 
#line 133
return __iAtomicMin(address, val); 
#line 134
} 
#endif
#line 136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicMin(unsigned *address, unsigned val) 
#line 137
{int volatile ___ = 1;(void)address;(void)val;
#line 139
::exit(___);}
#if 0
#line 137
{ 
#line 138
return __uAtomicMin(address, val); 
#line 139
} 
#endif
#line 141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline int atomicMax(int *address, int val) 
#line 142
{int volatile ___ = 1;(void)address;(void)val;
#line 144
::exit(___);}
#if 0
#line 142
{ 
#line 143
return __iAtomicMax(address, val); 
#line 144
} 
#endif
#line 146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicMax(unsigned *address, unsigned val) 
#line 147
{int volatile ___ = 1;(void)address;(void)val;
#line 149
::exit(___);}
#if 0
#line 147
{ 
#line 148
return __uAtomicMax(address, val); 
#line 149
} 
#endif
#line 151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicInc(unsigned *address, unsigned val) 
#line 152
{int volatile ___ = 1;(void)address;(void)val;
#line 154
::exit(___);}
#if 0
#line 152
{ 
#line 153
return __uAtomicInc(address, val); 
#line 154
} 
#endif
#line 156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicDec(unsigned *address, unsigned val) 
#line 157
{int volatile ___ = 1;(void)address;(void)val;
#line 159
::exit(___);}
#if 0
#line 157
{ 
#line 158
return __uAtomicDec(address, val); 
#line 159
} 
#endif
#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline int atomicAnd(int *address, int val) 
#line 162
{int volatile ___ = 1;(void)address;(void)val;
#line 164
::exit(___);}
#if 0
#line 162
{ 
#line 163
return __iAtomicAnd(address, val); 
#line 164
} 
#endif
#line 166 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicAnd(unsigned *address, unsigned val) 
#line 167
{int volatile ___ = 1;(void)address;(void)val;
#line 169
::exit(___);}
#if 0
#line 167
{ 
#line 168
return __uAtomicAnd(address, val); 
#line 169
} 
#endif
#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline int atomicOr(int *address, int val) 
#line 172
{int volatile ___ = 1;(void)address;(void)val;
#line 174
::exit(___);}
#if 0
#line 172
{ 
#line 173
return __iAtomicOr(address, val); 
#line 174
} 
#endif
#line 176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicOr(unsigned *address, unsigned val) 
#line 177
{int volatile ___ = 1;(void)address;(void)val;
#line 179
::exit(___);}
#if 0
#line 177
{ 
#line 178
return __uAtomicOr(address, val); 
#line 179
} 
#endif
#line 181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline int atomicXor(int *address, int val) 
#line 182
{int volatile ___ = 1;(void)address;(void)val;
#line 184
::exit(___);}
#if 0
#line 182
{ 
#line 183
return __iAtomicXor(address, val); 
#line 184
} 
#endif
#line 186 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicXor(unsigned *address, unsigned val) 
#line 187
{int volatile ___ = 1;(void)address;(void)val;
#line 189
::exit(___);}
#if 0
#line 187
{ 
#line 188
return __uAtomicXor(address, val); 
#line 189
} 
#endif
#line 191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline int atomicCAS(int *address, int compare, int val) 
#line 192
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
#line 194
::exit(___);}
#if 0
#line 192
{ 
#line 193
return __iAtomicCAS(address, compare, val); 
#line 194
} 
#endif
#line 196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicCAS(unsigned *address, unsigned compare, unsigned val) 
#line 197
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
#line 199
::exit(___);}
#if 0
#line 197
{ 
#line 198
return __uAtomicCAS(address, compare, val); 
#line 199
} 
#endif
#line 81 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_12_atomic_functions.h"
static __inline unsigned __int64 atomicAdd(unsigned __int64 *address, unsigned __int64 val) 
#line 82
{int volatile ___ = 1;(void)address;(void)val;
#line 84
::exit(___);}
#if 0
#line 82
{ 
#line 83
return __ullAtomicAdd(address, val); 
#line 84
} 
#endif
#line 86 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_12_atomic_functions.h"
static __inline unsigned __int64 atomicExch(unsigned __int64 *address, unsigned __int64 val) 
#line 87
{int volatile ___ = 1;(void)address;(void)val;
#line 89
::exit(___);}
#if 0
#line 87
{ 
#line 88
return __ullAtomicExch(address, val); 
#line 89
} 
#endif
#line 91 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_12_atomic_functions.h"
static __inline unsigned __int64 atomicCAS(unsigned __int64 *address, unsigned __int64 compare, unsigned __int64 val) 
#line 92
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
#line 94
::exit(___);}
#if 0
#line 92
{ 
#line 93
return __ullAtomicCAS(address, compare, val); 
#line 94
} 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_12_atomic_functions.h"
static __inline bool any(bool cond) 
#line 97
{int volatile ___ = 1;(void)cond;
#line 99
::exit(___);}
#if 0
#line 97
{ 
#line 98
return (bool)__any((int)cond); 
#line 99
} 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_12_atomic_functions.h"
static __inline bool all(bool cond) 
#line 102
{int volatile ___ = 1;(void)cond;
#line 104
::exit(___);}
#if 0
#line 102
{ 
#line 103
return (bool)__all((int)cond); 
#line 104
} 
#endif
#line 1133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline double fma(double a, double b, double c, cudaRoundMode mode) 
#line 1134
{int volatile ___ = 1;(void)a;(void)b;(void)c;(void)mode;
#line 1139
::exit(___);}
#if 0
#line 1134
{ 
#line 1135
return (mode == (cudaRoundZero)) ? __fma_rz(a, b, c) : ((mode == (cudaRoundPosInf)) ? __fma_ru(a, b, c) : ((mode == (cudaRoundMinInf)) ? __fma_rd(a, b, c) : __fma_rn(a, b, c))); 
#line 1139
} 
#endif
#line 1141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline double dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest) 
#line 1142
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
#line 1147
::exit(___);}
#if 0
#line 1142
{ 
#line 1143
return (mode == (cudaRoundZero)) ? __dmul_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dmul_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dmul_rd(a, b) : __dmul_rn(a, b))); 
#line 1147
} 
#endif
#line 1149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline double dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest) 
#line 1150
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
#line 1155
::exit(___);}
#if 0
#line 1150
{ 
#line 1151
return (mode == (cudaRoundZero)) ? __dadd_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dadd_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dadd_rd(a, b) : __dadd_rn(a, b))); 
#line 1155
} 
#endif
#line 1157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline double dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest) 
#line 1158
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
#line 1163
::exit(___);}
#if 0
#line 1158
{ 
#line 1159
return (mode == (cudaRoundZero)) ? __dsub_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dsub_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dsub_rd(a, b) : __dsub_rn(a, b))); 
#line 1163
} 
#endif
#line 1165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline int double2int(double a, cudaRoundMode mode = cudaRoundZero) 
#line 1166
{int volatile ___ = 1;(void)a;(void)mode;
#line 1171
::exit(___);}
#if 0
#line 1166
{ 
#line 1167
return (mode == (cudaRoundNearest)) ? __double2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2int_rd(a) : __double2int_rz(a))); 
#line 1171
} 
#endif
#line 1173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline unsigned double2uint(double a, cudaRoundMode mode = cudaRoundZero) 
#line 1174
{int volatile ___ = 1;(void)a;(void)mode;
#line 1179
::exit(___);}
#if 0
#line 1174
{ 
#line 1175
return (mode == (cudaRoundNearest)) ? __double2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2uint_rd(a) : __double2uint_rz(a))); 
#line 1179
} 
#endif
#line 1181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline __int64 double2ll(double a, cudaRoundMode mode = cudaRoundZero) 
#line 1182
{int volatile ___ = 1;(void)a;(void)mode;
#line 1187
::exit(___);}
#if 0
#line 1182
{ 
#line 1183
return (mode == (cudaRoundNearest)) ? __double2ll_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ll_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ll_rd(a) : __double2ll_rz(a))); 
#line 1187
} 
#endif
#line 1189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline unsigned __int64 double2ull(double a, cudaRoundMode mode = cudaRoundZero) 
#line 1190
{int volatile ___ = 1;(void)a;(void)mode;
#line 1195
::exit(___);}
#if 0
#line 1190
{ 
#line 1191
return (mode == (cudaRoundNearest)) ? __double2ull_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ull_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ull_rd(a) : __double2ull_rz(a))); 
#line 1195
} 
#endif
#line 1197 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline double ll2double(__int64 a, cudaRoundMode mode = cudaRoundNearest) 
#line 1198
{int volatile ___ = 1;(void)a;(void)mode;
#line 1203
::exit(___);}
#if 0
#line 1198
{ 
#line 1199
return (mode == (cudaRoundZero)) ? __ll2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ll2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ll2double_rd(a) : __ll2double_rn(a))); 
#line 1203
} 
#endif
#line 1205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline double ull2double(unsigned __int64 a, cudaRoundMode mode = cudaRoundNearest) 
#line 1206
{int volatile ___ = 1;(void)a;(void)mode;
#line 1211
::exit(___);}
#if 0
#line 1206
{ 
#line 1207
return (mode == (cudaRoundZero)) ? __ull2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ull2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ull2double_rd(a) : __ull2double_rn(a))); 
#line 1211
} 
#endif
#line 1213 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline double int2double(int a, cudaRoundMode mode = cudaRoundNearest) 
#line 1214
{int volatile ___ = 1;(void)a;(void)mode;
#line 1216
::exit(___);}
#if 0
#line 1214
{ 
#line 1215
return (double)a; 
#line 1216
} 
#endif
#line 1218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline double uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest) 
#line 1219
{int volatile ___ = 1;(void)a;(void)mode;
#line 1221
::exit(___);}
#if 0
#line 1219
{ 
#line 1220
return (double)a; 
#line 1221
} 
#endif
#line 1223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_13_double_functions.h"
static __inline double float2double(float a, cudaRoundMode mode = cudaRoundNearest) 
#line 1224
{int volatile ___ = 1;(void)a;(void)mode;
#line 1226
::exit(___);}
#if 0
#line 1224
{ 
#line 1225
return (double)a; 
#line 1226
} 
#endif
#line 77 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_atomic_functions.h"
static __inline float atomicAdd(float *address, float val) 
#line 78
{int volatile ___ = 1;(void)address;(void)val;
#line 80
::exit(___);}
#if 0
#line 78
{ 
#line 79
return __fAtomicAdd(address, val); 
#line 80
} 
#endif
#line 83 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMin(__int64 *address, __int64 val) 
#line 84
{int volatile ___ = 1;(void)address;(void)val;
#line 86
::exit(___);}
#if 0
#line 84
{ 
#line 85
return __illAtomicMin(address, val); 
#line 86
} 
#endif
#line 88 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMax(__int64 *address, __int64 val) 
#line 89
{int volatile ___ = 1;(void)address;(void)val;
#line 91
::exit(___);}
#if 0
#line 89
{ 
#line 90
return __illAtomicMax(address, val); 
#line 91
} 
#endif
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicMin(unsigned __int64 *address, unsigned __int64 val) 
#line 94
{int volatile ___ = 1;(void)address;(void)val;
#line 96
::exit(___);}
#if 0
#line 94
{ 
#line 95
return __ullAtomicMin(address, val); 
#line 96
} 
#endif
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicMax(unsigned __int64 *address, unsigned __int64 val) 
#line 99
{int volatile ___ = 1;(void)address;(void)val;
#line 101
::exit(___);}
#if 0
#line 99
{ 
#line 100
return __ullAtomicMax(address, val); 
#line 101
} 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicAnd(unsigned __int64 *address, unsigned __int64 val) 
#line 104
{int volatile ___ = 1;(void)address;(void)val;
#line 106
::exit(___);}
#if 0
#line 104
{ 
#line 105
return __ullAtomicAnd(address, val); 
#line 106
} 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicOr(unsigned __int64 *address, unsigned __int64 val) 
#line 109
{int volatile ___ = 1;(void)address;(void)val;
#line 111
::exit(___);}
#if 0
#line 109
{ 
#line 110
return __ullAtomicOr(address, val); 
#line 111
} 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicXor(unsigned __int64 *address, unsigned __int64 val) 
#line 114
{int volatile ___ = 1;(void)address;(void)val;
#line 116
::exit(___);}
#if 0
#line 114
{ 
#line 115
return __ullAtomicXor(address, val); 
#line 116
} 
#endif
#line 407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"
static __inline unsigned ballot(bool pred) 
#line 408
{int volatile ___ = 1;(void)pred;
#line 410
::exit(___);}
#if 0
#line 408
{ 
#line 409
return __ballot((int)pred); 
#line 410
} 
#endif
#line 412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"
static __inline int syncthreads_count(bool pred) 
#line 413
{int volatile ___ = 1;(void)pred;
#line 415
::exit(___);}
#if 0
#line 413
{ 
#line 414
return __syncthreads_count((int)pred); 
#line 415
} 
#endif
#line 417 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"
static __inline bool syncthreads_and(bool pred) 
#line 418
{int volatile ___ = 1;(void)pred;
#line 420
::exit(___);}
#if 0
#line 418
{ 
#line 419
return (bool)__syncthreads_and((int)pred); 
#line 420
} 
#endif
#line 422 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"
static __inline bool syncthreads_or(bool pred) 
#line 423
{int volatile ___ = 1;(void)pred;
#line 425
::exit(___);}
#if 0
#line 423
{ 
#line 424
return (bool)__syncthreads_or((int)pred); 
#line 425
} 
#endif
#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"
static __inline unsigned __isGlobal(const void *ptr) 
#line 431
{int volatile ___ = 1;(void)ptr;
#line 444 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"
::exit(___);}
#if 0
#line 431 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"
{ 
#line 432
unsigned ret; 
#line 433
__asm { 
	    .reg .pred p; 
	    isspacep.global p, %1; 
	    selp.u32 %0, 1, 0, p;  
	} 
	
#line 443 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_20_intrinsics.h"
return ret; 
#line 444
} 
#endif
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"
static __inline int __shfl(int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
#line 98
::exit(___);}
#if 0
#line 93
{ 
#line 94
int ret, c; 
#line 95
c = (((32 - width) << 8) | 31); 
#line 96
__asm shfl.idx.b32 %0, %1, %2, %3;
return ret; 
#line 98
} 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"
static __inline int __shfl_up(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 105
::exit(___);}
#if 0
#line 100
{ 
#line 101
int ret, c; 
#line 102
c = ((32 - width) << 8); 
#line 103
__asm shfl.up.b32 %0, %1, %2, %3;
return ret; 
#line 105
} 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"
static __inline int __shfl_down(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 112
::exit(___);}
#if 0
#line 107
{ 
#line 108
int ret, c; 
#line 109
c = (((32 - width) << 8) | 31); 
#line 110
__asm shfl.down.b32 %0, %1, %2, %3;
return ret; 
#line 112
} 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"
static __inline int __shfl_xor(int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
#line 119
::exit(___);}
#if 0
#line 114
{ 
#line 115
int ret, c; 
#line 116
c = (((32 - width) << 8) | 31); 
#line 117
__asm shfl.bfly.b32 %0, %1, %2, %3;
return ret; 
#line 119
} 
#endif
#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"
static __inline float __shfl(float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
#line 127
::exit(___);}
#if 0
#line 121
{ 
#line 122
float ret; 
#line 123
int c; 
#line 124
c = (((32 - width) << 8) | 31); 
#line 125
__asm shfl.idx.b32 %0, %1, %2, %3;
return ret; 
#line 127
} 
#endif
#line 129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"
static __inline float __shfl_up(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 135
::exit(___);}
#if 0
#line 129
{ 
#line 130
float ret; 
#line 131
int c; 
#line 132
c = ((32 - width) << 8); 
#line 133
__asm shfl.up.b32 %0, %1, %2, %3;
return ret; 
#line 135
} 
#endif
#line 137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"
static __inline float __shfl_down(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 143
::exit(___);}
#if 0
#line 137
{ 
#line 138
float ret; 
#line 139
int c; 
#line 140
c = (((32 - width) << 8) | 31); 
#line 141
__asm shfl.down.b32 %0, %1, %2, %3;
return ret; 
#line 143
} 
#endif
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_30_intrinsics.h"
static __inline float __shfl_xor(float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
#line 151
::exit(___);}
#if 0
#line 145
{ 
#line 146
float ret; 
#line 147
int c; 
#line 148
c = (((32 - width) << 8) | 31); 
#line 149
__asm shfl.bfly.b32 %0, %1, %2, %3;
return ret; 
#line 151
} 
#endif
#line 91 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline char __ldg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 91
{ unsigned ret; __asm ld.global.nc.s8 %0, [%1];
#line 91
return (char)ret; } 
#endif
#line 92 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline short __ldg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 92
{ unsigned short ret; __asm ld.global.nc.s16 %0, [%1];
#line 92
return (short)ret; } 
#endif
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline int __ldg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 93
{ unsigned ret; __asm ld.global.nc.s32 %0, [%1];
#line 93
return (int)ret; } 
#endif
#line 94 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldg(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 94
{ unsigned __int64 ret; __asm ld.global.nc.s64 %0, [%1];
#line 94
return (__int64)ret; } 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline char2 __ldg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 95
{ char2 ret; int2 tmp; __asm ld.global.nc.v2.s8 {%0,%1}, [%2];
#line 95
(ret.x) = ((char)(tmp.x)); (ret.y) = ((char)(tmp.y)); return ret; } 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline char4 __ldg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 96
{ char4 ret; int4 tmp; __asm ld.global.nc.v4.s8 {%0,%1,%2,%3}, [%4];
#line 96
(ret.x) = ((char)(tmp.x)); (ret.y) = ((char)(tmp.y)); (ret.z) = ((char)(tmp.z)); (ret.w) = ((char)(tmp.w)); return ret; } 
#endif
#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline short2 __ldg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 97
{ short2 ret; __asm ld.global.nc.v2.s16 {%0,%1}, [%2];
#line 97
return ret; } 
#endif
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline short4 __ldg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 98
{ short4 ret; __asm ld.global.nc.v4.s16 {%0,%1,%2,%3}, [%4];
#line 98
return ret; } 
#endif
#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline int2 __ldg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 99
{ int2 ret; __asm ld.global.nc.v2.s32 {%0,%1}, [%2];
#line 99
return ret; } 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline int4 __ldg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 100
{ int4 ret; __asm ld.global.nc.v4.s32 {%0,%1,%2,%3}, [%4];
#line 100
return ret; } 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 101
{ longlong2 ret; __asm ld.global.nc.v2.s64 %0, [%1];
#line 101
return ret; } 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 103
{ unsigned ret; __asm ld.global.nc.u8 %0, [%1];
#line 103
return (unsigned char)ret; } 
#endif
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 104
{ unsigned short ret; __asm ld.global.nc.u16 %0, [%1];
#line 104
return ret; } 
#endif
#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 105
{ unsigned ret; __asm ld.global.nc.u32 %0, [%1];
#line 105
return ret; } 
#endif
#line 106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldg(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 106
{ unsigned __int64 ret; __asm ld.global.nc.u64 %0, [%1];
#line 106
return ret; } 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 107
{ uchar2 ret; uint2 tmp; __asm ld.global.nc.v2.u8 {%0,%1}, [%2];
#line 107
(ret.x) = ((unsigned char)(tmp.x)); (ret.y) = ((unsigned char)(tmp.y)); return ret; } 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 108
{ uchar4 ret; uint4 tmp; __asm ld.global.nc.v4.u8 {%0,%1,%2,%3}, [%4];
#line 108
(ret.x) = ((unsigned char)(tmp.x)); (ret.y) = ((unsigned char)(tmp.y)); (ret.z) = ((unsigned char)(tmp.z)); (ret.w) = ((unsigned char)(tmp.w)); return ret; } 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 109
{ ushort2 ret; __asm ld.global.nc.v2.u16 {%0,%1}, [%2];
#line 109
return ret; } 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 110
{ ushort4 ret; __asm ld.global.nc.v4.u16 {%0,%1,%2,%3}, [%4];
#line 110
return ret; } 
#endif
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 111
{ uint2 ret; __asm ld.global.nc.v2.u32 {%0,%1}, [%2];
#line 111
return ret; } 
#endif
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 112
{ uint4 ret; __asm ld.global.nc.v4.u32 {%0,%1,%2,%3}, [%4];
#line 112
return ret; } 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 113
{ ulonglong2 ret; __asm ld.global.nc.v2.u64 %0, [%1];
#line 113
return ret; } 
#endif
#line 115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline float __ldg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 115
{ float ret; __asm ld.global.nc.f32 %0, [%1];
#line 115
return ret; } 
#endif
#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline double __ldg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 116
{ double ret; __asm ld.global.nc.f64 %0, [%1];
#line 116
return ret; } 
#endif
#line 117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline float2 __ldg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 117
{ float2 ret; __asm ld.global.nc.v2.f32 {%0,%1}, [%2];
#line 117
return ret; } 
#endif
#line 118 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline float4 __ldg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 118
{ float4 ret; __asm ld.global.nc.v4.f32 {%0,%1,%2,%3}, [%4];
#line 118
return ret; } 
#endif
#line 119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static __inline double2 __ldg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 119
{ double2 ret; __asm ld.global.nc.v2.f64 {%0,%1}, [%2];
#line 119
return ret; } 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift) 
#line 131
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
#line 135
::exit(___);}
#if 0
#line 131
{ 
#line 132
unsigned ret; 
#line 133
__asm shf.l.wrap.b32 %0, %1, %2, %3;
return ret; 
#line 135
} 
#endif
#line 136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift) 
#line 137
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
#line 141
::exit(___);}
#if 0
#line 137
{ 
#line 138
unsigned ret; 
#line 139
__asm shf.l.clamp.b32 %0, %1, %2, %3;
return ret; 
#line 141
} 
#endif
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift) 
#line 145
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
#line 149
::exit(___);}
#if 0
#line 145
{ 
#line 146
unsigned ret; 
#line 147
__asm shf.r.wrap.b32 %0, %1, %2, %3;
return ret; 
#line 149
} 
#endif
#line 150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\sm_32_intrinsics.h"
static inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift) 
#line 151
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
#line 155
::exit(___);}
#if 0
#line 151
{ 
#line 152
unsigned ret; 
#line 153
__asm shf.r.clamp.b32 %0, %1, %2, %3;
return ret; 
#line 155
} 
#endif
#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 100
surf1Dread(T *res, ::surface< void, 1>  surf, int x, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 101
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)s;(void)mode;
#line 108
::exit(___);}
#if 0
#line 101
{ 
#line 102
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surf1Dreadc1(surf, x, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surf1Dreads1(surf, x, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surf1Dreadu1(surf, x, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 108
} 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 111
surf1Dread(::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 112
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 118
::exit(___);}
#if 0
#line 112
{ 
#line 113
T tmp; 
#line 115
surf1Dread(&tmp, surf, x, (int)sizeof(T), mode); 
#line 117
return tmp; 
#line 118
} 
#endif
#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 121
surf1Dread(T *res, ::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 122
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)mode;
#line 124
::exit(___);}
#if 0
#line 122
{ 
#line 123
(*res) = surf1Dread< T> (surf, x, mode); 
#line 124
} 
#endif
#line 127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 128
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 130
::exit(___);}
#if 0
#line 128
{ 
#line 129
return (char)((__surf1Dreadc1(surf, x, cudaBoundaryModeTrap)).x); 
#line 130
} 
#endif
#line 133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline signed char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 134
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 136
::exit(___);}
#if 0
#line 134
{ 
#line 135
return (signed char)((__surf1Dreadc1(surf, x, cudaBoundaryModeTrap)).x); 
#line 136
} 
#endif
#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 140
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 142
::exit(___);}
#if 0
#line 140
{ 
#line 141
return (__surf1Dreadc1(surf, x, cudaBoundaryModeTrap)).x; 
#line 142
} 
#endif
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 146
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 148
::exit(___);}
#if 0
#line 146
{ 
#line 147
return make_char1((signed char)((__surf1Dreadc1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 148
} 
#endif
#line 151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 152
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 154
::exit(___);}
#if 0
#line 152
{ 
#line 153
return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap); 
#line 154
} 
#endif
#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 158
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 162
::exit(___);}
#if 0
#line 158
{ 
#line 159
uchar2 tmp = __surf1Dreadc2(surf, x, cudaBoundaryModeTrap); 
#line 161
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 162
} 
#endif
#line 165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 166
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 168
::exit(___);}
#if 0
#line 166
{ 
#line 167
return __surf1Dreadc2(surf, x, cudaBoundaryModeTrap); 
#line 168
} 
#endif
#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 172
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 176
::exit(___);}
#if 0
#line 172
{ 
#line 173
uchar4 tmp = __surf1Dreadc4(surf, x, cudaBoundaryModeTrap); 
#line 175
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 176
} 
#endif
#line 179 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 180
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 182
::exit(___);}
#if 0
#line 180
{ 
#line 181
return __surf1Dreadc4(surf, x, cudaBoundaryModeTrap); 
#line 182
} 
#endif
#line 185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 186
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 188
::exit(___);}
#if 0
#line 186
{ 
#line 187
return (short)((__surf1Dreads1(surf, x, cudaBoundaryModeTrap)).x); 
#line 188
} 
#endif
#line 191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned short surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 192
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 194
::exit(___);}
#if 0
#line 192
{ 
#line 193
return (__surf1Dreads1(surf, x, cudaBoundaryModeTrap)).x; 
#line 194
} 
#endif
#line 197 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 198
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 200
::exit(___);}
#if 0
#line 198
{ 
#line 199
return make_short1((signed short)((__surf1Dreads1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 200
} 
#endif
#line 203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 204
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 206
::exit(___);}
#if 0
#line 204
{ 
#line 205
return __surf1Dreads1(surf, x, cudaBoundaryModeTrap); 
#line 206
} 
#endif
#line 209 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 210
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 214
::exit(___);}
#if 0
#line 210
{ 
#line 211
ushort2 tmp = __surf1Dreads2(surf, x, cudaBoundaryModeTrap); 
#line 213
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 214
} 
#endif
#line 217 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 218
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 220
::exit(___);}
#if 0
#line 218
{ 
#line 219
return __surf1Dreads2(surf, x, cudaBoundaryModeTrap); 
#line 220
} 
#endif
#line 223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 224
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 228
::exit(___);}
#if 0
#line 224
{ 
#line 225
ushort4 tmp = __surf1Dreads4(surf, x, cudaBoundaryModeTrap); 
#line 227
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 228
} 
#endif
#line 231 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 232
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 234
::exit(___);}
#if 0
#line 232
{ 
#line 233
return __surf1Dreads4(surf, x, cudaBoundaryModeTrap); 
#line 234
} 
#endif
#line 237 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 238
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 240
::exit(___);}
#if 0
#line 238
{ 
#line 239
return (int)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x); 
#line 240
} 
#endif
#line 243 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 244
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 246
::exit(___);}
#if 0
#line 244
{ 
#line 245
return (__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x; 
#line 246
} 
#endif
#line 249 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 250
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 252
::exit(___);}
#if 0
#line 250
{ 
#line 251
return make_int1((signed int)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 252
} 
#endif
#line 255 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 256
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 258
::exit(___);}
#if 0
#line 256
{ 
#line 257
return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap); 
#line 258
} 
#endif
#line 261 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 262
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 266
::exit(___);}
#if 0
#line 262
{ 
#line 263
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 265
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 266
} 
#endif
#line 269 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 270
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 272
::exit(___);}
#if 0
#line 270
{ 
#line 271
return __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 272
} 
#endif
#line 275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 276
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 280
::exit(___);}
#if 0
#line 276
{ 
#line 277
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 279
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 280
} 
#endif
#line 283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 284
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 286
::exit(___);}
#if 0
#line 284
{ 
#line 285
return __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 286
} 
#endif
#line 289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline __int64 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 290
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 292
::exit(___);}
#if 0
#line 290
{ 
#line 291
return (__int64)((__surf1Dreadl1(surf, x, cudaBoundaryModeTrap)).x); 
#line 292
} 
#endif
#line 295 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 296
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 298
::exit(___);}
#if 0
#line 296
{ 
#line 297
return (__surf1Dreadl1(surf, x, cudaBoundaryModeTrap)).x; 
#line 298
} 
#endif
#line 301 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 302
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 304
::exit(___);}
#if 0
#line 302
{ 
#line 303
return make_longlong1((__int64)((__surf1Dreadl1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 304
} 
#endif
#line 307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 308
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 310
::exit(___);}
#if 0
#line 308
{ 
#line 309
return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap); 
#line 310
} 
#endif
#line 313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 314
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 318
::exit(___);}
#if 0
#line 314
{ 
#line 315
ulonglong2 tmp = __surf1Dreadl2(surf, x, cudaBoundaryModeTrap); 
#line 317
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 318
} 
#endif
#line 321 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 322
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 324
::exit(___);}
#if 0
#line 322
{ 
#line 323
return __surf1Dreadl2(surf, x, cudaBoundaryModeTrap); 
#line 324
} 
#endif
#line 329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 330
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 332
::exit(___);}
#if 0
#line 330
{ 
#line 331
return (long)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x); 
#line 332
} 
#endif
#line 335 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned long surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 336
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 338
::exit(___);}
#if 0
#line 336
{ 
#line 337
return (unsigned long)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x); 
#line 338
} 
#endif
#line 341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 342
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 344
::exit(___);}
#if 0
#line 342
{ 
#line 343
return make_long1((long)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 344
} 
#endif
#line 347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 348
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 350
::exit(___);}
#if 0
#line 348
{ 
#line 349
return make_ulong1((unsigned long)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 350
} 
#endif
#line 353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 354
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 358
::exit(___);}
#if 0
#line 354
{ 
#line 355
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 357
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 358
} 
#endif
#line 361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 362
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 366
::exit(___);}
#if 0
#line 362
{ 
#line 363
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 365
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 366
} 
#endif
#line 369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 370
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 374
::exit(___);}
#if 0
#line 370
{ 
#line 371
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 373
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 374
} 
#endif
#line 377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 378
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 382
::exit(___);}
#if 0
#line 378
{ 
#line 379
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 381
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 382
} 
#endif
#line 387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 388
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 390
::exit(___);}
#if 0
#line 388
{ 
#line 389
return __int_as_float((int)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 390
} 
#endif
#line 393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 394
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 396
::exit(___);}
#if 0
#line 394
{ 
#line 395
return make_float1(__int_as_float((int)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x))); 
#line 396
} 
#endif
#line 399 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 400
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 404
::exit(___);}
#if 0
#line 400
{ 
#line 401
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 403
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 404
} 
#endif
#line 407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 408
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 412
::exit(___);}
#if 0
#line 408
{ 
#line 409
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 411
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 412
} 
#endif
#line 447 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 448
surf2Dread(T *res, ::surface< void, 2>  surf, int x, int y, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 449
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)s;(void)mode;
#line 456
::exit(___);}
#if 0
#line 449
{ 
#line 450
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 456
} 
#endif
#line 458 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 459
surf2Dread(::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 460
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 466
::exit(___);}
#if 0
#line 460
{ 
#line 461
T tmp; 
#line 463
surf2Dread(&tmp, surf, x, y, (int)sizeof(T), mode); 
#line 465
return tmp; 
#line 466
} 
#endif
#line 468 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 469
surf2Dread(T *res, ::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 470
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)mode;
#line 472
::exit(___);}
#if 0
#line 470
{ 
#line 471
(*res) = surf2Dread< T> (surf, x, y, mode); 
#line 472
} 
#endif
#line 475 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 476
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 478
::exit(___);}
#if 0
#line 476
{ 
#line 477
return (char)((__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 478
} 
#endif
#line 481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline signed char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 482
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 484
::exit(___);}
#if 0
#line 482
{ 
#line 483
return (signed char)((__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 484
} 
#endif
#line 487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 488
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 490
::exit(___);}
#if 0
#line 488
{ 
#line 489
return (__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)).x; 
#line 490
} 
#endif
#line 493 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 494
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 496
::exit(___);}
#if 0
#line 494
{ 
#line 495
return make_char1((signed char)((__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 496
} 
#endif
#line 499 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 500
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 502
::exit(___);}
#if 0
#line 500
{ 
#line 501
return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap); 
#line 502
} 
#endif
#line 505 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 506
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 510
::exit(___);}
#if 0
#line 506
{ 
#line 507
uchar2 tmp = __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap); 
#line 509
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 510
} 
#endif
#line 513 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 514
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 516
::exit(___);}
#if 0
#line 514
{ 
#line 515
return __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap); 
#line 516
} 
#endif
#line 519 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 520
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 524
::exit(___);}
#if 0
#line 520
{ 
#line 521
uchar4 tmp = __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap); 
#line 523
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 524
} 
#endif
#line 527 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 528
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 530
::exit(___);}
#if 0
#line 528
{ 
#line 529
return __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap); 
#line 530
} 
#endif
#line 533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 534
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 536
::exit(___);}
#if 0
#line 534
{ 
#line 535
return (short)((__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 536
} 
#endif
#line 539 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned short surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 540
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 542
::exit(___);}
#if 0
#line 540
{ 
#line 541
return (__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)).x; 
#line 542
} 
#endif
#line 545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 546
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 548
::exit(___);}
#if 0
#line 546
{ 
#line 547
return make_short1((signed short)((__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 548
} 
#endif
#line 551 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 552
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 554
::exit(___);}
#if 0
#line 552
{ 
#line 553
return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap); 
#line 554
} 
#endif
#line 557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 558
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 562
::exit(___);}
#if 0
#line 558
{ 
#line 559
ushort2 tmp = __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap); 
#line 561
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 562
} 
#endif
#line 565 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 566
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 568
::exit(___);}
#if 0
#line 566
{ 
#line 567
return __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap); 
#line 568
} 
#endif
#line 571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 572
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 576
::exit(___);}
#if 0
#line 572
{ 
#line 573
ushort4 tmp = __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap); 
#line 575
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 576
} 
#endif
#line 579 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 580
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 582
::exit(___);}
#if 0
#line 580
{ 
#line 581
return __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap); 
#line 582
} 
#endif
#line 585 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 586
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 588
::exit(___);}
#if 0
#line 586
{ 
#line 587
return (int)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 588
} 
#endif
#line 591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 592
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 594
::exit(___);}
#if 0
#line 592
{ 
#line 593
return (__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x; 
#line 594
} 
#endif
#line 597 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 598
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 600
::exit(___);}
#if 0
#line 598
{ 
#line 599
return make_int1((signed int)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 600
} 
#endif
#line 603 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 604
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 606
::exit(___);}
#if 0
#line 604
{ 
#line 605
return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap); 
#line 606
} 
#endif
#line 609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 610
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 614
::exit(___);}
#if 0
#line 610
{ 
#line 611
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 613
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 614
} 
#endif
#line 617 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 618
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 620
::exit(___);}
#if 0
#line 618
{ 
#line 619
return __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 620
} 
#endif
#line 623 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 624
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 628
::exit(___);}
#if 0
#line 624
{ 
#line 625
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 627
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 628
} 
#endif
#line 631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 632
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 634
::exit(___);}
#if 0
#line 632
{ 
#line 633
return __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 634
} 
#endif
#line 637 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline __int64 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 638
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 640
::exit(___);}
#if 0
#line 638
{ 
#line 639
return (__int64)((__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 640
} 
#endif
#line 643 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 644
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 646
::exit(___);}
#if 0
#line 644
{ 
#line 645
return (__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap)).x; 
#line 646
} 
#endif
#line 649 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 650
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 652
::exit(___);}
#if 0
#line 650
{ 
#line 651
return make_longlong1((__int64)((__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 652
} 
#endif
#line 655 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 656
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 658
::exit(___);}
#if 0
#line 656
{ 
#line 657
return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap); 
#line 658
} 
#endif
#line 661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 662
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 666
::exit(___);}
#if 0
#line 662
{ 
#line 663
ulonglong2 tmp = __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap); 
#line 665
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 666
} 
#endif
#line 669 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 670
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 672
::exit(___);}
#if 0
#line 670
{ 
#line 671
return __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap); 
#line 672
} 
#endif
#line 677 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 678
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 680
::exit(___);}
#if 0
#line 678
{ 
#line 679
return (long)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 680
} 
#endif
#line 683 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned long surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 684
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 686
::exit(___);}
#if 0
#line 684
{ 
#line 685
return (unsigned long)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 686
} 
#endif
#line 689 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 690
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 692
::exit(___);}
#if 0
#line 690
{ 
#line 691
return make_long1((long)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 692
} 
#endif
#line 695 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 696
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 698
::exit(___);}
#if 0
#line 696
{ 
#line 697
return make_ulong1((unsigned long)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 698
} 
#endif
#line 701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 702
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 706
::exit(___);}
#if 0
#line 702
{ 
#line 703
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 705
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 706
} 
#endif
#line 709 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 710
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 714
::exit(___);}
#if 0
#line 710
{ 
#line 711
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 713
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 714
} 
#endif
#line 717 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 718
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 722
::exit(___);}
#if 0
#line 718
{ 
#line 719
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 721
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 722
} 
#endif
#line 725 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 726
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 730
::exit(___);}
#if 0
#line 726
{ 
#line 727
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 729
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 730
} 
#endif
#line 735 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 736
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 738
::exit(___);}
#if 0
#line 736
{ 
#line 737
return __int_as_float((int)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 738
} 
#endif
#line 741 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 742
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 744
::exit(___);}
#if 0
#line 742
{ 
#line 743
return make_float1(__int_as_float((int)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x))); 
#line 744
} 
#endif
#line 747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 748
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 752
::exit(___);}
#if 0
#line 748
{ 
#line 749
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 751
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 752
} 
#endif
#line 755 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 756
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 760
::exit(___);}
#if 0
#line 756
{ 
#line 757
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 759
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 760
} 
#endif
#line 795 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 796
surf3Dread(T *res, ::surface< void, 3>  surf, int x, int y, int z, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 797
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
#line 804
::exit(___);}
#if 0
#line 797
{ 
#line 798
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 804
} 
#endif
#line 806 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 807
surf3Dread(::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 808
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 814
::exit(___);}
#if 0
#line 808
{ 
#line 809
T tmp; 
#line 811
surf3Dread(&tmp, surf, x, y, z, (int)sizeof(T), mode); 
#line 813
return tmp; 
#line 814
} 
#endif
#line 816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 817
surf3Dread(T *res, ::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 818
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 820
::exit(___);}
#if 0
#line 818
{ 
#line 819
(*res) = surf3Dread< T> (surf, x, y, z, mode); 
#line 820
} 
#endif
#line 823 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 824
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 826
::exit(___);}
#if 0
#line 824
{ 
#line 825
return (char)((__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 826
} 
#endif
#line 829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline signed char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 830
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 832
::exit(___);}
#if 0
#line 830
{ 
#line 831
return (signed char)((__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 832
} 
#endif
#line 835 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 836
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 838
::exit(___);}
#if 0
#line 836
{ 
#line 837
return (__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)).x; 
#line 838
} 
#endif
#line 841 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 842
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 844
::exit(___);}
#if 0
#line 842
{ 
#line 843
return make_char1((signed char)((__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 844
} 
#endif
#line 847 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 848
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 850
::exit(___);}
#if 0
#line 848
{ 
#line 849
return __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap); 
#line 850
} 
#endif
#line 853 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 854
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 858
::exit(___);}
#if 0
#line 854
{ 
#line 855
uchar2 tmp = __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 857
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 858
} 
#endif
#line 861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 862
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 864
::exit(___);}
#if 0
#line 862
{ 
#line 863
return __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 864
} 
#endif
#line 867 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 868
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 872
::exit(___);}
#if 0
#line 868
{ 
#line 869
uchar4 tmp = __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 871
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 872
} 
#endif
#line 875 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 876
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 878
::exit(___);}
#if 0
#line 876
{ 
#line 877
return __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 878
} 
#endif
#line 881 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 882
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 884
::exit(___);}
#if 0
#line 882
{ 
#line 883
return (short)((__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 884
} 
#endif
#line 887 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned short surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 888
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 890
::exit(___);}
#if 0
#line 888
{ 
#line 889
return (__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)).x; 
#line 890
} 
#endif
#line 893 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 894
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 896
::exit(___);}
#if 0
#line 894
{ 
#line 895
return make_short1((signed short)((__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 896
} 
#endif
#line 899 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 900
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 902
::exit(___);}
#if 0
#line 900
{ 
#line 901
return __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap); 
#line 902
} 
#endif
#line 905 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 906
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 910
::exit(___);}
#if 0
#line 906
{ 
#line 907
ushort2 tmp = __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 909
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 910
} 
#endif
#line 913 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 914
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 916
::exit(___);}
#if 0
#line 914
{ 
#line 915
return __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 916
} 
#endif
#line 919 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 920
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 924
::exit(___);}
#if 0
#line 920
{ 
#line 921
ushort4 tmp = __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 923
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 924
} 
#endif
#line 927 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 928
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 930
::exit(___);}
#if 0
#line 928
{ 
#line 929
return __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 930
} 
#endif
#line 933 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 934
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 936
::exit(___);}
#if 0
#line 934
{ 
#line 935
return (int)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 936
} 
#endif
#line 939 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 940
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 942
::exit(___);}
#if 0
#line 940
{ 
#line 941
return (__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x; 
#line 942
} 
#endif
#line 945 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 946
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 948
::exit(___);}
#if 0
#line 946
{ 
#line 947
return make_int1((signed int)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 948
} 
#endif
#line 951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 952
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 954
::exit(___);}
#if 0
#line 952
{ 
#line 953
return __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap); 
#line 954
} 
#endif
#line 957 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 958
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 962
::exit(___);}
#if 0
#line 958
{ 
#line 959
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 961
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 962
} 
#endif
#line 965 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 966
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 968
::exit(___);}
#if 0
#line 966
{ 
#line 967
return __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 968
} 
#endif
#line 971 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 972
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 976
::exit(___);}
#if 0
#line 972
{ 
#line 973
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 975
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 976
} 
#endif
#line 979 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 980
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 982
::exit(___);}
#if 0
#line 980
{ 
#line 981
return __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 982
} 
#endif
#line 985 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline __int64 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 986
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 988
::exit(___);}
#if 0
#line 986
{ 
#line 987
return (__int64)((__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 988
} 
#endif
#line 991 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 992
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 994
::exit(___);}
#if 0
#line 992
{ 
#line 993
return (__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap)).x; 
#line 994
} 
#endif
#line 997 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 998
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1000
::exit(___);}
#if 0
#line 998
{ 
#line 999
return make_longlong1((__int64)((__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 1000
} 
#endif
#line 1003 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1004
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1006
::exit(___);}
#if 0
#line 1004
{ 
#line 1005
return __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1006
} 
#endif
#line 1009 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1010
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1014
::exit(___);}
#if 0
#line 1010
{ 
#line 1011
ulonglong2 tmp = __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1013
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 1014
} 
#endif
#line 1017 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1018
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1020
::exit(___);}
#if 0
#line 1018
{ 
#line 1019
return __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1020
} 
#endif
#line 1025 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1026
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1028
::exit(___);}
#if 0
#line 1026
{ 
#line 1027
return (long)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 1028
} 
#endif
#line 1031 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned long surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1032
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1034
::exit(___);}
#if 0
#line 1032
{ 
#line 1033
return (unsigned long)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 1034
} 
#endif
#line 1037 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1038
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1040
::exit(___);}
#if 0
#line 1038
{ 
#line 1039
return make_long1((long)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 1040
} 
#endif
#line 1043 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1044
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1046
::exit(___);}
#if 0
#line 1044
{ 
#line 1045
return make_ulong1((unsigned long)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 1046
} 
#endif
#line 1049 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1050
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1054
::exit(___);}
#if 0
#line 1050
{ 
#line 1051
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1053
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 1054
} 
#endif
#line 1057 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1058
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1062
::exit(___);}
#if 0
#line 1058
{ 
#line 1059
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1061
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 1062
} 
#endif
#line 1065 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1066
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1070
::exit(___);}
#if 0
#line 1066
{ 
#line 1067
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1069
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 1070
} 
#endif
#line 1073 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1074
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1078
::exit(___);}
#if 0
#line 1074
{ 
#line 1075
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1077
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 1078
} 
#endif
#line 1083 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1084
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1086
::exit(___);}
#if 0
#line 1084
{ 
#line 1085
return __int_as_float((int)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 1086
} 
#endif
#line 1089 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1090
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1092
::exit(___);}
#if 0
#line 1090
{ 
#line 1091
return make_float1(__int_as_float((int)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x))); 
#line 1092
} 
#endif
#line 1095 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1096
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1100
::exit(___);}
#if 0
#line 1096
{ 
#line 1097
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1099
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 1100
} 
#endif
#line 1103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1104
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1108
::exit(___);}
#if 0
#line 1104
{ 
#line 1105
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1107
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 1108
} 
#endif
#line 1143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1144
surf1DLayeredread(T *res, ::surface< void, 241>  surf, int x, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1145
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
#line 1152
::exit(___);}
#if 0
#line 1145
{ 
#line 1146
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 1152
} 
#endif
#line 1154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 1155
surf1DLayeredread(::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1156
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1162
::exit(___);}
#if 0
#line 1156
{ 
#line 1157
T tmp; 
#line 1159
surf1DLayeredread(&tmp, surf, x, layer, (int)sizeof(T), mode); 
#line 1161
return tmp; 
#line 1162
} 
#endif
#line 1164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1165
surf1DLayeredread(T *res, ::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1166
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)mode;
#line 1168
::exit(___);}
#if 0
#line 1166
{ 
#line 1167
(*res) = surf1DLayeredread< T> (surf, x, layer, mode); 
#line 1168
} 
#endif
#line 1171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1172
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1174
::exit(___);}
#if 0
#line 1172
{ 
#line 1173
return (char)((__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1174
} 
#endif
#line 1177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline signed char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1178
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1180
::exit(___);}
#if 0
#line 1178
{ 
#line 1179
return (signed char)((__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1180
} 
#endif
#line 1183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1184
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1186
::exit(___);}
#if 0
#line 1184
{ 
#line 1185
return (__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)).x; 
#line 1186
} 
#endif
#line 1189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1190
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1192
::exit(___);}
#if 0
#line 1190
{ 
#line 1191
return make_char1((signed char)((__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1192
} 
#endif
#line 1195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1196
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1198
::exit(___);}
#if 0
#line 1196
{ 
#line 1197
return __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap); 
#line 1198
} 
#endif
#line 1201 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1202
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1206
::exit(___);}
#if 0
#line 1202
{ 
#line 1203
uchar2 tmp = __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1205
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 1206
} 
#endif
#line 1209 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1210
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1212
::exit(___);}
#if 0
#line 1210
{ 
#line 1211
return __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1212
} 
#endif
#line 1215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1216
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1220
::exit(___);}
#if 0
#line 1216
{ 
#line 1217
uchar4 tmp = __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1219
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 1220
} 
#endif
#line 1223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1224
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1226
::exit(___);}
#if 0
#line 1224
{ 
#line 1225
return __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1226
} 
#endif
#line 1229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1230
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1232
::exit(___);}
#if 0
#line 1230
{ 
#line 1231
return (short)((__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1232
} 
#endif
#line 1235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned short surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1236
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1238
::exit(___);}
#if 0
#line 1236
{ 
#line 1237
return (__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)).x; 
#line 1238
} 
#endif
#line 1241 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1242
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1244
::exit(___);}
#if 0
#line 1242
{ 
#line 1243
return make_short1((signed short)((__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1244
} 
#endif
#line 1247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1248
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1250
::exit(___);}
#if 0
#line 1248
{ 
#line 1249
return __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap); 
#line 1250
} 
#endif
#line 1253 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1254
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1258
::exit(___);}
#if 0
#line 1254
{ 
#line 1255
ushort2 tmp = __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1257
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 1258
} 
#endif
#line 1261 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1262
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1264
::exit(___);}
#if 0
#line 1262
{ 
#line 1263
return __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1264
} 
#endif
#line 1267 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1268
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1272
::exit(___);}
#if 0
#line 1268
{ 
#line 1269
ushort4 tmp = __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1271
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 1272
} 
#endif
#line 1275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1276
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1278
::exit(___);}
#if 0
#line 1276
{ 
#line 1277
return __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1278
} 
#endif
#line 1281 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1282
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1284
::exit(___);}
#if 0
#line 1282
{ 
#line 1283
return (int)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1284
} 
#endif
#line 1287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1288
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1290
::exit(___);}
#if 0
#line 1288
{ 
#line 1289
return (__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x; 
#line 1290
} 
#endif
#line 1293 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1294
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1296
::exit(___);}
#if 0
#line 1294
{ 
#line 1295
return make_int1((signed int)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1296
} 
#endif
#line 1299 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1300
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1302
::exit(___);}
#if 0
#line 1300
{ 
#line 1301
return __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap); 
#line 1302
} 
#endif
#line 1305 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1306
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1310
::exit(___);}
#if 0
#line 1306
{ 
#line 1307
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1309
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 1310
} 
#endif
#line 1313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1314
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1316
::exit(___);}
#if 0
#line 1314
{ 
#line 1315
return __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1316
} 
#endif
#line 1319 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1320
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1324
::exit(___);}
#if 0
#line 1320
{ 
#line 1321
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1323
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 1324
} 
#endif
#line 1327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1328
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1330
::exit(___);}
#if 0
#line 1328
{ 
#line 1329
return __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1330
} 
#endif
#line 1333 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline __int64 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1334
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1336
::exit(___);}
#if 0
#line 1334
{ 
#line 1335
return (__int64)((__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1336
} 
#endif
#line 1339 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1340
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1342
::exit(___);}
#if 0
#line 1340
{ 
#line 1341
return (__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap)).x; 
#line 1342
} 
#endif
#line 1345 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1346
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1348
::exit(___);}
#if 0
#line 1346
{ 
#line 1347
return make_longlong1((__int64)((__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1348
} 
#endif
#line 1351 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1352
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1354
::exit(___);}
#if 0
#line 1352
{ 
#line 1353
return __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap); 
#line 1354
} 
#endif
#line 1357 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1358
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1362
::exit(___);}
#if 0
#line 1358
{ 
#line 1359
ulonglong2 tmp = __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1361
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 1362
} 
#endif
#line 1365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1366
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1368
::exit(___);}
#if 0
#line 1366
{ 
#line 1367
return __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1368
} 
#endif
#line 1373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1374
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1376
::exit(___);}
#if 0
#line 1374
{ 
#line 1375
return (long)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1376
} 
#endif
#line 1379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned long surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1380
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1382
::exit(___);}
#if 0
#line 1380
{ 
#line 1381
return (unsigned long)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1382
} 
#endif
#line 1385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1386
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1388
::exit(___);}
#if 0
#line 1386
{ 
#line 1387
return make_long1((long)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1388
} 
#endif
#line 1391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1392
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1394
::exit(___);}
#if 0
#line 1392
{ 
#line 1393
return make_ulong1((unsigned long)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1394
} 
#endif
#line 1397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1398
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1402
::exit(___);}
#if 0
#line 1398
{ 
#line 1399
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1401
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 1402
} 
#endif
#line 1405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1406
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1410
::exit(___);}
#if 0
#line 1406
{ 
#line 1407
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1409
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 1410
} 
#endif
#line 1413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1414
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1418
::exit(___);}
#if 0
#line 1414
{ 
#line 1415
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1417
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 1418
} 
#endif
#line 1421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1422
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1426
::exit(___);}
#if 0
#line 1422
{ 
#line 1423
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1425
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 1426
} 
#endif
#line 1431 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1432
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1434
::exit(___);}
#if 0
#line 1432
{ 
#line 1433
return __int_as_float((int)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1434
} 
#endif
#line 1437 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1438
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1440
::exit(___);}
#if 0
#line 1438
{ 
#line 1439
return make_float1(__int_as_float((int)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x))); 
#line 1440
} 
#endif
#line 1443 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1444
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1448
::exit(___);}
#if 0
#line 1444
{ 
#line 1445
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1447
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 1448
} 
#endif
#line 1451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1452
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1456
::exit(___);}
#if 0
#line 1452
{ 
#line 1453
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1455
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 1456
} 
#endif
#line 1491 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1492
surf2DLayeredread(T *res, ::surface< void, 242>  surf, int x, int y, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1493
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
#line 1500
::exit(___);}
#if 0
#line 1493
{ 
#line 1494
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 1500
} 
#endif
#line 1502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 1503
surf2DLayeredread(::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1504
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1510
::exit(___);}
#if 0
#line 1504
{ 
#line 1505
T tmp; 
#line 1507
surf2DLayeredread(&tmp, surf, x, y, layer, (int)sizeof(T), mode); 
#line 1509
return tmp; 
#line 1510
} 
#endif
#line 1512 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1513
surf2DLayeredread(T *res, ::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1514
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1516
::exit(___);}
#if 0
#line 1514
{ 
#line 1515
(*res) = surf2DLayeredread< T> (surf, x, y, layer, mode); 
#line 1516
} 
#endif
#line 1519 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1520
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1522
::exit(___);}
#if 0
#line 1520
{ 
#line 1521
return (char)((__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1522
} 
#endif
#line 1525 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline signed char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1526
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1528
::exit(___);}
#if 0
#line 1526
{ 
#line 1527
return (signed char)((__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1528
} 
#endif
#line 1531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1532
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1534
::exit(___);}
#if 0
#line 1532
{ 
#line 1533
return (__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)).x; 
#line 1534
} 
#endif
#line 1537 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1538
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1540
::exit(___);}
#if 0
#line 1538
{ 
#line 1539
return make_char1((signed char)((__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1540
} 
#endif
#line 1543 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1544
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1546
::exit(___);}
#if 0
#line 1544
{ 
#line 1545
return __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1546
} 
#endif
#line 1549 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1550
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1554
::exit(___);}
#if 0
#line 1550
{ 
#line 1551
uchar2 tmp = __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1553
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 1554
} 
#endif
#line 1557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1558
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1560
::exit(___);}
#if 0
#line 1558
{ 
#line 1559
return __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1560
} 
#endif
#line 1563 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1564
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1568
::exit(___);}
#if 0
#line 1564
{ 
#line 1565
uchar4 tmp = __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1567
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 1568
} 
#endif
#line 1571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1572
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1574
::exit(___);}
#if 0
#line 1572
{ 
#line 1573
return __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1574
} 
#endif
#line 1577 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1578
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1580
::exit(___);}
#if 0
#line 1578
{ 
#line 1579
return (short)((__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1580
} 
#endif
#line 1583 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned short surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1584
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1586
::exit(___);}
#if 0
#line 1584
{ 
#line 1585
return (__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)).x; 
#line 1586
} 
#endif
#line 1589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1590
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1592
::exit(___);}
#if 0
#line 1590
{ 
#line 1591
return make_short1((signed short)((__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1592
} 
#endif
#line 1595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1596
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1598
::exit(___);}
#if 0
#line 1596
{ 
#line 1597
return __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1598
} 
#endif
#line 1601 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1602
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1606
::exit(___);}
#if 0
#line 1602
{ 
#line 1603
ushort2 tmp = __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1605
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 1606
} 
#endif
#line 1609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1610
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1612
::exit(___);}
#if 0
#line 1610
{ 
#line 1611
return __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1612
} 
#endif
#line 1615 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1616
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1620
::exit(___);}
#if 0
#line 1616
{ 
#line 1617
ushort4 tmp = __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1619
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 1620
} 
#endif
#line 1623 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1624
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1626
::exit(___);}
#if 0
#line 1624
{ 
#line 1625
return __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1626
} 
#endif
#line 1629 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1630
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1632
::exit(___);}
#if 0
#line 1630
{ 
#line 1631
return (int)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1632
} 
#endif
#line 1635 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1636
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1638
::exit(___);}
#if 0
#line 1636
{ 
#line 1637
return (__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x; 
#line 1638
} 
#endif
#line 1641 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1642
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1644
::exit(___);}
#if 0
#line 1642
{ 
#line 1643
return make_int1((signed int)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1644
} 
#endif
#line 1647 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1648
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1650
::exit(___);}
#if 0
#line 1648
{ 
#line 1649
return __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1650
} 
#endif
#line 1653 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1654
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1658
::exit(___);}
#if 0
#line 1654
{ 
#line 1655
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1657
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 1658
} 
#endif
#line 1661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1662
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1664
::exit(___);}
#if 0
#line 1662
{ 
#line 1663
return __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1664
} 
#endif
#line 1667 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1668
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1672
::exit(___);}
#if 0
#line 1668
{ 
#line 1669
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1671
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 1672
} 
#endif
#line 1675 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1676
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1678
::exit(___);}
#if 0
#line 1676
{ 
#line 1677
return __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1678
} 
#endif
#line 1681 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline __int64 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1682
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1684
::exit(___);}
#if 0
#line 1682
{ 
#line 1683
return (__int64)((__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1684
} 
#endif
#line 1687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1688
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1690
::exit(___);}
#if 0
#line 1688
{ 
#line 1689
return (__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap)).x; 
#line 1690
} 
#endif
#line 1693 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1694
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1696
::exit(___);}
#if 0
#line 1694
{ 
#line 1695
return make_longlong1((__int64)((__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1696
} 
#endif
#line 1699 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1700
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1702
::exit(___);}
#if 0
#line 1700
{ 
#line 1701
return __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1702
} 
#endif
#line 1705 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1706
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1710
::exit(___);}
#if 0
#line 1706
{ 
#line 1707
ulonglong2 tmp = __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1709
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 1710
} 
#endif
#line 1713 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1714
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1716
::exit(___);}
#if 0
#line 1714
{ 
#line 1715
return __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1716
} 
#endif
#line 1721 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1722
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1724
::exit(___);}
#if 0
#line 1722
{ 
#line 1723
return (long)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1724
} 
#endif
#line 1727 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned long surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1728
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1730
::exit(___);}
#if 0
#line 1728
{ 
#line 1729
return (unsigned long)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1730
} 
#endif
#line 1733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1734
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1736
::exit(___);}
#if 0
#line 1734
{ 
#line 1735
return make_long1((long)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1736
} 
#endif
#line 1739 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1740
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1742
::exit(___);}
#if 0
#line 1740
{ 
#line 1741
return make_ulong1((unsigned long)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1742
} 
#endif
#line 1745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1746
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1750
::exit(___);}
#if 0
#line 1746
{ 
#line 1747
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1749
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 1750
} 
#endif
#line 1753 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1754
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1758
::exit(___);}
#if 0
#line 1754
{ 
#line 1755
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1757
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 1758
} 
#endif
#line 1761 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1762
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1766
::exit(___);}
#if 0
#line 1762
{ 
#line 1763
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1765
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 1766
} 
#endif
#line 1769 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1770
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1774
::exit(___);}
#if 0
#line 1770
{ 
#line 1771
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1773
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 1774
} 
#endif
#line 1779 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1780
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1782
::exit(___);}
#if 0
#line 1780
{ 
#line 1781
return __int_as_float((int)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1782
} 
#endif
#line 1785 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1786
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1788
::exit(___);}
#if 0
#line 1786
{ 
#line 1787
return make_float1(__int_as_float((int)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x))); 
#line 1788
} 
#endif
#line 1791 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1792
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1796
::exit(___);}
#if 0
#line 1792
{ 
#line 1793
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1795
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 1796
} 
#endif
#line 1799 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1800
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1804
::exit(___);}
#if 0
#line 1800
{ 
#line 1801
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1803
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 1804
} 
#endif
#line 1839 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1840
surfCubemapread(T *res, ::surface< void, 12>  surf, int x, int y, int face, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1841
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
#line 1848
::exit(___);}
#if 0
#line 1841
{ 
#line 1842
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 1848
} 
#endif
#line 1850 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 1851
surfCubemapread(::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1852
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1858
::exit(___);}
#if 0
#line 1852
{ 
#line 1853
T tmp; 
#line 1855
surfCubemapread(&tmp, surf, x, y, face, (int)sizeof(T), mode); 
#line 1857
return tmp; 
#line 1858
} 
#endif
#line 1860 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1861
surfCubemapread(T *res, ::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1862
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1864
::exit(___);}
#if 0
#line 1862
{ 
#line 1863
(*res) = surfCubemapread< T> (surf, x, y, face, mode); 
#line 1864
} 
#endif
#line 1867 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1868
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1870
::exit(___);}
#if 0
#line 1868
{ 
#line 1869
return (char)((__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 1870
} 
#endif
#line 1873 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline signed char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1874
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1876
::exit(___);}
#if 0
#line 1874
{ 
#line 1875
return (signed char)((__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 1876
} 
#endif
#line 1879 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1880
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1882
::exit(___);}
#if 0
#line 1880
{ 
#line 1881
return (__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap)).x; 
#line 1882
} 
#endif
#line 1885 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1886
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1888
::exit(___);}
#if 0
#line 1886
{ 
#line 1887
return make_char1((signed char)((__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 1888
} 
#endif
#line 1891 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1892
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1894
::exit(___);}
#if 0
#line 1892
{ 
#line 1893
return __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1894
} 
#endif
#line 1897 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1898
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1902
::exit(___);}
#if 0
#line 1898
{ 
#line 1899
uchar2 tmp = __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1901
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 1902
} 
#endif
#line 1905 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1906
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1908
::exit(___);}
#if 0
#line 1906
{ 
#line 1907
return __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1908
} 
#endif
#line 1911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1912
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1916
::exit(___);}
#if 0
#line 1912
{ 
#line 1913
uchar4 tmp = __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1915
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 1916
} 
#endif
#line 1919 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1920
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1922
::exit(___);}
#if 0
#line 1920
{ 
#line 1921
return __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1922
} 
#endif
#line 1925 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1926
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1928
::exit(___);}
#if 0
#line 1926
{ 
#line 1927
return (short)((__surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 1928
} 
#endif
#line 1931 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned short surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1932
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1934
::exit(___);}
#if 0
#line 1932
{ 
#line 1933
return (__surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap)).x; 
#line 1934
} 
#endif
#line 1937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1938
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1940
::exit(___);}
#if 0
#line 1938
{ 
#line 1939
return make_short1((signed short)((__surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 1940
} 
#endif
#line 1943 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1944
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1946
::exit(___);}
#if 0
#line 1944
{ 
#line 1945
return __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1946
} 
#endif
#line 1949 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1950
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1954
::exit(___);}
#if 0
#line 1950
{ 
#line 1951
ushort2 tmp = __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1953
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 1954
} 
#endif
#line 1957 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1958
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1960
::exit(___);}
#if 0
#line 1958
{ 
#line 1959
return __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1960
} 
#endif
#line 1963 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1964
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1968
::exit(___);}
#if 0
#line 1964
{ 
#line 1965
ushort4 tmp = __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1967
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 1968
} 
#endif
#line 1971 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1972
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1974
::exit(___);}
#if 0
#line 1972
{ 
#line 1973
return __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1974
} 
#endif
#line 1977 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1978
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1980
::exit(___);}
#if 0
#line 1978
{ 
#line 1979
return (int)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 1980
} 
#endif
#line 1983 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1984
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1986
::exit(___);}
#if 0
#line 1984
{ 
#line 1985
return (__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x; 
#line 1986
} 
#endif
#line 1989 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1990
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1992
::exit(___);}
#if 0
#line 1990
{ 
#line 1991
return make_int1((signed int)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 1992
} 
#endif
#line 1995 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1996
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1998
::exit(___);}
#if 0
#line 1996
{ 
#line 1997
return __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1998
} 
#endif
#line 2001 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2002
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2006
::exit(___);}
#if 0
#line 2002
{ 
#line 2003
uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2005
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 2006
} 
#endif
#line 2009 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2010
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2012
::exit(___);}
#if 0
#line 2010
{ 
#line 2011
return __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2012
} 
#endif
#line 2015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2016
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2020
::exit(___);}
#if 0
#line 2016
{ 
#line 2017
uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2019
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 2020
} 
#endif
#line 2023 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2024
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2026
::exit(___);}
#if 0
#line 2024
{ 
#line 2025
return __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2026
} 
#endif
#line 2029 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline __int64 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2030
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2032
::exit(___);}
#if 0
#line 2030
{ 
#line 2031
return (__int64)((__surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 2032
} 
#endif
#line 2035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2036
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2038
::exit(___);}
#if 0
#line 2036
{ 
#line 2037
return (__surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap)).x; 
#line 2038
} 
#endif
#line 2041 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2042
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2044
::exit(___);}
#if 0
#line 2042
{ 
#line 2043
return make_longlong1((__int64)((__surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2044
} 
#endif
#line 2047 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2048
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2050
::exit(___);}
#if 0
#line 2048
{ 
#line 2049
return __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2050
} 
#endif
#line 2053 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2054
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2058
::exit(___);}
#if 0
#line 2054
{ 
#line 2055
ulonglong2 tmp = __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2057
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 2058
} 
#endif
#line 2061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2062
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2064
::exit(___);}
#if 0
#line 2062
{ 
#line 2063
return __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2064
} 
#endif
#line 2069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2070
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2072
::exit(___);}
#if 0
#line 2070
{ 
#line 2071
return (long)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 2072
} 
#endif
#line 2075 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned long surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2076
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2078
::exit(___);}
#if 0
#line 2076
{ 
#line 2077
return (unsigned long)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 2078
} 
#endif
#line 2081 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2082
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2084
::exit(___);}
#if 0
#line 2082
{ 
#line 2083
return make_long1((long)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2084
} 
#endif
#line 2087 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2088
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2090
::exit(___);}
#if 0
#line 2088
{ 
#line 2089
return make_ulong1((unsigned long)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2090
} 
#endif
#line 2093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2094
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2098
::exit(___);}
#if 0
#line 2094
{ 
#line 2095
uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2097
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 2098
} 
#endif
#line 2101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2102
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2106
::exit(___);}
#if 0
#line 2102
{ 
#line 2103
uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2105
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 2106
} 
#endif
#line 2109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2110
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2114
::exit(___);}
#if 0
#line 2110
{ 
#line 2111
uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2113
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 2114
} 
#endif
#line 2117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2118
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2122
::exit(___);}
#if 0
#line 2118
{ 
#line 2119
uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2121
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 2122
} 
#endif
#line 2127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2128
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2130
::exit(___);}
#if 0
#line 2128
{ 
#line 2129
return __int_as_float((int)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2130
} 
#endif
#line 2133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2134
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2136
::exit(___);}
#if 0
#line 2134
{ 
#line 2135
return make_float1(__int_as_float((int)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x))); 
#line 2136
} 
#endif
#line 2139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2140
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2144
::exit(___);}
#if 0
#line 2140
{ 
#line 2141
uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2143
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 2144
} 
#endif
#line 2147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2148
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2152
::exit(___);}
#if 0
#line 2148
{ 
#line 2149
uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2151
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 2152
} 
#endif
#line 2188 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2189
surfCubemapLayeredread(T *res, ::surface< void, 252>  surf, int x, int y, int layerFace, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2190
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
#line 2197
::exit(___);}
#if 0
#line 2190
{ 
#line 2191
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 2197
} 
#endif
#line 2199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 2200
surfCubemapLayeredread(::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2201
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2207
::exit(___);}
#if 0
#line 2201
{ 
#line 2202
T tmp; 
#line 2204
surfCubemapLayeredread(&tmp, surf, x, y, layerFace, (int)sizeof(T), mode); 
#line 2206
return tmp; 
#line 2207
} 
#endif
#line 2209 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2210
surfCubemapLayeredread(T *res, ::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2211
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2213
::exit(___);}
#if 0
#line 2211
{ 
#line 2212
(*res) = surfCubemapLayeredread< T> (surf, x, y, layerFace, mode); 
#line 2213
} 
#endif
#line 2216 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2217
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2219
::exit(___);}
#if 0
#line 2217
{ 
#line 2218
return (char)((__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2219
} 
#endif
#line 2222 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline signed char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2223
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2225
::exit(___);}
#if 0
#line 2223
{ 
#line 2224
return (signed char)((__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2225
} 
#endif
#line 2228 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2229
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2231
::exit(___);}
#if 0
#line 2229
{ 
#line 2230
return (__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x; 
#line 2231
} 
#endif
#line 2234 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2235
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2237
::exit(___);}
#if 0
#line 2235
{ 
#line 2236
return make_char1((signed char)((__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2237
} 
#endif
#line 2240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2241
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2243
::exit(___);}
#if 0
#line 2241
{ 
#line 2242
return __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2243
} 
#endif
#line 2246 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2247
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2251
::exit(___);}
#if 0
#line 2247
{ 
#line 2248
uchar2 tmp = __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2250
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 2251
} 
#endif
#line 2254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2255
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2257
::exit(___);}
#if 0
#line 2255
{ 
#line 2256
return __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2257
} 
#endif
#line 2260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline char4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2261
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2265
::exit(___);}
#if 0
#line 2261
{ 
#line 2262
uchar4 tmp = __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2264
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 2265
} 
#endif
#line 2268 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uchar4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2269
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2271
::exit(___);}
#if 0
#line 2269
{ 
#line 2270
return __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2271
} 
#endif
#line 2274 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2275
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2277
::exit(___);}
#if 0
#line 2275
{ 
#line 2276
return (short)((__surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2277
} 
#endif
#line 2280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned short surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2281
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2283
::exit(___);}
#if 0
#line 2281
{ 
#line 2282
return (__surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x; 
#line 2283
} 
#endif
#line 2286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2287
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2289
::exit(___);}
#if 0
#line 2287
{ 
#line 2288
return make_short1((signed short)((__surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2289
} 
#endif
#line 2292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2293
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2295
::exit(___);}
#if 0
#line 2293
{ 
#line 2294
return __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2295
} 
#endif
#line 2298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2299
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2303
::exit(___);}
#if 0
#line 2299
{ 
#line 2300
ushort2 tmp = __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2302
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 2303
} 
#endif
#line 2306 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2307
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2309
::exit(___);}
#if 0
#line 2307
{ 
#line 2308
return __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2309
} 
#endif
#line 2312 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline short4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2313
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2317
::exit(___);}
#if 0
#line 2313
{ 
#line 2314
ushort4 tmp = __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2316
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 2317
} 
#endif
#line 2320 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ushort4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2321
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2323
::exit(___);}
#if 0
#line 2321
{ 
#line 2322
return __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2323
} 
#endif
#line 2326 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2327
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2329
::exit(___);}
#if 0
#line 2327
{ 
#line 2328
return (int)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2329
} 
#endif
#line 2332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2333
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2335
::exit(___);}
#if 0
#line 2333
{ 
#line 2334
return (__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x; 
#line 2335
} 
#endif
#line 2338 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2339
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2341
::exit(___);}
#if 0
#line 2339
{ 
#line 2340
return make_int1((signed int)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2341
} 
#endif
#line 2344 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2345
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2347
::exit(___);}
#if 0
#line 2345
{ 
#line 2346
return __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2347
} 
#endif
#line 2350 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2351
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2355
::exit(___);}
#if 0
#line 2351
{ 
#line 2352
uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2354
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 2355
} 
#endif
#line 2358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2359
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2361
::exit(___);}
#if 0
#line 2359
{ 
#line 2360
return __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2361
} 
#endif
#line 2364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline int4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2365
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2369
::exit(___);}
#if 0
#line 2365
{ 
#line 2366
uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2368
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 2369
} 
#endif
#line 2372 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline uint4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2373
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2375
::exit(___);}
#if 0
#line 2373
{ 
#line 2374
return __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2375
} 
#endif
#line 2378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline __int64 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2379
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2381
::exit(___);}
#if 0
#line 2379
{ 
#line 2380
return (__int64)((__surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2381
} 
#endif
#line 2384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2385
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2387
::exit(___);}
#if 0
#line 2385
{ 
#line 2386
return (__surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x; 
#line 2387
} 
#endif
#line 2390 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2391
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2393
::exit(___);}
#if 0
#line 2391
{ 
#line 2392
return make_longlong1((__int64)((__surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2393
} 
#endif
#line 2396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2397
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2399
::exit(___);}
#if 0
#line 2397
{ 
#line 2398
return __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2399
} 
#endif
#line 2402 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline longlong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2403
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2407
::exit(___);}
#if 0
#line 2403
{ 
#line 2404
ulonglong2 tmp = __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2406
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 2407
} 
#endif
#line 2410 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2411
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2413
::exit(___);}
#if 0
#line 2411
{ 
#line 2412
return __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2413
} 
#endif
#line 2418 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2419
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2421
::exit(___);}
#if 0
#line 2419
{ 
#line 2420
return (long)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2421
} 
#endif
#line 2424 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline unsigned long surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2425
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2427
::exit(___);}
#if 0
#line 2425
{ 
#line 2426
return (unsigned long)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2427
} 
#endif
#line 2430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2431
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2433
::exit(___);}
#if 0
#line 2431
{ 
#line 2432
return make_long1((long)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2433
} 
#endif
#line 2436 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2437
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2439
::exit(___);}
#if 0
#line 2437
{ 
#line 2438
return make_ulong1((unsigned long)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2439
} 
#endif
#line 2442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2443
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2447
::exit(___);}
#if 0
#line 2443
{ 
#line 2444
uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2446
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 2447
} 
#endif
#line 2450 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2451
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2455
::exit(___);}
#if 0
#line 2451
{ 
#line 2452
uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2454
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 2455
} 
#endif
#line 2458 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline long4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2459
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2463
::exit(___);}
#if 0
#line 2459
{ 
#line 2460
uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2462
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 2463
} 
#endif
#line 2466 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline ulong4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2467
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2471
::exit(___);}
#if 0
#line 2467
{ 
#line 2468
uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2470
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 2471
} 
#endif
#line 2476 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2477
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2479
::exit(___);}
#if 0
#line 2477
{ 
#line 2478
return __int_as_float((int)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2479
} 
#endif
#line 2482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2483
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2485
::exit(___);}
#if 0
#line 2483
{ 
#line 2484
return make_float1(__int_as_float((int)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x))); 
#line 2485
} 
#endif
#line 2488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2489
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2493
::exit(___);}
#if 0
#line 2489
{ 
#line 2490
uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2492
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 2493
} 
#endif
#line 2496 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template<> __forceinline float4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2497
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2501
::exit(___);}
#if 0
#line 2497
{ 
#line 2498
uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2500
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 2501
} 
#endif
#line 2537 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2538
surf1Dwrite(T val, ::surface< void, 1>  surf, int x, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2539
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)s;(void)mode;
#line 2557
::exit(___);}
#if 0
#line 2539
{ 
#line 2540
union { 
#line 2541
T val; 
#line 2542
::uchar1 c1; 
#line 2543
::ushort1 s1; 
#line 2544
::uint1 u1; 
#line 2545
::uint2 u2; 
#line 2546
::uint4 u4; 
#line 2547
} tmp; 
#line 2549
(tmp.val) = val; 
#line 2551
(s == 1) ? ((void)__surf1Dwritec1(tmp.c1, surf, x, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf1Dwrites1(tmp.s1, surf, x, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf1Dwriteu1(tmp.u1, surf, x, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf1Dwriteu2(tmp.u2, surf, x, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf1Dwriteu4(tmp.u4, surf, x, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 2557
} 
#endif
#line 2559 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2560
surf1Dwrite(T val, ::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2561
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2563
::exit(___);}
#if 0
#line 2561
{ ; 
#line 2562
surf1Dwrite(val, surf, x, (int)sizeof(T), mode); 
#line 2563
} 
#endif
#line 2566 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2567
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2569
::exit(___);}
#if 0
#line 2567
{ 
#line 2568
__surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap); 
#line 2569
} 
#endif
#line 2571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(signed char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2572
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2574
::exit(___);}
#if 0
#line 2572
{ 
#line 2573
__surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap); 
#line 2574
} 
#endif
#line 2576 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(unsigned char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2577
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2579
::exit(___);}
#if 0
#line 2577
{ 
#line 2578
__surf1Dwritec1(make_uchar1(val), surf, x, cudaBoundaryModeTrap); 
#line 2579
} 
#endif
#line 2581 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(char1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2582
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2584
::exit(___);}
#if 0
#line 2582
{ 
#line 2583
__surf1Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2584
} 
#endif
#line 2586 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(uchar1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2587
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2589
::exit(___);}
#if 0
#line 2587
{ 
#line 2588
__surf1Dwritec1(val, surf, x, cudaBoundaryModeTrap); 
#line 2589
} 
#endif
#line 2591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(char2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2592
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2594
::exit(___);}
#if 0
#line 2592
{ 
#line 2593
__surf1Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 2594
} 
#endif
#line 2596 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(uchar2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2597
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2599
::exit(___);}
#if 0
#line 2597
{ 
#line 2598
__surf1Dwritec2(val, surf, x, cudaBoundaryModeTrap); 
#line 2599
} 
#endif
#line 2601 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(char4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2602
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2604
::exit(___);}
#if 0
#line 2602
{ 
#line 2603
__surf1Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 2604
} 
#endif
#line 2606 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(uchar4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2607
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2609
::exit(___);}
#if 0
#line 2607
{ 
#line 2608
__surf1Dwritec4(val, surf, x, cudaBoundaryModeTrap); 
#line 2609
} 
#endif
#line 2611 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2612
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2614
::exit(___);}
#if 0
#line 2612
{ 
#line 2613
__surf1Dwrites1(make_ushort1((unsigned short)val), surf, x, cudaBoundaryModeTrap); 
#line 2614
} 
#endif
#line 2616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(unsigned short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2617
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2619
::exit(___);}
#if 0
#line 2617
{ 
#line 2618
__surf1Dwrites1(make_ushort1(val), surf, x, cudaBoundaryModeTrap); 
#line 2619
} 
#endif
#line 2621 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(short1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2622
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2624
::exit(___);}
#if 0
#line 2622
{ 
#line 2623
__surf1Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2624
} 
#endif
#line 2626 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ushort1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2627
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2629
::exit(___);}
#if 0
#line 2627
{ 
#line 2628
__surf1Dwrites1(val, surf, x, cudaBoundaryModeTrap); 
#line 2629
} 
#endif
#line 2631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(short2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2632
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2634
::exit(___);}
#if 0
#line 2632
{ 
#line 2633
__surf1Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 2634
} 
#endif
#line 2636 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ushort2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2637
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2639
::exit(___);}
#if 0
#line 2637
{ 
#line 2638
__surf1Dwrites2(val, surf, x, cudaBoundaryModeTrap); 
#line 2639
} 
#endif
#line 2641 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(short4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2642
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2644
::exit(___);}
#if 0
#line 2642
{ 
#line 2643
__surf1Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 2644
} 
#endif
#line 2646 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ushort4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2647
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2649
::exit(___);}
#if 0
#line 2647
{ 
#line 2648
__surf1Dwrites4(val, surf, x, cudaBoundaryModeTrap); 
#line 2649
} 
#endif
#line 2651 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(int val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2652
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2654
::exit(___);}
#if 0
#line 2652
{ 
#line 2653
__surf1Dwriteu1(make_uint1((unsigned)val), surf, x, cudaBoundaryModeTrap); 
#line 2654
} 
#endif
#line 2656 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(unsigned val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2657
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2659
::exit(___);}
#if 0
#line 2657
{ 
#line 2658
__surf1Dwriteu1(make_uint1(val), surf, x, cudaBoundaryModeTrap); 
#line 2659
} 
#endif
#line 2661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(int1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2662
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2664
::exit(___);}
#if 0
#line 2662
{ 
#line 2663
__surf1Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2664
} 
#endif
#line 2666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(uint1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2667
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2669
::exit(___);}
#if 0
#line 2667
{ 
#line 2668
__surf1Dwriteu1(val, surf, x, cudaBoundaryModeTrap); 
#line 2669
} 
#endif
#line 2671 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(int2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2672
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2674
::exit(___);}
#if 0
#line 2672
{ 
#line 2673
__surf1Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 2674
} 
#endif
#line 2676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(uint2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2677
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2679
::exit(___);}
#if 0
#line 2677
{ 
#line 2678
__surf1Dwriteu2(val, surf, x, cudaBoundaryModeTrap); 
#line 2679
} 
#endif
#line 2681 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(int4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2682
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2684
::exit(___);}
#if 0
#line 2682
{ 
#line 2683
__surf1Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 2684
} 
#endif
#line 2686 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(uint4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2687
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2689
::exit(___);}
#if 0
#line 2687
{ 
#line 2688
__surf1Dwriteu4(val, surf, x, cudaBoundaryModeTrap); 
#line 2689
} 
#endif
#line 2691 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(__int64 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2692
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2694
::exit(___);}
#if 0
#line 2692
{ 
#line 2693
__surf1Dwritel1(make_ulonglong1((unsigned __int64)val), surf, x, cudaBoundaryModeTrap); 
#line 2694
} 
#endif
#line 2696 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(unsigned __int64 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2697
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2699
::exit(___);}
#if 0
#line 2697
{ 
#line 2698
__surf1Dwritel1(make_ulonglong1(val), surf, x, cudaBoundaryModeTrap); 
#line 2699
} 
#endif
#line 2701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(longlong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2702
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2704
::exit(___);}
#if 0
#line 2702
{ 
#line 2703
__surf1Dwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2704
} 
#endif
#line 2706 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ulonglong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2707
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2709
::exit(___);}
#if 0
#line 2707
{ 
#line 2708
__surf1Dwritel1(val, surf, x, cudaBoundaryModeTrap); 
#line 2709
} 
#endif
#line 2711 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(longlong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2712
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2714
::exit(___);}
#if 0
#line 2712
{ 
#line 2713
__surf1Dwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 2714
} 
#endif
#line 2716 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ulonglong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2717
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2719
::exit(___);}
#if 0
#line 2717
{ 
#line 2718
__surf1Dwritel2(val, surf, x, cudaBoundaryModeTrap); 
#line 2719
} 
#endif
#line 2723 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2724
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2726
::exit(___);}
#if 0
#line 2724
{ 
#line 2725
__surf1Dwriteu1(make_uint1((unsigned)val), surf, x, cudaBoundaryModeTrap); 
#line 2726
} 
#endif
#line 2728 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(unsigned long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2729
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2731
::exit(___);}
#if 0
#line 2729
{ 
#line 2730
__surf1Dwriteu1(make_uint1((unsigned)val), surf, x, cudaBoundaryModeTrap); 
#line 2731
} 
#endif
#line 2733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(long1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2734
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2736
::exit(___);}
#if 0
#line 2734
{ 
#line 2735
__surf1Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2736
} 
#endif
#line 2738 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ulong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2739
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2741
::exit(___);}
#if 0
#line 2739
{ 
#line 2740
__surf1Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2741
} 
#endif
#line 2743 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(long2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2744
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2746
::exit(___);}
#if 0
#line 2744
{ 
#line 2745
__surf1Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 2746
} 
#endif
#line 2748 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ulong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2749
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2751
::exit(___);}
#if 0
#line 2749
{ 
#line 2750
__surf1Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 2751
} 
#endif
#line 2753 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(long4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2754
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2756
::exit(___);}
#if 0
#line 2754
{ 
#line 2755
__surf1Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 2756
} 
#endif
#line 2758 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ulong4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2759
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2761
::exit(___);}
#if 0
#line 2759
{ 
#line 2760
__surf1Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 2761
} 
#endif
#line 2765 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(float val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2766
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2768
::exit(___);}
#if 0
#line 2766
{ 
#line 2767
__surf1Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, cudaBoundaryModeTrap); 
#line 2768
} 
#endif
#line 2770 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(float1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2771
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2773
::exit(___);}
#if 0
#line 2771
{ 
#line 2772
__surf1Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2773
} 
#endif
#line 2775 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(float2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2776
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2778
::exit(___);}
#if 0
#line 2776
{ 
#line 2777
__surf1Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, cudaBoundaryModeTrap); 
#line 2778
} 
#endif
#line 2780 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(float4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2781
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2783
::exit(___);}
#if 0
#line 2781
{ 
#line 2782
__surf1Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 2783
} 
#endif
#line 2819 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2820
surf2Dwrite(T val, ::surface< void, 2>  surf, int x, int y, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2821
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)s;(void)mode;
#line 2839
::exit(___);}
#if 0
#line 2821
{ 
#line 2822
union { 
#line 2823
T val; 
#line 2824
::uchar1 c1; 
#line 2825
::ushort1 s1; 
#line 2826
::uint1 u1; 
#line 2827
::uint2 u2; 
#line 2828
::uint4 u4; 
#line 2829
} tmp; 
#line 2831
(tmp.val) = val; 
#line 2833
(s == 1) ? ((void)__surf2Dwritec1(tmp.c1, surf, x, y, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf2Dwrites1(tmp.s1, surf, x, y, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf2Dwriteu1(tmp.u1, surf, x, y, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf2Dwriteu2(tmp.u2, surf, x, y, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf2Dwriteu4(tmp.u4, surf, x, y, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 2839
} 
#endif
#line 2841 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2842
surf2Dwrite(T val, ::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2843
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2845
::exit(___);}
#if 0
#line 2843
{ ; 
#line 2844
surf2Dwrite(val, surf, x, y, (int)sizeof(T), mode); 
#line 2845
} 
#endif
#line 2848 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2849
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2851
::exit(___);}
#if 0
#line 2849
{ 
#line 2850
__surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap); 
#line 2851
} 
#endif
#line 2853 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(signed char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2854
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2856
::exit(___);}
#if 0
#line 2854
{ 
#line 2855
__surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap); 
#line 2856
} 
#endif
#line 2858 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(unsigned char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2859
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2861
::exit(___);}
#if 0
#line 2859
{ 
#line 2860
__surf2Dwritec1(make_uchar1(val), surf, x, y, cudaBoundaryModeTrap); 
#line 2861
} 
#endif
#line 2863 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(char1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2864
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2866
::exit(___);}
#if 0
#line 2864
{ 
#line 2865
__surf2Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 2866
} 
#endif
#line 2868 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(uchar1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2869
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2871
::exit(___);}
#if 0
#line 2869
{ 
#line 2870
__surf2Dwritec1(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2871
} 
#endif
#line 2873 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(char2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2874
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2876
::exit(___);}
#if 0
#line 2874
{ 
#line 2875
__surf2Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 2876
} 
#endif
#line 2878 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(uchar2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2879
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2881
::exit(___);}
#if 0
#line 2879
{ 
#line 2880
__surf2Dwritec2(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2881
} 
#endif
#line 2883 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(char4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2884
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2886
::exit(___);}
#if 0
#line 2884
{ 
#line 2885
__surf2Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 2886
} 
#endif
#line 2888 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(uchar4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2889
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2891
::exit(___);}
#if 0
#line 2889
{ 
#line 2890
__surf2Dwritec4(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2891
} 
#endif
#line 2893 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2894
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2896
::exit(___);}
#if 0
#line 2894
{ 
#line 2895
__surf2Dwrites1(make_ushort1((unsigned short)val), surf, x, y, cudaBoundaryModeTrap); 
#line 2896
} 
#endif
#line 2898 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(unsigned short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2899
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2901
::exit(___);}
#if 0
#line 2899
{ 
#line 2900
__surf2Dwrites1(make_ushort1(val), surf, x, y, cudaBoundaryModeTrap); 
#line 2901
} 
#endif
#line 2903 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(short1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2904
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2906
::exit(___);}
#if 0
#line 2904
{ 
#line 2905
__surf2Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 2906
} 
#endif
#line 2908 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ushort1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2909
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2911
::exit(___);}
#if 0
#line 2909
{ 
#line 2910
__surf2Dwrites1(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2911
} 
#endif
#line 2913 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(short2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2914
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2916
::exit(___);}
#if 0
#line 2914
{ 
#line 2915
__surf2Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 2916
} 
#endif
#line 2918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ushort2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2919
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2921
::exit(___);}
#if 0
#line 2919
{ 
#line 2920
__surf2Dwrites2(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2921
} 
#endif
#line 2923 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(short4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2924
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2926
::exit(___);}
#if 0
#line 2924
{ 
#line 2925
__surf2Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 2926
} 
#endif
#line 2928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ushort4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2929
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2931
::exit(___);}
#if 0
#line 2929
{ 
#line 2930
__surf2Dwrites4(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2931
} 
#endif
#line 2933 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(int val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2934
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2936
::exit(___);}
#if 0
#line 2934
{ 
#line 2935
__surf2Dwriteu1(make_uint1((unsigned)val), surf, x, y, cudaBoundaryModeTrap); 
#line 2936
} 
#endif
#line 2938 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(unsigned val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2939
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2941
::exit(___);}
#if 0
#line 2939
{ 
#line 2940
__surf2Dwriteu1(make_uint1(val), surf, x, y, cudaBoundaryModeTrap); 
#line 2941
} 
#endif
#line 2943 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(int1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2944
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2946
::exit(___);}
#if 0
#line 2944
{ 
#line 2945
__surf2Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 2946
} 
#endif
#line 2948 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(uint1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2949
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2951
::exit(___);}
#if 0
#line 2949
{ 
#line 2950
__surf2Dwriteu1(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2951
} 
#endif
#line 2953 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(int2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2954
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2956
::exit(___);}
#if 0
#line 2954
{ 
#line 2955
__surf2Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 2956
} 
#endif
#line 2958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(uint2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2959
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2961
::exit(___);}
#if 0
#line 2959
{ 
#line 2960
__surf2Dwriteu2(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2961
} 
#endif
#line 2963 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(int4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2964
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2966
::exit(___);}
#if 0
#line 2964
{ 
#line 2965
__surf2Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 2966
} 
#endif
#line 2968 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(uint4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2969
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2971
::exit(___);}
#if 0
#line 2969
{ 
#line 2970
__surf2Dwriteu4(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2971
} 
#endif
#line 2973 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(__int64 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2974
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2976
::exit(___);}
#if 0
#line 2974
{ 
#line 2975
__surf2Dwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, cudaBoundaryModeTrap); 
#line 2976
} 
#endif
#line 2978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(unsigned __int64 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2979
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2981
::exit(___);}
#if 0
#line 2979
{ 
#line 2980
__surf2Dwritel1(make_ulonglong1(val), surf, x, y, cudaBoundaryModeTrap); 
#line 2981
} 
#endif
#line 2983 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(longlong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2984
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2986
::exit(___);}
#if 0
#line 2984
{ 
#line 2985
__surf2Dwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 2986
} 
#endif
#line 2988 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ulonglong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2989
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2991
::exit(___);}
#if 0
#line 2989
{ 
#line 2990
__surf2Dwritel1(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2991
} 
#endif
#line 2993 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(longlong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2994
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2996
::exit(___);}
#if 0
#line 2994
{ 
#line 2995
__surf2Dwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 2996
} 
#endif
#line 2998 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ulonglong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2999
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3001
::exit(___);}
#if 0
#line 2999
{ 
#line 3000
__surf2Dwritel2(val, surf, x, y, cudaBoundaryModeTrap); 
#line 3001
} 
#endif
#line 3005 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3006
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3008
::exit(___);}
#if 0
#line 3006
{ 
#line 3007
__surf2Dwriteu1(make_uint1((unsigned)val), surf, x, y, cudaBoundaryModeTrap); 
#line 3008
} 
#endif
#line 3010 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(unsigned long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3011
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3013
::exit(___);}
#if 0
#line 3011
{ 
#line 3012
__surf2Dwriteu1(make_uint1((unsigned)val), surf, x, y, cudaBoundaryModeTrap); 
#line 3013
} 
#endif
#line 3015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(long1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3016
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3018
::exit(___);}
#if 0
#line 3016
{ 
#line 3017
__surf2Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 3018
} 
#endif
#line 3020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ulong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3021
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3023
::exit(___);}
#if 0
#line 3021
{ 
#line 3022
__surf2Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 3023
} 
#endif
#line 3025 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(long2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3026
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3028
::exit(___);}
#if 0
#line 3026
{ 
#line 3027
__surf2Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 3028
} 
#endif
#line 3030 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ulong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3031
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3033
::exit(___);}
#if 0
#line 3031
{ 
#line 3032
__surf2Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 3033
} 
#endif
#line 3035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(long4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3036
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3038
::exit(___);}
#if 0
#line 3036
{ 
#line 3037
__surf2Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 3038
} 
#endif
#line 3040 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ulong4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3041
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3043
::exit(___);}
#if 0
#line 3041
{ 
#line 3042
__surf2Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 3043
} 
#endif
#line 3047 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(float val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3048
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3050
::exit(___);}
#if 0
#line 3048
{ 
#line 3049
__surf2Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, cudaBoundaryModeTrap); 
#line 3050
} 
#endif
#line 3052 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(float1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3053
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3055
::exit(___);}
#if 0
#line 3053
{ 
#line 3054
__surf2Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 3055
} 
#endif
#line 3057 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(float2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3058
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3060
::exit(___);}
#if 0
#line 3058
{ 
#line 3059
__surf2Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, cudaBoundaryModeTrap); 
#line 3060
} 
#endif
#line 3062 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(float4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3063
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3065
::exit(___);}
#if 0
#line 3063
{ 
#line 3064
__surf2Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 3065
} 
#endif
#line 3101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3102
surf3Dwrite(T val, ::surface< void, 3>  surf, int x, int y, int z, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3103
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
#line 3121
::exit(___);}
#if 0
#line 3103
{ 
#line 3104
union { 
#line 3105
T val; 
#line 3106
::uchar1 c1; 
#line 3107
::ushort1 s1; 
#line 3108
::uint1 u1; 
#line 3109
::uint2 u2; 
#line 3110
::uint4 u4; 
#line 3111
} tmp; 
#line 3113
(tmp.val) = val; 
#line 3115
(s == 1) ? ((void)__surf3Dwritec1(tmp.c1, surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf3Dwrites1(tmp.s1, surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf3Dwriteu1(tmp.u1, surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf3Dwriteu2(tmp.u2, surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf3Dwriteu4(tmp.u4, surf, x, y, z, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 3121
} 
#endif
#line 3123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3124
surf3Dwrite(T val, ::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3125
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3127
::exit(___);}
#if 0
#line 3125
{ ; 
#line 3126
surf3Dwrite(val, surf, x, y, z, (int)sizeof(T), mode); 
#line 3127
} 
#endif
#line 3130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3131
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3133
::exit(___);}
#if 0
#line 3131
{ 
#line 3132
__surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3133
} 
#endif
#line 3135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(signed char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3136
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3138
::exit(___);}
#if 0
#line 3136
{ 
#line 3137
__surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3138
} 
#endif
#line 3140 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(unsigned char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3141
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3143
::exit(___);}
#if 0
#line 3141
{ 
#line 3142
__surf3Dwritec1(make_uchar1(val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3143
} 
#endif
#line 3145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(char1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3146
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3148
::exit(___);}
#if 0
#line 3146
{ 
#line 3147
__surf3Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3148
} 
#endif
#line 3150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(uchar1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3151
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3153
::exit(___);}
#if 0
#line 3151
{ 
#line 3152
__surf3Dwritec1(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3153
} 
#endif
#line 3155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(char2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3156
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3158
::exit(___);}
#if 0
#line 3156
{ 
#line 3157
__surf3Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3158
} 
#endif
#line 3160 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(uchar2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3161
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3163
::exit(___);}
#if 0
#line 3161
{ 
#line 3162
__surf3Dwritec2(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3163
} 
#endif
#line 3165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(char4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3166
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3168
::exit(___);}
#if 0
#line 3166
{ 
#line 3167
__surf3Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3168
} 
#endif
#line 3170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(uchar4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3171
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3173
::exit(___);}
#if 0
#line 3171
{ 
#line 3172
__surf3Dwritec4(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3173
} 
#endif
#line 3175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3176
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3178
::exit(___);}
#if 0
#line 3176
{ 
#line 3177
__surf3Dwrites1(make_ushort1((unsigned short)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3178
} 
#endif
#line 3180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(unsigned short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3181
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3183
::exit(___);}
#if 0
#line 3181
{ 
#line 3182
__surf3Dwrites1(make_ushort1(val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3183
} 
#endif
#line 3185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(short1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3186
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3188
::exit(___);}
#if 0
#line 3186
{ 
#line 3187
__surf3Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3188
} 
#endif
#line 3190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ushort1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3191
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3193
::exit(___);}
#if 0
#line 3191
{ 
#line 3192
__surf3Dwrites1(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3193
} 
#endif
#line 3195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(short2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3196
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3198
::exit(___);}
#if 0
#line 3196
{ 
#line 3197
__surf3Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3198
} 
#endif
#line 3200 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ushort2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3201
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3203
::exit(___);}
#if 0
#line 3201
{ 
#line 3202
__surf3Dwrites2(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3203
} 
#endif
#line 3205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(short4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3206
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3208
::exit(___);}
#if 0
#line 3206
{ 
#line 3207
__surf3Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3208
} 
#endif
#line 3210 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ushort4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3211
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3213
::exit(___);}
#if 0
#line 3211
{ 
#line 3212
__surf3Dwrites4(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3213
} 
#endif
#line 3215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(int val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3216
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3218
::exit(___);}
#if 0
#line 3216
{ 
#line 3217
__surf3Dwriteu1(make_uint1((unsigned)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3218
} 
#endif
#line 3220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(unsigned val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3221
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3223
::exit(___);}
#if 0
#line 3221
{ 
#line 3222
__surf3Dwriteu1(make_uint1(val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3223
} 
#endif
#line 3225 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(int1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3226
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3228
::exit(___);}
#if 0
#line 3226
{ 
#line 3227
__surf3Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3228
} 
#endif
#line 3230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(uint1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3231
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3233
::exit(___);}
#if 0
#line 3231
{ 
#line 3232
__surf3Dwriteu1(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3233
} 
#endif
#line 3235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(int2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3236
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3238
::exit(___);}
#if 0
#line 3236
{ 
#line 3237
__surf3Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3238
} 
#endif
#line 3240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(uint2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3241
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3243
::exit(___);}
#if 0
#line 3241
{ 
#line 3242
__surf3Dwriteu2(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3243
} 
#endif
#line 3245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(int4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3246
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3248
::exit(___);}
#if 0
#line 3246
{ 
#line 3247
__surf3Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3248
} 
#endif
#line 3250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(uint4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3251
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3253
::exit(___);}
#if 0
#line 3251
{ 
#line 3252
__surf3Dwriteu4(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3253
} 
#endif
#line 3255 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(__int64 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3256
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3258
::exit(___);}
#if 0
#line 3256
{ 
#line 3257
__surf3Dwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3258
} 
#endif
#line 3260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(unsigned __int64 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3261
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3263
::exit(___);}
#if 0
#line 3261
{ 
#line 3262
__surf3Dwritel1(make_ulonglong1(val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3263
} 
#endif
#line 3265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(longlong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3266
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3268
::exit(___);}
#if 0
#line 3266
{ 
#line 3267
__surf3Dwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3268
} 
#endif
#line 3270 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ulonglong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3271
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3273
::exit(___);}
#if 0
#line 3271
{ 
#line 3272
__surf3Dwritel1(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3273
} 
#endif
#line 3275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(longlong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3276
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3278
::exit(___);}
#if 0
#line 3276
{ 
#line 3277
__surf3Dwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3278
} 
#endif
#line 3280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ulonglong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3281
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3283
::exit(___);}
#if 0
#line 3281
{ 
#line 3282
__surf3Dwritel2(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3283
} 
#endif
#line 3287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3288
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3290
::exit(___);}
#if 0
#line 3288
{ 
#line 3289
__surf3Dwriteu1(make_uint1((unsigned)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3290
} 
#endif
#line 3292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(unsigned long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3293
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3295
::exit(___);}
#if 0
#line 3293
{ 
#line 3294
__surf3Dwriteu1(make_uint1((unsigned)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3295
} 
#endif
#line 3297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(long1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3298
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3300
::exit(___);}
#if 0
#line 3298
{ 
#line 3299
__surf3Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3300
} 
#endif
#line 3302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ulong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3303
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3305
::exit(___);}
#if 0
#line 3303
{ 
#line 3304
__surf3Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3305
} 
#endif
#line 3307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(long2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3308
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3310
::exit(___);}
#if 0
#line 3308
{ 
#line 3309
__surf3Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3310
} 
#endif
#line 3312 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ulong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3313
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3315
::exit(___);}
#if 0
#line 3313
{ 
#line 3314
__surf3Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3315
} 
#endif
#line 3317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(long4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3318
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3320
::exit(___);}
#if 0
#line 3318
{ 
#line 3319
__surf3Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3320
} 
#endif
#line 3322 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ulong4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3323
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3325
::exit(___);}
#if 0
#line 3323
{ 
#line 3324
__surf3Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3325
} 
#endif
#line 3329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(float val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3330
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3332
::exit(___);}
#if 0
#line 3330
{ 
#line 3331
__surf3Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3332
} 
#endif
#line 3334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(float1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3335
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3337
::exit(___);}
#if 0
#line 3335
{ 
#line 3336
__surf3Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3337
} 
#endif
#line 3339 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(float2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3340
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3342
::exit(___);}
#if 0
#line 3340
{ 
#line 3341
__surf3Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3342
} 
#endif
#line 3344 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(float4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3345
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3347
::exit(___);}
#if 0
#line 3345
{ 
#line 3346
__surf3Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3347
} 
#endif
#line 3383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3384
surf1DLayeredwrite(T val, ::surface< void, 241>  surf, int x, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3385
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
#line 3403
::exit(___);}
#if 0
#line 3385
{ 
#line 3386
union { 
#line 3387
T val; 
#line 3388
::uchar1 c1; 
#line 3389
::ushort1 s1; 
#line 3390
::uint1 u1; 
#line 3391
::uint2 u2; 
#line 3392
::uint4 u4; 
#line 3393
} tmp; 
#line 3395
(tmp.val) = val; 
#line 3397
(s == 1) ? ((void)__surf1DLayeredwritec1(tmp.c1, surf, x, layer, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf1DLayeredwrites1(tmp.s1, surf, x, layer, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf1DLayeredwriteu1(tmp.u1, surf, x, layer, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf1DLayeredwriteu2(tmp.u2, surf, x, layer, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf1DLayeredwriteu4(tmp.u4, surf, x, layer, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 3403
} 
#endif
#line 3405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3406
surf1DLayeredwrite(T val, ::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3407
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3409
::exit(___);}
#if 0
#line 3407
{ ; 
#line 3408
surf1DLayeredwrite(val, surf, x, layer, (int)sizeof(T), mode); 
#line 3409
} 
#endif
#line 3412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3413
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3415
::exit(___);}
#if 0
#line 3413
{ 
#line 3414
__surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3415
} 
#endif
#line 3417 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(signed char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3418
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3420
::exit(___);}
#if 0
#line 3418
{ 
#line 3419
__surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3420
} 
#endif
#line 3422 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3423
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3425
::exit(___);}
#if 0
#line 3423
{ 
#line 3424
__surf1DLayeredwritec1(make_uchar1(val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3425
} 
#endif
#line 3427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(char1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3428
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3430
::exit(___);}
#if 0
#line 3428
{ 
#line 3429
__surf1DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3430
} 
#endif
#line 3432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(uchar1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3433
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3435
::exit(___);}
#if 0
#line 3433
{ 
#line 3434
__surf1DLayeredwritec1(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3435
} 
#endif
#line 3437 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(char2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3438
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3440
::exit(___);}
#if 0
#line 3438
{ 
#line 3439
__surf1DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3440
} 
#endif
#line 3442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(uchar2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3443
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3445
::exit(___);}
#if 0
#line 3443
{ 
#line 3444
__surf1DLayeredwritec2(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3445
} 
#endif
#line 3447 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(char4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3448
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3450
::exit(___);}
#if 0
#line 3448
{ 
#line 3449
__surf1DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3450
} 
#endif
#line 3452 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(uchar4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3453
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3455
::exit(___);}
#if 0
#line 3453
{ 
#line 3454
__surf1DLayeredwritec4(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3455
} 
#endif
#line 3457 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3458
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3460
::exit(___);}
#if 0
#line 3458
{ 
#line 3459
__surf1DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3460
} 
#endif
#line 3462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3463
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3465
::exit(___);}
#if 0
#line 3463
{ 
#line 3464
__surf1DLayeredwrites1(make_ushort1(val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3465
} 
#endif
#line 3467 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(short1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3468
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3470
::exit(___);}
#if 0
#line 3468
{ 
#line 3469
__surf1DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3470
} 
#endif
#line 3472 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ushort1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3473
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3475
::exit(___);}
#if 0
#line 3473
{ 
#line 3474
__surf1DLayeredwrites1(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3475
} 
#endif
#line 3477 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(short2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3478
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3480
::exit(___);}
#if 0
#line 3478
{ 
#line 3479
__surf1DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3480
} 
#endif
#line 3482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ushort2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3483
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3485
::exit(___);}
#if 0
#line 3483
{ 
#line 3484
__surf1DLayeredwrites2(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3485
} 
#endif
#line 3487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(short4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3488
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3490
::exit(___);}
#if 0
#line 3488
{ 
#line 3489
__surf1DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3490
} 
#endif
#line 3492 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ushort4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3493
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3495
::exit(___);}
#if 0
#line 3493
{ 
#line 3494
__surf1DLayeredwrites4(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3495
} 
#endif
#line 3497 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(int val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3498
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3500
::exit(___);}
#if 0
#line 3498
{ 
#line 3499
__surf1DLayeredwriteu1(make_uint1((unsigned)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3500
} 
#endif
#line 3502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3503
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3505
::exit(___);}
#if 0
#line 3503
{ 
#line 3504
__surf1DLayeredwriteu1(make_uint1(val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3505
} 
#endif
#line 3507 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(int1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3508
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3510
::exit(___);}
#if 0
#line 3508
{ 
#line 3509
__surf1DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3510
} 
#endif
#line 3512 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(uint1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3513
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3515
::exit(___);}
#if 0
#line 3513
{ 
#line 3514
__surf1DLayeredwriteu1(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3515
} 
#endif
#line 3517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(int2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3518
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3520
::exit(___);}
#if 0
#line 3518
{ 
#line 3519
__surf1DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3520
} 
#endif
#line 3522 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(uint2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3523
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3525
::exit(___);}
#if 0
#line 3523
{ 
#line 3524
__surf1DLayeredwriteu2(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3525
} 
#endif
#line 3527 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(int4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3528
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3530
::exit(___);}
#if 0
#line 3528
{ 
#line 3529
__surf1DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3530
} 
#endif
#line 3532 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(uint4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3533
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3535
::exit(___);}
#if 0
#line 3533
{ 
#line 3534
__surf1DLayeredwriteu4(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3535
} 
#endif
#line 3537 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(__int64 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3538
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3540
::exit(___);}
#if 0
#line 3538
{ 
#line 3539
__surf1DLayeredwritel1(make_ulonglong1((unsigned __int64)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3540
} 
#endif
#line 3542 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned __int64 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3543
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3545
::exit(___);}
#if 0
#line 3543
{ 
#line 3544
__surf1DLayeredwritel1(make_ulonglong1(val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3545
} 
#endif
#line 3547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(longlong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3548
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3550
::exit(___);}
#if 0
#line 3548
{ 
#line 3549
__surf1DLayeredwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3550
} 
#endif
#line 3552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ulonglong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3553
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3555
::exit(___);}
#if 0
#line 3553
{ 
#line 3554
__surf1DLayeredwritel1(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3555
} 
#endif
#line 3557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(longlong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3558
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3560
::exit(___);}
#if 0
#line 3558
{ 
#line 3559
__surf1DLayeredwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3560
} 
#endif
#line 3562 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ulonglong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3563
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3565
::exit(___);}
#if 0
#line 3563
{ 
#line 3564
__surf1DLayeredwritel2(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3565
} 
#endif
#line 3569 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3570
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3572
::exit(___);}
#if 0
#line 3570
{ 
#line 3571
__surf1DLayeredwriteu1(make_uint1((unsigned)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3572
} 
#endif
#line 3574 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3575
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3577
::exit(___);}
#if 0
#line 3575
{ 
#line 3576
__surf1DLayeredwriteu1(make_uint1((unsigned)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3577
} 
#endif
#line 3579 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(long1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3580
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3582
::exit(___);}
#if 0
#line 3580
{ 
#line 3581
__surf1DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3582
} 
#endif
#line 3584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ulong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3585
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3587
::exit(___);}
#if 0
#line 3585
{ 
#line 3586
__surf1DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3587
} 
#endif
#line 3589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(long2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3590
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3592
::exit(___);}
#if 0
#line 3590
{ 
#line 3591
__surf1DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3592
} 
#endif
#line 3594 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ulong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3595
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3597
::exit(___);}
#if 0
#line 3595
{ 
#line 3596
__surf1DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3597
} 
#endif
#line 3599 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(long4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3600
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3602
::exit(___);}
#if 0
#line 3600
{ 
#line 3601
__surf1DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3602
} 
#endif
#line 3604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ulong4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3605
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3607
::exit(___);}
#if 0
#line 3605
{ 
#line 3606
__surf1DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3607
} 
#endif
#line 3611 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(float val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3612
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3614
::exit(___);}
#if 0
#line 3612
{ 
#line 3613
__surf1DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3614
} 
#endif
#line 3616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(float1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3617
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3619
::exit(___);}
#if 0
#line 3617
{ 
#line 3618
__surf1DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3619
} 
#endif
#line 3621 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(float2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3622
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3624
::exit(___);}
#if 0
#line 3622
{ 
#line 3623
__surf1DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, layer, cudaBoundaryModeTrap); 
#line 3624
} 
#endif
#line 3626 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(float4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3627
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3629
::exit(___);}
#if 0
#line 3627
{ 
#line 3628
__surf1DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3629
} 
#endif
#line 3665 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3666
surf2DLayeredwrite(T val, ::surface< void, 242>  surf, int x, int y, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3667
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
#line 3685
::exit(___);}
#if 0
#line 3667
{ 
#line 3668
union { 
#line 3669
T val; 
#line 3670
::uchar1 c1; 
#line 3671
::ushort1 s1; 
#line 3672
::uint1 u1; 
#line 3673
::uint2 u2; 
#line 3674
::uint4 u4; 
#line 3675
} tmp; 
#line 3677
(tmp.val) = val; 
#line 3679
(s == 1) ? ((void)__surf2DLayeredwritec1(tmp.c1, surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf2DLayeredwrites1(tmp.s1, surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf2DLayeredwriteu1(tmp.u1, surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf2DLayeredwriteu2(tmp.u2, surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf2DLayeredwriteu4(tmp.u4, surf, x, y, layer, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 3685
} 
#endif
#line 3687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3688
surf2DLayeredwrite(T val, ::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3689
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3691
::exit(___);}
#if 0
#line 3689
{ ; 
#line 3690
surf2DLayeredwrite(val, surf, x, y, layer, (int)sizeof(T), mode); 
#line 3691
} 
#endif
#line 3694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3695
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3697
::exit(___);}
#if 0
#line 3695
{ 
#line 3696
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3697
} 
#endif
#line 3699 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(signed char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3700
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3702
::exit(___);}
#if 0
#line 3700
{ 
#line 3701
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3702
} 
#endif
#line 3704 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3705
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3707
::exit(___);}
#if 0
#line 3705
{ 
#line 3706
__surf2DLayeredwritec1(make_uchar1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3707
} 
#endif
#line 3709 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(char1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3710
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3712
::exit(___);}
#if 0
#line 3710
{ 
#line 3711
__surf2DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3712
} 
#endif
#line 3714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(uchar1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3715
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3717
::exit(___);}
#if 0
#line 3715
{ 
#line 3716
__surf2DLayeredwritec1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3717
} 
#endif
#line 3719 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(char2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3720
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3722
::exit(___);}
#if 0
#line 3720
{ 
#line 3721
__surf2DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3722
} 
#endif
#line 3724 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(uchar2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3725
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3727
::exit(___);}
#if 0
#line 3725
{ 
#line 3726
__surf2DLayeredwritec2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3727
} 
#endif
#line 3729 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(char4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3730
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3732
::exit(___);}
#if 0
#line 3730
{ 
#line 3731
__surf2DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3732
} 
#endif
#line 3734 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(uchar4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3735
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3737
::exit(___);}
#if 0
#line 3735
{ 
#line 3736
__surf2DLayeredwritec4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3737
} 
#endif
#line 3739 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3740
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3742
::exit(___);}
#if 0
#line 3740
{ 
#line 3741
__surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3742
} 
#endif
#line 3744 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3745
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3747
::exit(___);}
#if 0
#line 3745
{ 
#line 3746
__surf2DLayeredwrites1(make_ushort1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3747
} 
#endif
#line 3749 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(short1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3750
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3752
::exit(___);}
#if 0
#line 3750
{ 
#line 3751
__surf2DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3752
} 
#endif
#line 3754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ushort1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3755
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3757
::exit(___);}
#if 0
#line 3755
{ 
#line 3756
__surf2DLayeredwrites1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3757
} 
#endif
#line 3759 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(short2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3760
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3762
::exit(___);}
#if 0
#line 3760
{ 
#line 3761
__surf2DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3762
} 
#endif
#line 3764 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ushort2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3765
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3767
::exit(___);}
#if 0
#line 3765
{ 
#line 3766
__surf2DLayeredwrites2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3767
} 
#endif
#line 3769 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(short4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3770
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3772
::exit(___);}
#if 0
#line 3770
{ 
#line 3771
__surf2DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3772
} 
#endif
#line 3774 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ushort4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3775
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3777
::exit(___);}
#if 0
#line 3775
{ 
#line 3776
__surf2DLayeredwrites4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3777
} 
#endif
#line 3779 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(int val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3780
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3782
::exit(___);}
#if 0
#line 3780
{ 
#line 3781
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3782
} 
#endif
#line 3784 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3785
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3787
::exit(___);}
#if 0
#line 3785
{ 
#line 3786
__surf2DLayeredwriteu1(make_uint1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3787
} 
#endif
#line 3789 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(int1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3790
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3792
::exit(___);}
#if 0
#line 3790
{ 
#line 3791
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3792
} 
#endif
#line 3794 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(uint1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3795
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3797
::exit(___);}
#if 0
#line 3795
{ 
#line 3796
__surf2DLayeredwriteu1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3797
} 
#endif
#line 3799 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(int2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3800
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3802
::exit(___);}
#if 0
#line 3800
{ 
#line 3801
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3802
} 
#endif
#line 3804 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(uint2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3805
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3807
::exit(___);}
#if 0
#line 3805
{ 
#line 3806
__surf2DLayeredwriteu2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3807
} 
#endif
#line 3809 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(int4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3810
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3812
::exit(___);}
#if 0
#line 3810
{ 
#line 3811
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3812
} 
#endif
#line 3814 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(uint4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3815
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3817
::exit(___);}
#if 0
#line 3815
{ 
#line 3816
__surf2DLayeredwriteu4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3817
} 
#endif
#line 3819 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(__int64 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3820
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3822
::exit(___);}
#if 0
#line 3820
{ 
#line 3821
__surf2DLayeredwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3822
} 
#endif
#line 3824 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned __int64 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3825
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3827
::exit(___);}
#if 0
#line 3825
{ 
#line 3826
__surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3827
} 
#endif
#line 3829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(longlong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3830
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3832
::exit(___);}
#if 0
#line 3830
{ 
#line 3831
__surf2DLayeredwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3832
} 
#endif
#line 3834 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ulonglong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3835
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3837
::exit(___);}
#if 0
#line 3835
{ 
#line 3836
__surf2DLayeredwritel1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3837
} 
#endif
#line 3839 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(longlong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3840
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3842
::exit(___);}
#if 0
#line 3840
{ 
#line 3841
__surf2DLayeredwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3842
} 
#endif
#line 3844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ulonglong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3845
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3847
::exit(___);}
#if 0
#line 3845
{ 
#line 3846
__surf2DLayeredwritel2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3847
} 
#endif
#line 3851 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3852
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3854
::exit(___);}
#if 0
#line 3852
{ 
#line 3853
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3854
} 
#endif
#line 3856 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3857
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3859
::exit(___);}
#if 0
#line 3857
{ 
#line 3858
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3859
} 
#endif
#line 3861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(long1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3862
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3864
::exit(___);}
#if 0
#line 3862
{ 
#line 3863
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3864
} 
#endif
#line 3866 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ulong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3867
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3869
::exit(___);}
#if 0
#line 3867
{ 
#line 3868
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3869
} 
#endif
#line 3871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(long2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3872
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3874
::exit(___);}
#if 0
#line 3872
{ 
#line 3873
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3874
} 
#endif
#line 3876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ulong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3877
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3879
::exit(___);}
#if 0
#line 3877
{ 
#line 3878
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3879
} 
#endif
#line 3881 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(long4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3882
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3884
::exit(___);}
#if 0
#line 3882
{ 
#line 3883
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3884
} 
#endif
#line 3886 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ulong4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3887
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3889
::exit(___);}
#if 0
#line 3887
{ 
#line 3888
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3889
} 
#endif
#line 3893 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(float val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3894
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3896
::exit(___);}
#if 0
#line 3894
{ 
#line 3895
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3896
} 
#endif
#line 3898 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(float1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3899
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3901
::exit(___);}
#if 0
#line 3899
{ 
#line 3900
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3901
} 
#endif
#line 3903 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(float2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3904
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3906
::exit(___);}
#if 0
#line 3904
{ 
#line 3905
__surf2DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3906
} 
#endif
#line 3908 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(float4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3909
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3911
::exit(___);}
#if 0
#line 3909
{ 
#line 3910
__surf2DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3911
} 
#endif
#line 3947 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3948
surfCubemapwrite(T val, ::surface< void, 12>  surf, int x, int y, int face, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3949
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
#line 3967
::exit(___);}
#if 0
#line 3949
{ 
#line 3950
union { 
#line 3951
T val; 
#line 3952
::uchar1 c1; 
#line 3953
::ushort1 s1; 
#line 3954
::uint1 u1; 
#line 3955
::uint2 u2; 
#line 3956
::uint4 u4; 
#line 3957
} tmp; 
#line 3959
(tmp.val) = val; 
#line 3961
(s == 1) ? ((void)__surfCubemapwritec1(tmp.c1, surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surfCubemapwrites1(tmp.s1, surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surfCubemapwriteu1(tmp.u1, surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surfCubemapwriteu2(tmp.u2, surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surfCubemapwriteu4(tmp.u4, surf, x, y, face, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 3967
} 
#endif
#line 3969 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3970
surfCubemapwrite(T val, ::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3971
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3973
::exit(___);}
#if 0
#line 3971
{ ; 
#line 3972
surfCubemapwrite(val, surf, x, y, face, (int)sizeof(T), mode); 
#line 3973
} 
#endif
#line 3976 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3977
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3979
::exit(___);}
#if 0
#line 3977
{ 
#line 3978
__surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 3979
} 
#endif
#line 3981 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(signed char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3982
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3984
::exit(___);}
#if 0
#line 3982
{ 
#line 3983
__surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 3984
} 
#endif
#line 3986 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(unsigned char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3987
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3989
::exit(___);}
#if 0
#line 3987
{ 
#line 3988
__surfCubemapwritec1(make_uchar1(val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 3989
} 
#endif
#line 3991 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(char1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3992
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3994
::exit(___);}
#if 0
#line 3992
{ 
#line 3993
__surfCubemapwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 3994
} 
#endif
#line 3996 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(uchar1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3997
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3999
::exit(___);}
#if 0
#line 3997
{ 
#line 3998
__surfCubemapwritec1(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 3999
} 
#endif
#line 4001 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(char2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4002
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4004
::exit(___);}
#if 0
#line 4002
{ 
#line 4003
__surfCubemapwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4004
} 
#endif
#line 4006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(uchar2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4007
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4009
::exit(___);}
#if 0
#line 4007
{ 
#line 4008
__surfCubemapwritec2(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4009
} 
#endif
#line 4011 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(char4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4012
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4014
::exit(___);}
#if 0
#line 4012
{ 
#line 4013
__surfCubemapwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4014
} 
#endif
#line 4016 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(uchar4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4017
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4019
::exit(___);}
#if 0
#line 4017
{ 
#line 4018
__surfCubemapwritec4(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4019
} 
#endif
#line 4021 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4022
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4024
::exit(___);}
#if 0
#line 4022
{ 
#line 4023
__surfCubemapwrites1(make_ushort1((unsigned short)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4024
} 
#endif
#line 4026 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(unsigned short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4027
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4029
::exit(___);}
#if 0
#line 4027
{ 
#line 4028
__surfCubemapwrites1(make_ushort1(val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4029
} 
#endif
#line 4031 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(short1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4032
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4034
::exit(___);}
#if 0
#line 4032
{ 
#line 4033
__surfCubemapwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4034
} 
#endif
#line 4036 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ushort1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4037
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4039
::exit(___);}
#if 0
#line 4037
{ 
#line 4038
__surfCubemapwrites1(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4039
} 
#endif
#line 4041 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(short2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4042
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4044
::exit(___);}
#if 0
#line 4042
{ 
#line 4043
__surfCubemapwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4044
} 
#endif
#line 4046 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ushort2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4047
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4049
::exit(___);}
#if 0
#line 4047
{ 
#line 4048
__surfCubemapwrites2(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4049
} 
#endif
#line 4051 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(short4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4052
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4054
::exit(___);}
#if 0
#line 4052
{ 
#line 4053
__surfCubemapwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4054
} 
#endif
#line 4056 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ushort4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4057
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4059
::exit(___);}
#if 0
#line 4057
{ 
#line 4058
__surfCubemapwrites4(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4059
} 
#endif
#line 4061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(int val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4062
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4064
::exit(___);}
#if 0
#line 4062
{ 
#line 4063
__surfCubemapwriteu1(make_uint1((unsigned)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4064
} 
#endif
#line 4066 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(unsigned val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4067
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4069
::exit(___);}
#if 0
#line 4067
{ 
#line 4068
__surfCubemapwriteu1(make_uint1(val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4069
} 
#endif
#line 4071 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(int1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4072
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4074
::exit(___);}
#if 0
#line 4072
{ 
#line 4073
__surfCubemapwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4074
} 
#endif
#line 4076 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(uint1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4077
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4079
::exit(___);}
#if 0
#line 4077
{ 
#line 4078
__surfCubemapwriteu1(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4079
} 
#endif
#line 4081 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(int2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4082
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4084
::exit(___);}
#if 0
#line 4082
{ 
#line 4083
__surfCubemapwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4084
} 
#endif
#line 4086 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(uint2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4087
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4089
::exit(___);}
#if 0
#line 4087
{ 
#line 4088
__surfCubemapwriteu2(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4089
} 
#endif
#line 4091 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(int4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4092
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4094
::exit(___);}
#if 0
#line 4092
{ 
#line 4093
__surfCubemapwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4094
} 
#endif
#line 4096 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(uint4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4097
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4099
::exit(___);}
#if 0
#line 4097
{ 
#line 4098
__surfCubemapwriteu4(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4099
} 
#endif
#line 4101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(__int64 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4102
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4104
::exit(___);}
#if 0
#line 4102
{ 
#line 4103
__surfCubemapwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4104
} 
#endif
#line 4106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(unsigned __int64 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4107
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4109
::exit(___);}
#if 0
#line 4107
{ 
#line 4108
__surfCubemapwritel1(make_ulonglong1(val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4109
} 
#endif
#line 4111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(longlong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4112
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4114
::exit(___);}
#if 0
#line 4112
{ 
#line 4113
__surfCubemapwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4114
} 
#endif
#line 4116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ulonglong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4117
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4119
::exit(___);}
#if 0
#line 4117
{ 
#line 4118
__surfCubemapwritel1(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4119
} 
#endif
#line 4121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(longlong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4122
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4124
::exit(___);}
#if 0
#line 4122
{ 
#line 4123
__surfCubemapwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4124
} 
#endif
#line 4126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ulonglong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4127
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4129
::exit(___);}
#if 0
#line 4127
{ 
#line 4128
__surfCubemapwritel2(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4129
} 
#endif
#line 4133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4134
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4136
::exit(___);}
#if 0
#line 4134
{ 
#line 4135
__surfCubemapwriteu1(make_uint1((unsigned)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4136
} 
#endif
#line 4138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(unsigned long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4139
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4141
::exit(___);}
#if 0
#line 4139
{ 
#line 4140
__surfCubemapwriteu1(make_uint1((unsigned)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4141
} 
#endif
#line 4143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(long1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4144
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4146
::exit(___);}
#if 0
#line 4144
{ 
#line 4145
__surfCubemapwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4146
} 
#endif
#line 4148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ulong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4149
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4151
::exit(___);}
#if 0
#line 4149
{ 
#line 4150
__surfCubemapwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4151
} 
#endif
#line 4153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(long2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4154
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4156
::exit(___);}
#if 0
#line 4154
{ 
#line 4155
__surfCubemapwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4156
} 
#endif
#line 4158 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ulong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4159
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4161
::exit(___);}
#if 0
#line 4159
{ 
#line 4160
__surfCubemapwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4161
} 
#endif
#line 4163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(long4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4164
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4166
::exit(___);}
#if 0
#line 4164
{ 
#line 4165
__surfCubemapwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4166
} 
#endif
#line 4168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ulong4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4169
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4171
::exit(___);}
#if 0
#line 4169
{ 
#line 4170
__surfCubemapwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4171
} 
#endif
#line 4175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(float val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4176
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4178
::exit(___);}
#if 0
#line 4176
{ 
#line 4177
__surfCubemapwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4178
} 
#endif
#line 4180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(float1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4181
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4183
::exit(___);}
#if 0
#line 4181
{ 
#line 4182
__surfCubemapwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4183
} 
#endif
#line 4185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(float2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4186
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4188
::exit(___);}
#if 0
#line 4186
{ 
#line 4187
__surfCubemapwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4188
} 
#endif
#line 4190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(float4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4191
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4193
::exit(___);}
#if 0
#line 4191
{ 
#line 4192
__surfCubemapwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4193
} 
#endif
#line 4229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 4230
surfCubemapLayeredwrite(T val, ::surface< void, 252>  surf, int x, int y, int layerFace, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4231
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
#line 4249
::exit(___);}
#if 0
#line 4231
{ 
#line 4232
union { 
#line 4233
T val; 
#line 4234
::uchar1 c1; 
#line 4235
::ushort1 s1; 
#line 4236
::uint1 u1; 
#line 4237
::uint2 u2; 
#line 4238
::uint4 u4; 
#line 4239
} tmp; 
#line 4241
(tmp.val) = val; 
#line 4243
(s == 1) ? ((void)__surfCubemapLayeredwritec1(tmp.c1, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surfCubemapLayeredwrites1(tmp.s1, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surfCubemapLayeredwriteu1(tmp.u1, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surfCubemapLayeredwriteu2(tmp.u2, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surfCubemapLayeredwriteu4(tmp.u4, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 4249
} 
#endif
#line 4251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 4252
surfCubemapLayeredwrite(T val, ::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4253
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4255
::exit(___);}
#if 0
#line 4253
{ ; 
#line 4254
surfCubemapLayeredwrite(val, surf, x, y, layerFace, (int)sizeof(T), mode); 
#line 4255
} 
#endif
#line 4258 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4259
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4261
::exit(___);}
#if 0
#line 4259
{ 
#line 4260
__surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4261
} 
#endif
#line 4263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(signed char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4264
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4266
::exit(___);}
#if 0
#line 4264
{ 
#line 4265
__surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4266
} 
#endif
#line 4268 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4269
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4271
::exit(___);}
#if 0
#line 4269
{ 
#line 4270
__surfCubemapLayeredwritec1(make_uchar1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4271
} 
#endif
#line 4273 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(char1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4274
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4276
::exit(___);}
#if 0
#line 4274
{ 
#line 4275
__surfCubemapLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4276
} 
#endif
#line 4278 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(uchar1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4279
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4281
::exit(___);}
#if 0
#line 4279
{ 
#line 4280
__surfCubemapLayeredwritec1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4281
} 
#endif
#line 4283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(char2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4284
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4286
::exit(___);}
#if 0
#line 4284
{ 
#line 4285
__surfCubemapLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4286
} 
#endif
#line 4288 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(uchar2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4289
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4291
::exit(___);}
#if 0
#line 4289
{ 
#line 4290
__surfCubemapLayeredwritec2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4291
} 
#endif
#line 4293 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(char4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4294
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4296
::exit(___);}
#if 0
#line 4294
{ 
#line 4295
__surfCubemapLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4296
} 
#endif
#line 4298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(uchar4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4299
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4301
::exit(___);}
#if 0
#line 4299
{ 
#line 4300
__surfCubemapLayeredwritec4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4301
} 
#endif
#line 4303 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4304
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4306
::exit(___);}
#if 0
#line 4304
{ 
#line 4305
__surfCubemapLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4306
} 
#endif
#line 4308 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4309
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4311
::exit(___);}
#if 0
#line 4309
{ 
#line 4310
__surfCubemapLayeredwrites1(make_ushort1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4311
} 
#endif
#line 4313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(short1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4314
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4316
::exit(___);}
#if 0
#line 4314
{ 
#line 4315
__surfCubemapLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4316
} 
#endif
#line 4318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ushort1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4319
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4321
::exit(___);}
#if 0
#line 4319
{ 
#line 4320
__surfCubemapLayeredwrites1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4321
} 
#endif
#line 4323 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(short2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4324
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4326
::exit(___);}
#if 0
#line 4324
{ 
#line 4325
__surfCubemapLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4326
} 
#endif
#line 4328 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ushort2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4329
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4331
::exit(___);}
#if 0
#line 4329
{ 
#line 4330
__surfCubemapLayeredwrites2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4331
} 
#endif
#line 4333 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(short4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4334
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4336
::exit(___);}
#if 0
#line 4334
{ 
#line 4335
__surfCubemapLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4336
} 
#endif
#line 4338 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ushort4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4339
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4341
::exit(___);}
#if 0
#line 4339
{ 
#line 4340
__surfCubemapLayeredwrites4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4341
} 
#endif
#line 4343 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(int val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4344
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4346
::exit(___);}
#if 0
#line 4344
{ 
#line 4345
__surfCubemapLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4346
} 
#endif
#line 4348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4349
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4351
::exit(___);}
#if 0
#line 4349
{ 
#line 4350
__surfCubemapLayeredwriteu1(make_uint1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4351
} 
#endif
#line 4353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(int1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4354
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4356
::exit(___);}
#if 0
#line 4354
{ 
#line 4355
__surfCubemapLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4356
} 
#endif
#line 4358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(uint1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4359
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4361
::exit(___);}
#if 0
#line 4359
{ 
#line 4360
__surfCubemapLayeredwriteu1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4361
} 
#endif
#line 4363 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(int2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4364
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4366
::exit(___);}
#if 0
#line 4364
{ 
#line 4365
__surfCubemapLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4366
} 
#endif
#line 4368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(uint2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4369
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4371
::exit(___);}
#if 0
#line 4369
{ 
#line 4370
__surfCubemapLayeredwriteu2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4371
} 
#endif
#line 4373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(int4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4374
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4376
::exit(___);}
#if 0
#line 4374
{ 
#line 4375
__surfCubemapLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4376
} 
#endif
#line 4378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(uint4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4379
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4381
::exit(___);}
#if 0
#line 4379
{ 
#line 4380
__surfCubemapLayeredwriteu4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4381
} 
#endif
#line 4383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(__int64 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4384
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4386
::exit(___);}
#if 0
#line 4384
{ 
#line 4385
__surfCubemapLayeredwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4386
} 
#endif
#line 4388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned __int64 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4389
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4391
::exit(___);}
#if 0
#line 4389
{ 
#line 4390
__surfCubemapLayeredwritel1(make_ulonglong1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4391
} 
#endif
#line 4393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(longlong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4394
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4396
::exit(___);}
#if 0
#line 4394
{ 
#line 4395
__surfCubemapLayeredwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4396
} 
#endif
#line 4398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulonglong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4399
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4401
::exit(___);}
#if 0
#line 4399
{ 
#line 4400
__surfCubemapLayeredwritel1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4401
} 
#endif
#line 4403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(longlong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4404
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4406
::exit(___);}
#if 0
#line 4404
{ 
#line 4405
__surfCubemapLayeredwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4406
} 
#endif
#line 4408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulonglong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4409
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4411
::exit(___);}
#if 0
#line 4409
{ 
#line 4410
__surfCubemapLayeredwritel2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4411
} 
#endif
#line 4415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4416
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4418
::exit(___);}
#if 0
#line 4416
{ 
#line 4417
__surfCubemapLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4418
} 
#endif
#line 4420 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4421
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4423
::exit(___);}
#if 0
#line 4421
{ 
#line 4422
__surfCubemapLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4423
} 
#endif
#line 4425 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(long1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4426
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4428
::exit(___);}
#if 0
#line 4426
{ 
#line 4427
__surfCubemapLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4428
} 
#endif
#line 4430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4431
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4433
::exit(___);}
#if 0
#line 4431
{ 
#line 4432
__surfCubemapLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4433
} 
#endif
#line 4435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(long2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4436
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4438
::exit(___);}
#if 0
#line 4436
{ 
#line 4437
__surfCubemapLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4438
} 
#endif
#line 4440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4441
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4443
::exit(___);}
#if 0
#line 4441
{ 
#line 4442
__surfCubemapLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4443
} 
#endif
#line 4445 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(long4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4446
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4448
::exit(___);}
#if 0
#line 4446
{ 
#line 4447
__surfCubemapLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4448
} 
#endif
#line 4450 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulong4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4451
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4453
::exit(___);}
#if 0
#line 4451
{ 
#line 4452
__surfCubemapLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4453
} 
#endif
#line 4457 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(float val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4458
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4460
::exit(___);}
#if 0
#line 4458
{ 
#line 4459
__surfCubemapLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4460
} 
#endif
#line 4462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(float1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4463
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4465
::exit(___);}
#if 0
#line 4463
{ 
#line 4464
__surfCubemapLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4465
} 
#endif
#line 4467 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(float2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4468
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4470
::exit(___);}
#if 0
#line 4468
{ 
#line 4469
__surfCubemapLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4470
} 
#endif
#line 4472 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(float4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4473
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4475
::exit(___);}
#if 0
#line 4473
{ 
#line 4474
__surfCubemapLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4475
} 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex1Dfetch(texture< char, 1, cudaReadModeElementType>  t, int x) 
#line 97
{int volatile ___ = 1;(void)t;(void)x;
#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 105
} 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1Dfetch(texture< signed char, 1, cudaReadModeElementType>  t, int x) 
#line 108
{int volatile ___ = 1;(void)t;(void)x;
#line 112
::exit(___);}
#if 0
#line 108
{ 
#line 109
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 111
return (signed char)(v.x); 
#line 112
} 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1Dfetch(texture< unsigned char, 1, cudaReadModeElementType>  t, int x) 
#line 115
{int volatile ___ = 1;(void)t;(void)x;
#line 119
::exit(___);}
#if 0
#line 115
{ 
#line 116
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 118
return (unsigned char)(v.x); 
#line 119
} 
#endif
#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1Dfetch(texture< char1, 1, cudaReadModeElementType>  t, int x) 
#line 122
{int volatile ___ = 1;(void)t;(void)x;
#line 126
::exit(___);}
#if 0
#line 122
{ 
#line 123
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 125
return make_char1(v.x); 
#line 126
} 
#endif
#line 128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1Dfetch(texture< uchar1, 1, cudaReadModeElementType>  t, int x) 
#line 129
{int volatile ___ = 1;(void)t;(void)x;
#line 133
::exit(___);}
#if 0
#line 129
{ 
#line 130
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 132
return make_uchar1(v.x); 
#line 133
} 
#endif
#line 135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1Dfetch(texture< char2, 1, cudaReadModeElementType>  t, int x) 
#line 136
{int volatile ___ = 1;(void)t;(void)x;
#line 140
::exit(___);}
#if 0
#line 136
{ 
#line 137
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 139
return make_char2(v.x, v.y); 
#line 140
} 
#endif
#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1Dfetch(texture< uchar2, 1, cudaReadModeElementType>  t, int x) 
#line 143
{int volatile ___ = 1;(void)t;(void)x;
#line 147
::exit(___);}
#if 0
#line 143
{ 
#line 144
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 146
return make_uchar2(v.x, v.y); 
#line 147
} 
#endif
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1Dfetch(texture< char4, 1, cudaReadModeElementType>  t, int x) 
#line 150
{int volatile ___ = 1;(void)t;(void)x;
#line 154
::exit(___);}
#if 0
#line 150
{ 
#line 151
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 153
return make_char4(v.x, v.y, v.z, v.w); 
#line 154
} 
#endif
#line 156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1Dfetch(texture< uchar4, 1, cudaReadModeElementType>  t, int x) 
#line 157
{int volatile ___ = 1;(void)t;(void)x;
#line 161
::exit(___);}
#if 0
#line 157
{ 
#line 158
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 160
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 161
} 
#endif
#line 169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex1Dfetch(texture< short, 1, cudaReadModeElementType>  t, int x) 
#line 170
{int volatile ___ = 1;(void)t;(void)x;
#line 174
::exit(___);}
#if 0
#line 170
{ 
#line 171
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 173
return (short)(v.x); 
#line 174
} 
#endif
#line 176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1Dfetch(texture< unsigned short, 1, cudaReadModeElementType>  t, int x) 
#line 177
{int volatile ___ = 1;(void)t;(void)x;
#line 181
::exit(___);}
#if 0
#line 177
{ 
#line 178
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 180
return (unsigned short)(v.x); 
#line 181
} 
#endif
#line 183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1Dfetch(texture< short1, 1, cudaReadModeElementType>  t, int x) 
#line 184
{int volatile ___ = 1;(void)t;(void)x;
#line 188
::exit(___);}
#if 0
#line 184
{ 
#line 185
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 187
return make_short1(v.x); 
#line 188
} 
#endif
#line 190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1Dfetch(texture< ushort1, 1, cudaReadModeElementType>  t, int x) 
#line 191
{int volatile ___ = 1;(void)t;(void)x;
#line 195
::exit(___);}
#if 0
#line 191
{ 
#line 192
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 194
return make_ushort1(v.x); 
#line 195
} 
#endif
#line 197 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1Dfetch(texture< short2, 1, cudaReadModeElementType>  t, int x) 
#line 198
{int volatile ___ = 1;(void)t;(void)x;
#line 202
::exit(___);}
#if 0
#line 198
{ 
#line 199
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 201
return make_short2(v.x, v.y); 
#line 202
} 
#endif
#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1Dfetch(texture< ushort2, 1, cudaReadModeElementType>  t, int x) 
#line 205
{int volatile ___ = 1;(void)t;(void)x;
#line 209
::exit(___);}
#if 0
#line 205
{ 
#line 206
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 208
return make_ushort2(v.x, v.y); 
#line 209
} 
#endif
#line 211 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1Dfetch(texture< short4, 1, cudaReadModeElementType>  t, int x) 
#line 212
{int volatile ___ = 1;(void)t;(void)x;
#line 216
::exit(___);}
#if 0
#line 212
{ 
#line 213
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 215
return make_short4(v.x, v.y, v.z, v.w); 
#line 216
} 
#endif
#line 218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1Dfetch(texture< ushort4, 1, cudaReadModeElementType>  t, int x) 
#line 219
{int volatile ___ = 1;(void)t;(void)x;
#line 223
::exit(___);}
#if 0
#line 219
{ 
#line 220
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 222
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 223
} 
#endif
#line 231 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex1Dfetch(texture< int, 1, cudaReadModeElementType>  t, int x) 
#line 232
{int volatile ___ = 1;(void)t;(void)x;
#line 236
::exit(___);}
#if 0
#line 232
{ 
#line 233
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 235
return v.x; 
#line 236
} 
#endif
#line 238 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1Dfetch(texture< unsigned, 1, cudaReadModeElementType>  t, int x) 
#line 239
{int volatile ___ = 1;(void)t;(void)x;
#line 243
::exit(___);}
#if 0
#line 239
{ 
#line 240
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 242
return v.x; 
#line 243
} 
#endif
#line 245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1Dfetch(texture< int1, 1, cudaReadModeElementType>  t, int x) 
#line 246
{int volatile ___ = 1;(void)t;(void)x;
#line 250
::exit(___);}
#if 0
#line 246
{ 
#line 247
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 249
return make_int1(v.x); 
#line 250
} 
#endif
#line 252 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1Dfetch(texture< uint1, 1, cudaReadModeElementType>  t, int x) 
#line 253
{int volatile ___ = 1;(void)t;(void)x;
#line 257
::exit(___);}
#if 0
#line 253
{ 
#line 254
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 256
return make_uint1(v.x); 
#line 257
} 
#endif
#line 259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1Dfetch(texture< int2, 1, cudaReadModeElementType>  t, int x) 
#line 260
{int volatile ___ = 1;(void)t;(void)x;
#line 264
::exit(___);}
#if 0
#line 260
{ 
#line 261
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 263
return make_int2(v.x, v.y); 
#line 264
} 
#endif
#line 266 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1Dfetch(texture< uint2, 1, cudaReadModeElementType>  t, int x) 
#line 267
{int volatile ___ = 1;(void)t;(void)x;
#line 271
::exit(___);}
#if 0
#line 267
{ 
#line 268
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 270
return make_uint2(v.x, v.y); 
#line 271
} 
#endif
#line 273 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1Dfetch(texture< int4, 1, cudaReadModeElementType>  t, int x) 
#line 274
{int volatile ___ = 1;(void)t;(void)x;
#line 278
::exit(___);}
#if 0
#line 274
{ 
#line 275
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 277
return make_int4(v.x, v.y, v.z, v.w); 
#line 278
} 
#endif
#line 280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1Dfetch(texture< uint4, 1, cudaReadModeElementType>  t, int x) 
#line 281
{int volatile ___ = 1;(void)t;(void)x;
#line 285
::exit(___);}
#if 0
#line 281
{ 
#line 282
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 284
return make_uint4(v.x, v.y, v.z, v.w); 
#line 285
} 
#endif
#line 295 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex1Dfetch(texture< long, 1, cudaReadModeElementType>  t, int x) 
#line 296
{int volatile ___ = 1;(void)t;(void)x;
#line 300
::exit(___);}
#if 0
#line 296
{ 
#line 297
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 299
return (long)(v.x); 
#line 300
} 
#endif
#line 302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1Dfetch(texture< unsigned long, 1, cudaReadModeElementType>  t, int x) 
#line 303
{int volatile ___ = 1;(void)t;(void)x;
#line 307
::exit(___);}
#if 0
#line 303
{ 
#line 304
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 306
return (unsigned long)(v.x); 
#line 307
} 
#endif
#line 309 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1Dfetch(texture< long1, 1, cudaReadModeElementType>  t, int x) 
#line 310
{int volatile ___ = 1;(void)t;(void)x;
#line 314
::exit(___);}
#if 0
#line 310
{ 
#line 311
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 313
return make_long1(v.x); 
#line 314
} 
#endif
#line 316 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1Dfetch(texture< ulong1, 1, cudaReadModeElementType>  t, int x) 
#line 317
{int volatile ___ = 1;(void)t;(void)x;
#line 321
::exit(___);}
#if 0
#line 317
{ 
#line 318
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 320
return make_ulong1(v.x); 
#line 321
} 
#endif
#line 323 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1Dfetch(texture< long2, 1, cudaReadModeElementType>  t, int x) 
#line 324
{int volatile ___ = 1;(void)t;(void)x;
#line 328
::exit(___);}
#if 0
#line 324
{ 
#line 325
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 327
return make_long2(v.x, v.y); 
#line 328
} 
#endif
#line 330 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1Dfetch(texture< ulong2, 1, cudaReadModeElementType>  t, int x) 
#line 331
{int volatile ___ = 1;(void)t;(void)x;
#line 335
::exit(___);}
#if 0
#line 331
{ 
#line 332
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 334
return make_ulong2(v.x, v.y); 
#line 335
} 
#endif
#line 337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1Dfetch(texture< long4, 1, cudaReadModeElementType>  t, int x) 
#line 338
{int volatile ___ = 1;(void)t;(void)x;
#line 342
::exit(___);}
#if 0
#line 338
{ 
#line 339
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 341
return make_long4(v.x, v.y, v.z, v.w); 
#line 342
} 
#endif
#line 344 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1Dfetch(texture< ulong4, 1, cudaReadModeElementType>  t, int x) 
#line 345
{int volatile ___ = 1;(void)t;(void)x;
#line 349
::exit(___);}
#if 0
#line 345
{ 
#line 346
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 348
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 349
} 
#endif
#line 359 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< float, 1, cudaReadModeElementType>  t, int x) 
#line 360
{int volatile ___ = 1;(void)t;(void)x;
#line 364
::exit(___);}
#if 0
#line 360
{ 
#line 361
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 363
return v.x; 
#line 364
} 
#endif
#line 366 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1Dfetch(texture< float1, 1, cudaReadModeElementType>  t, int x) 
#line 367
{int volatile ___ = 1;(void)t;(void)x;
#line 371
::exit(___);}
#if 0
#line 367
{ 
#line 368
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 370
return make_float1(v.x); 
#line 371
} 
#endif
#line 373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1Dfetch(texture< float2, 1, cudaReadModeElementType>  t, int x) 
#line 374
{int volatile ___ = 1;(void)t;(void)x;
#line 378
::exit(___);}
#if 0
#line 374
{ 
#line 375
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 377
return make_float2(v.x, v.y); 
#line 378
} 
#endif
#line 380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1Dfetch(texture< float4, 1, cudaReadModeElementType>  t, int x) 
#line 381
{int volatile ___ = 1;(void)t;(void)x;
#line 385
::exit(___);}
#if 0
#line 381
{ 
#line 382
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 384
return make_float4(v.x, v.y, v.z, v.w); 
#line 385
} 
#endif
#line 393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< char, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 394
{int volatile ___ = 1;(void)t;(void)x;
#line 403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 402
return w.x; 
#line 403
} 
#endif
#line 405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 406
{int volatile ___ = 1;(void)t;(void)x;
#line 411
::exit(___);}
#if 0
#line 406
{ 
#line 407
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 408
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 410
return w.x; 
#line 411
} 
#endif
#line 413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 414
{int volatile ___ = 1;(void)t;(void)x;
#line 419
::exit(___);}
#if 0
#line 414
{ 
#line 415
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 416
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 418
return w.x; 
#line 419
} 
#endif
#line 421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1Dfetch(texture< char1, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 422
{int volatile ___ = 1;(void)t;(void)x;
#line 427
::exit(___);}
#if 0
#line 422
{ 
#line 423
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 424
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 426
return make_float1(w.x); 
#line 427
} 
#endif
#line 429 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1Dfetch(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 430
{int volatile ___ = 1;(void)t;(void)x;
#line 435
::exit(___);}
#if 0
#line 430
{ 
#line 431
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 432
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 434
return make_float1(w.x); 
#line 435
} 
#endif
#line 437 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1Dfetch(texture< char2, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 438
{int volatile ___ = 1;(void)t;(void)x;
#line 443
::exit(___);}
#if 0
#line 438
{ 
#line 439
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 440
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 442
return make_float2(w.x, w.y); 
#line 443
} 
#endif
#line 445 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1Dfetch(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 446
{int volatile ___ = 1;(void)t;(void)x;
#line 451
::exit(___);}
#if 0
#line 446
{ 
#line 447
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 448
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 450
return make_float2(w.x, w.y); 
#line 451
} 
#endif
#line 453 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1Dfetch(texture< char4, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 454
{int volatile ___ = 1;(void)t;(void)x;
#line 459
::exit(___);}
#if 0
#line 454
{ 
#line 455
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 456
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 458
return make_float4(w.x, w.y, w.z, w.w); 
#line 459
} 
#endif
#line 461 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1Dfetch(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 462
{int volatile ___ = 1;(void)t;(void)x;
#line 467
::exit(___);}
#if 0
#line 462
{ 
#line 463
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 464
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 466
return make_float4(w.x, w.y, w.z, w.w); 
#line 467
} 
#endif
#line 475 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< short, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 476
{int volatile ___ = 1;(void)t;(void)x;
#line 481
::exit(___);}
#if 0
#line 476
{ 
#line 477
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 478
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 480
return w.x; 
#line 481
} 
#endif
#line 483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 484
{int volatile ___ = 1;(void)t;(void)x;
#line 489
::exit(___);}
#if 0
#line 484
{ 
#line 485
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 486
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 488
return w.x; 
#line 489
} 
#endif
#line 491 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1Dfetch(texture< short1, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 492
{int volatile ___ = 1;(void)t;(void)x;
#line 497
::exit(___);}
#if 0
#line 492
{ 
#line 493
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 494
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 496
return make_float1(w.x); 
#line 497
} 
#endif
#line 499 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1Dfetch(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 500
{int volatile ___ = 1;(void)t;(void)x;
#line 505
::exit(___);}
#if 0
#line 500
{ 
#line 501
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 502
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 504
return make_float1(w.x); 
#line 505
} 
#endif
#line 507 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1Dfetch(texture< short2, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 508
{int volatile ___ = 1;(void)t;(void)x;
#line 513
::exit(___);}
#if 0
#line 508
{ 
#line 509
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 510
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 512
return make_float2(w.x, w.y); 
#line 513
} 
#endif
#line 515 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1Dfetch(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 516
{int volatile ___ = 1;(void)t;(void)x;
#line 521
::exit(___);}
#if 0
#line 516
{ 
#line 517
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 518
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 520
return make_float2(w.x, w.y); 
#line 521
} 
#endif
#line 523 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1Dfetch(texture< short4, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 524
{int volatile ___ = 1;(void)t;(void)x;
#line 529
::exit(___);}
#if 0
#line 524
{ 
#line 525
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 526
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 528
return make_float4(w.x, w.y, w.z, w.w); 
#line 529
} 
#endif
#line 531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1Dfetch(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 532
{int volatile ___ = 1;(void)t;(void)x;
#line 537
::exit(___);}
#if 0
#line 532
{ 
#line 533
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 534
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 536
return make_float4(w.x, w.y, w.z, w.w); 
#line 537
} 
#endif
#line 545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex1D(texture< char, 1, cudaReadModeElementType>  t, float x) 
#line 546
{int volatile ___ = 1;(void)t;(void)x;
#line 554 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 546 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 553 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 554
} 
#endif
#line 556 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1D(texture< signed char, 1, cudaReadModeElementType>  t, float x) 
#line 557
{int volatile ___ = 1;(void)t;(void)x;
#line 561
::exit(___);}
#if 0
#line 557
{ 
#line 558
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 560
return (signed char)(v.x); 
#line 561
} 
#endif
#line 563 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1D(texture< unsigned char, 1, cudaReadModeElementType>  t, float x) 
#line 564
{int volatile ___ = 1;(void)t;(void)x;
#line 568
::exit(___);}
#if 0
#line 564
{ 
#line 565
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 567
return (unsigned char)(v.x); 
#line 568
} 
#endif
#line 570 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1D(texture< char1, 1, cudaReadModeElementType>  t, float x) 
#line 571
{int volatile ___ = 1;(void)t;(void)x;
#line 575
::exit(___);}
#if 0
#line 571
{ 
#line 572
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 574
return make_char1(v.x); 
#line 575
} 
#endif
#line 577 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1D(texture< uchar1, 1, cudaReadModeElementType>  t, float x) 
#line 578
{int volatile ___ = 1;(void)t;(void)x;
#line 582
::exit(___);}
#if 0
#line 578
{ 
#line 579
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 581
return make_uchar1(v.x); 
#line 582
} 
#endif
#line 584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1D(texture< char2, 1, cudaReadModeElementType>  t, float x) 
#line 585
{int volatile ___ = 1;(void)t;(void)x;
#line 589
::exit(___);}
#if 0
#line 585
{ 
#line 586
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 588
return make_char2(v.x, v.y); 
#line 589
} 
#endif
#line 591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1D(texture< uchar2, 1, cudaReadModeElementType>  t, float x) 
#line 592
{int volatile ___ = 1;(void)t;(void)x;
#line 596
::exit(___);}
#if 0
#line 592
{ 
#line 593
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 595
return make_uchar2(v.x, v.y); 
#line 596
} 
#endif
#line 598 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1D(texture< char4, 1, cudaReadModeElementType>  t, float x) 
#line 599
{int volatile ___ = 1;(void)t;(void)x;
#line 603
::exit(___);}
#if 0
#line 599
{ 
#line 600
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 602
return make_char4(v.x, v.y, v.z, v.w); 
#line 603
} 
#endif
#line 605 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1D(texture< uchar4, 1, cudaReadModeElementType>  t, float x) 
#line 606
{int volatile ___ = 1;(void)t;(void)x;
#line 610
::exit(___);}
#if 0
#line 606
{ 
#line 607
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 609
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 610
} 
#endif
#line 618 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex1D(texture< short, 1, cudaReadModeElementType>  t, float x) 
#line 619
{int volatile ___ = 1;(void)t;(void)x;
#line 623
::exit(___);}
#if 0
#line 619
{ 
#line 620
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 622
return (short)(v.x); 
#line 623
} 
#endif
#line 625 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1D(texture< unsigned short, 1, cudaReadModeElementType>  t, float x) 
#line 626
{int volatile ___ = 1;(void)t;(void)x;
#line 630
::exit(___);}
#if 0
#line 626
{ 
#line 627
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 629
return (unsigned short)(v.x); 
#line 630
} 
#endif
#line 632 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1D(texture< short1, 1, cudaReadModeElementType>  t, float x) 
#line 633
{int volatile ___ = 1;(void)t;(void)x;
#line 637
::exit(___);}
#if 0
#line 633
{ 
#line 634
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 636
return make_short1(v.x); 
#line 637
} 
#endif
#line 639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1D(texture< ushort1, 1, cudaReadModeElementType>  t, float x) 
#line 640
{int volatile ___ = 1;(void)t;(void)x;
#line 644
::exit(___);}
#if 0
#line 640
{ 
#line 641
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 643
return make_ushort1(v.x); 
#line 644
} 
#endif
#line 646 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1D(texture< short2, 1, cudaReadModeElementType>  t, float x) 
#line 647
{int volatile ___ = 1;(void)t;(void)x;
#line 651
::exit(___);}
#if 0
#line 647
{ 
#line 648
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 650
return make_short2(v.x, v.y); 
#line 651
} 
#endif
#line 653 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1D(texture< ushort2, 1, cudaReadModeElementType>  t, float x) 
#line 654
{int volatile ___ = 1;(void)t;(void)x;
#line 658
::exit(___);}
#if 0
#line 654
{ 
#line 655
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 657
return make_ushort2(v.x, v.y); 
#line 658
} 
#endif
#line 660 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1D(texture< short4, 1, cudaReadModeElementType>  t, float x) 
#line 661
{int volatile ___ = 1;(void)t;(void)x;
#line 665
::exit(___);}
#if 0
#line 661
{ 
#line 662
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 664
return make_short4(v.x, v.y, v.z, v.w); 
#line 665
} 
#endif
#line 667 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1D(texture< ushort4, 1, cudaReadModeElementType>  t, float x) 
#line 668
{int volatile ___ = 1;(void)t;(void)x;
#line 672
::exit(___);}
#if 0
#line 668
{ 
#line 669
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 671
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 672
} 
#endif
#line 680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex1D(texture< int, 1, cudaReadModeElementType>  t, float x) 
#line 681
{int volatile ___ = 1;(void)t;(void)x;
#line 685
::exit(___);}
#if 0
#line 681
{ 
#line 682
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 684
return v.x; 
#line 685
} 
#endif
#line 687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1D(texture< unsigned, 1, cudaReadModeElementType>  t, float x) 
#line 688
{int volatile ___ = 1;(void)t;(void)x;
#line 692
::exit(___);}
#if 0
#line 688
{ 
#line 689
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 691
return v.x; 
#line 692
} 
#endif
#line 694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1D(texture< int1, 1, cudaReadModeElementType>  t, float x) 
#line 695
{int volatile ___ = 1;(void)t;(void)x;
#line 699
::exit(___);}
#if 0
#line 695
{ 
#line 696
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 698
return make_int1(v.x); 
#line 699
} 
#endif
#line 701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1D(texture< uint1, 1, cudaReadModeElementType>  t, float x) 
#line 702
{int volatile ___ = 1;(void)t;(void)x;
#line 706
::exit(___);}
#if 0
#line 702
{ 
#line 703
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 705
return make_uint1(v.x); 
#line 706
} 
#endif
#line 708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1D(texture< int2, 1, cudaReadModeElementType>  t, float x) 
#line 709
{int volatile ___ = 1;(void)t;(void)x;
#line 713
::exit(___);}
#if 0
#line 709
{ 
#line 710
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 712
return make_int2(v.x, v.y); 
#line 713
} 
#endif
#line 715 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1D(texture< uint2, 1, cudaReadModeElementType>  t, float x) 
#line 716
{int volatile ___ = 1;(void)t;(void)x;
#line 720
::exit(___);}
#if 0
#line 716
{ 
#line 717
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 719
return make_uint2(v.x, v.y); 
#line 720
} 
#endif
#line 722 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1D(texture< int4, 1, cudaReadModeElementType>  t, float x) 
#line 723
{int volatile ___ = 1;(void)t;(void)x;
#line 727
::exit(___);}
#if 0
#line 723
{ 
#line 724
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 726
return make_int4(v.x, v.y, v.z, v.w); 
#line 727
} 
#endif
#line 729 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1D(texture< uint4, 1, cudaReadModeElementType>  t, float x) 
#line 730
{int volatile ___ = 1;(void)t;(void)x;
#line 734
::exit(___);}
#if 0
#line 730
{ 
#line 731
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 733
return make_uint4(v.x, v.y, v.z, v.w); 
#line 734
} 
#endif
#line 750 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex1D(texture< long, 1, cudaReadModeElementType>  t, float x) 
#line 751
{int volatile ___ = 1;(void)t;(void)x;
#line 755
::exit(___);}
#if 0
#line 751
{ 
#line 752
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 754
return (long)(v.x); 
#line 755
} 
#endif
#line 757 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1D(texture< unsigned long, 1, cudaReadModeElementType>  t, float x) 
#line 758
{int volatile ___ = 1;(void)t;(void)x;
#line 762
::exit(___);}
#if 0
#line 758
{ 
#line 759
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 761
return (unsigned long)(v.x); 
#line 762
} 
#endif
#line 764 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1D(texture< long1, 1, cudaReadModeElementType>  t, float x) 
#line 765
{int volatile ___ = 1;(void)t;(void)x;
#line 769
::exit(___);}
#if 0
#line 765
{ 
#line 766
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 768
return make_long1(v.x); 
#line 769
} 
#endif
#line 771 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1D(texture< ulong1, 1, cudaReadModeElementType>  t, float x) 
#line 772
{int volatile ___ = 1;(void)t;(void)x;
#line 776
::exit(___);}
#if 0
#line 772
{ 
#line 773
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 775
return make_ulong1(v.x); 
#line 776
} 
#endif
#line 778 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1D(texture< long2, 1, cudaReadModeElementType>  t, float x) 
#line 779
{int volatile ___ = 1;(void)t;(void)x;
#line 783
::exit(___);}
#if 0
#line 779
{ 
#line 780
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 782
return make_long2(v.x, v.y); 
#line 783
} 
#endif
#line 785 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1D(texture< ulong2, 1, cudaReadModeElementType>  t, float x) 
#line 786
{int volatile ___ = 1;(void)t;(void)x;
#line 790
::exit(___);}
#if 0
#line 786
{ 
#line 787
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 789
return make_ulong2(v.x, v.y); 
#line 790
} 
#endif
#line 792 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1D(texture< long4, 1, cudaReadModeElementType>  t, float x) 
#line 793
{int volatile ___ = 1;(void)t;(void)x;
#line 797
::exit(___);}
#if 0
#line 793
{ 
#line 794
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 796
return make_long4(v.x, v.y, v.z, v.w); 
#line 797
} 
#endif
#line 799 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1D(texture< ulong4, 1, cudaReadModeElementType>  t, float x) 
#line 800
{int volatile ___ = 1;(void)t;(void)x;
#line 804
::exit(___);}
#if 0
#line 800
{ 
#line 801
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 803
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 804
} 
#endif
#line 814 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< float, 1, cudaReadModeElementType>  t, float x) 
#line 815
{int volatile ___ = 1;(void)t;(void)x;
#line 819
::exit(___);}
#if 0
#line 815
{ 
#line 816
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
#line 818
return v.x; 
#line 819
} 
#endif
#line 821 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1D(texture< float1, 1, cudaReadModeElementType>  t, float x) 
#line 822
{int volatile ___ = 1;(void)t;(void)x;
#line 826
::exit(___);}
#if 0
#line 822
{ 
#line 823
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
#line 825
return make_float1(v.x); 
#line 826
} 
#endif
#line 828 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1D(texture< float2, 1, cudaReadModeElementType>  t, float x) 
#line 829
{int volatile ___ = 1;(void)t;(void)x;
#line 833
::exit(___);}
#if 0
#line 829
{ 
#line 830
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
#line 832
return make_float2(v.x, v.y); 
#line 833
} 
#endif
#line 835 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1D(texture< float4, 1, cudaReadModeElementType>  t, float x) 
#line 836
{int volatile ___ = 1;(void)t;(void)x;
#line 840
::exit(___);}
#if 0
#line 836
{ 
#line 837
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
#line 839
return make_float4(v.x, v.y, v.z, v.w); 
#line 840
} 
#endif
#line 848 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 849
{int volatile ___ = 1;(void)t;(void)x;
#line 858 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 849 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 853 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 855 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 857
return w.x; 
#line 858
} 
#endif
#line 860 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 861
{int volatile ___ = 1;(void)t;(void)x;
#line 866
::exit(___);}
#if 0
#line 861
{ 
#line 862
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 863
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 865
return w.x; 
#line 866
} 
#endif
#line 868 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 869
{int volatile ___ = 1;(void)t;(void)x;
#line 874
::exit(___);}
#if 0
#line 869
{ 
#line 870
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 871
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 873
return w.x; 
#line 874
} 
#endif
#line 876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1D(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 877
{int volatile ___ = 1;(void)t;(void)x;
#line 882
::exit(___);}
#if 0
#line 877
{ 
#line 878
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 879
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 881
return make_float1(w.x); 
#line 882
} 
#endif
#line 884 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1D(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 885
{int volatile ___ = 1;(void)t;(void)x;
#line 890
::exit(___);}
#if 0
#line 885
{ 
#line 886
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 887
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 889
return make_float1(w.x); 
#line 890
} 
#endif
#line 892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1D(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 893
{int volatile ___ = 1;(void)t;(void)x;
#line 898
::exit(___);}
#if 0
#line 893
{ 
#line 894
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 895
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 897
return make_float2(w.x, w.y); 
#line 898
} 
#endif
#line 900 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1D(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 901
{int volatile ___ = 1;(void)t;(void)x;
#line 906
::exit(___);}
#if 0
#line 901
{ 
#line 902
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 903
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 905
return make_float2(w.x, w.y); 
#line 906
} 
#endif
#line 908 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1D(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 909
{int volatile ___ = 1;(void)t;(void)x;
#line 914
::exit(___);}
#if 0
#line 909
{ 
#line 910
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 911
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 913
return make_float4(w.x, w.y, w.z, w.w); 
#line 914
} 
#endif
#line 916 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1D(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 917
{int volatile ___ = 1;(void)t;(void)x;
#line 922
::exit(___);}
#if 0
#line 917
{ 
#line 918
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 919
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 921
return make_float4(w.x, w.y, w.z, w.w); 
#line 922
} 
#endif
#line 930 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 931
{int volatile ___ = 1;(void)t;(void)x;
#line 936
::exit(___);}
#if 0
#line 931
{ 
#line 932
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 933
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 935
return w.x; 
#line 936
} 
#endif
#line 938 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 939
{int volatile ___ = 1;(void)t;(void)x;
#line 944
::exit(___);}
#if 0
#line 939
{ 
#line 940
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 941
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 943
return w.x; 
#line 944
} 
#endif
#line 946 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1D(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 947
{int volatile ___ = 1;(void)t;(void)x;
#line 952
::exit(___);}
#if 0
#line 947
{ 
#line 948
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 949
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 951
return make_float1(w.x); 
#line 952
} 
#endif
#line 954 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1D(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 955
{int volatile ___ = 1;(void)t;(void)x;
#line 960
::exit(___);}
#if 0
#line 955
{ 
#line 956
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 957
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 959
return make_float1(w.x); 
#line 960
} 
#endif
#line 962 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1D(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 963
{int volatile ___ = 1;(void)t;(void)x;
#line 968
::exit(___);}
#if 0
#line 963
{ 
#line 964
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 965
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 967
return make_float2(w.x, w.y); 
#line 968
} 
#endif
#line 970 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1D(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 971
{int volatile ___ = 1;(void)t;(void)x;
#line 976
::exit(___);}
#if 0
#line 971
{ 
#line 972
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 973
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 975
return make_float2(w.x, w.y); 
#line 976
} 
#endif
#line 978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1D(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 979
{int volatile ___ = 1;(void)t;(void)x;
#line 984
::exit(___);}
#if 0
#line 979
{ 
#line 980
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 981
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 983
return make_float4(w.x, w.y, w.z, w.w); 
#line 984
} 
#endif
#line 986 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1D(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 987
{int volatile ___ = 1;(void)t;(void)x;
#line 992
::exit(___);}
#if 0
#line 987
{ 
#line 988
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 989
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 991
return make_float4(w.x, w.y, w.z, w.w); 
#line 992
} 
#endif
#line 1000 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex2D(texture< char, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1001
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1009 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 1001 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 1005 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1008 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 1009
} 
#endif
#line 1011 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex2D(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1012
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1016
::exit(___);}
#if 0
#line 1012
{ 
#line 1013
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1015
return (signed char)(v.x); 
#line 1016
} 
#endif
#line 1018 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex2D(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1019
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1023
::exit(___);}
#if 0
#line 1019
{ 
#line 1020
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1022
return (unsigned char)(v.x); 
#line 1023
} 
#endif
#line 1025 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex2D(texture< char1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1026
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1030
::exit(___);}
#if 0
#line 1026
{ 
#line 1027
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1029
return make_char1(v.x); 
#line 1030
} 
#endif
#line 1032 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex2D(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1033
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1037
::exit(___);}
#if 0
#line 1033
{ 
#line 1034
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1036
return make_uchar1(v.x); 
#line 1037
} 
#endif
#line 1039 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex2D(texture< char2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1040
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1044
::exit(___);}
#if 0
#line 1040
{ 
#line 1041
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1043
return make_char2(v.x, v.y); 
#line 1044
} 
#endif
#line 1046 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex2D(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1047
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1051
::exit(___);}
#if 0
#line 1047
{ 
#line 1048
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1050
return make_uchar2(v.x, v.y); 
#line 1051
} 
#endif
#line 1053 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2D(texture< char4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1054
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1058
::exit(___);}
#if 0
#line 1054
{ 
#line 1055
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1057
return make_char4(v.x, v.y, v.z, v.w); 
#line 1058
} 
#endif
#line 1060 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2D(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1061
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1065
::exit(___);}
#if 0
#line 1061
{ 
#line 1062
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1064
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 1065
} 
#endif
#line 1073 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex2D(texture< short, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1074
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1078
::exit(___);}
#if 0
#line 1074
{ 
#line 1075
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1077
return (short)(v.x); 
#line 1078
} 
#endif
#line 1080 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex2D(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1081
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1085
::exit(___);}
#if 0
#line 1081
{ 
#line 1082
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1084
return (unsigned short)(v.x); 
#line 1085
} 
#endif
#line 1087 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex2D(texture< short1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1088
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1092
::exit(___);}
#if 0
#line 1088
{ 
#line 1089
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1091
return make_short1(v.x); 
#line 1092
} 
#endif
#line 1094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex2D(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1095
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1099
::exit(___);}
#if 0
#line 1095
{ 
#line 1096
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1098
return make_ushort1(v.x); 
#line 1099
} 
#endif
#line 1101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex2D(texture< short2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1102
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1106
::exit(___);}
#if 0
#line 1102
{ 
#line 1103
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1105
return make_short2(v.x, v.y); 
#line 1106
} 
#endif
#line 1108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex2D(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1109
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1113
::exit(___);}
#if 0
#line 1109
{ 
#line 1110
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1112
return make_ushort2(v.x, v.y); 
#line 1113
} 
#endif
#line 1115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2D(texture< short4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1116
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1120
::exit(___);}
#if 0
#line 1116
{ 
#line 1117
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1119
return make_short4(v.x, v.y, v.z, v.w); 
#line 1120
} 
#endif
#line 1122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2D(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1123
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1127
::exit(___);}
#if 0
#line 1123
{ 
#line 1124
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1126
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 1127
} 
#endif
#line 1135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex2D(texture< int, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1136
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1140
::exit(___);}
#if 0
#line 1136
{ 
#line 1137
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1139
return v.x; 
#line 1140
} 
#endif
#line 1142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex2D(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1143
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1147
::exit(___);}
#if 0
#line 1143
{ 
#line 1144
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1146
return v.x; 
#line 1147
} 
#endif
#line 1149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex2D(texture< int1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1150
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1154
::exit(___);}
#if 0
#line 1150
{ 
#line 1151
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1153
return make_int1(v.x); 
#line 1154
} 
#endif
#line 1156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex2D(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1157
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1161
::exit(___);}
#if 0
#line 1157
{ 
#line 1158
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1160
return make_uint1(v.x); 
#line 1161
} 
#endif
#line 1163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex2D(texture< int2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1164
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1168
::exit(___);}
#if 0
#line 1164
{ 
#line 1165
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1167
return make_int2(v.x, v.y); 
#line 1168
} 
#endif
#line 1170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex2D(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1171
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1175
::exit(___);}
#if 0
#line 1171
{ 
#line 1172
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1174
return make_uint2(v.x, v.y); 
#line 1175
} 
#endif
#line 1177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2D(texture< int4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1178
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1182
::exit(___);}
#if 0
#line 1178
{ 
#line 1179
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1181
return make_int4(v.x, v.y, v.z, v.w); 
#line 1182
} 
#endif
#line 1184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2D(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1185
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1189
::exit(___);}
#if 0
#line 1185
{ 
#line 1186
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1188
return make_uint4(v.x, v.y, v.z, v.w); 
#line 1189
} 
#endif
#line 1199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex2D(texture< long, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1200
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1204
::exit(___);}
#if 0
#line 1200
{ 
#line 1201
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1203
return (long)(v.x); 
#line 1204
} 
#endif
#line 1206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex2D(texture< unsigned long, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1207
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1211
::exit(___);}
#if 0
#line 1207
{ 
#line 1208
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1210
return (unsigned long)(v.x); 
#line 1211
} 
#endif
#line 1213 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex2D(texture< long1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1214
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1218
::exit(___);}
#if 0
#line 1214
{ 
#line 1215
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1217
return make_long1(v.x); 
#line 1218
} 
#endif
#line 1220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex2D(texture< ulong1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1221
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1225
::exit(___);}
#if 0
#line 1221
{ 
#line 1222
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1224
return make_ulong1(v.x); 
#line 1225
} 
#endif
#line 1227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex2D(texture< long2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1228
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1232
::exit(___);}
#if 0
#line 1228
{ 
#line 1229
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1231
return make_long2(v.x, v.y); 
#line 1232
} 
#endif
#line 1234 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex2D(texture< ulong2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1235
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1239
::exit(___);}
#if 0
#line 1235
{ 
#line 1236
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1238
return make_ulong2(v.x, v.y); 
#line 1239
} 
#endif
#line 1241 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex2D(texture< long4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1242
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1246
::exit(___);}
#if 0
#line 1242
{ 
#line 1243
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1245
return make_long4(v.x, v.y, v.z, v.w); 
#line 1246
} 
#endif
#line 1248 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex2D(texture< ulong4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1249
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1253
::exit(___);}
#if 0
#line 1249
{ 
#line 1250
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1252
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 1253
} 
#endif
#line 1263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< float, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1264
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1268
::exit(___);}
#if 0
#line 1264
{ 
#line 1265
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
#line 1267
return v.x; 
#line 1268
} 
#endif
#line 1270 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2D(texture< float1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1271
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1275
::exit(___);}
#if 0
#line 1271
{ 
#line 1272
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
#line 1274
return make_float1(v.x); 
#line 1275
} 
#endif
#line 1277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2D(texture< float2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1278
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1282
::exit(___);}
#if 0
#line 1278
{ 
#line 1279
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
#line 1281
return make_float2(v.x, v.y); 
#line 1282
} 
#endif
#line 1284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2D(texture< float4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1285
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1289
::exit(___);}
#if 0
#line 1285
{ 
#line 1286
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
#line 1288
return make_float4(v.x, v.y, v.z, v.w); 
#line 1289
} 
#endif
#line 1297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1298
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 1298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 1302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1306
return w.x; 
#line 1307
} 
#endif
#line 1309 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1310
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1315
::exit(___);}
#if 0
#line 1310
{ 
#line 1311
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1312
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1314
return w.x; 
#line 1315
} 
#endif
#line 1317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1318
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1323
::exit(___);}
#if 0
#line 1318
{ 
#line 1319
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1320
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1322
return w.x; 
#line 1323
} 
#endif
#line 1325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2D(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1326
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1331
::exit(___);}
#if 0
#line 1326
{ 
#line 1327
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1328
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1330
return make_float1(w.x); 
#line 1331
} 
#endif
#line 1333 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2D(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1334
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1339
::exit(___);}
#if 0
#line 1334
{ 
#line 1335
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1336
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1338
return make_float1(w.x); 
#line 1339
} 
#endif
#line 1341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2D(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1342
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1347
::exit(___);}
#if 0
#line 1342
{ 
#line 1343
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1344
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1346
return make_float2(w.x, w.y); 
#line 1347
} 
#endif
#line 1349 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2D(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1350
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1355
::exit(___);}
#if 0
#line 1350
{ 
#line 1351
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1352
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1354
return make_float2(w.x, w.y); 
#line 1355
} 
#endif
#line 1357 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2D(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1358
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1363
::exit(___);}
#if 0
#line 1358
{ 
#line 1359
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1360
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1362
return make_float4(w.x, w.y, w.z, w.w); 
#line 1363
} 
#endif
#line 1365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2D(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1366
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1371
::exit(___);}
#if 0
#line 1366
{ 
#line 1367
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1368
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1370
return make_float4(w.x, w.y, w.z, w.w); 
#line 1371
} 
#endif
#line 1379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1380
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1385
::exit(___);}
#if 0
#line 1380
{ 
#line 1381
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1382
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1384
return w.x; 
#line 1385
} 
#endif
#line 1387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1388
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1393
::exit(___);}
#if 0
#line 1388
{ 
#line 1389
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1390
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1392
return w.x; 
#line 1393
} 
#endif
#line 1395 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2D(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1396
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1401
::exit(___);}
#if 0
#line 1396
{ 
#line 1397
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1398
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1400
return make_float1(w.x); 
#line 1401
} 
#endif
#line 1403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2D(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1404
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1409
::exit(___);}
#if 0
#line 1404
{ 
#line 1405
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1406
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1408
return make_float1(w.x); 
#line 1409
} 
#endif
#line 1411 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2D(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1412
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1417
::exit(___);}
#if 0
#line 1412
{ 
#line 1413
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1414
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1416
return make_float2(w.x, w.y); 
#line 1417
} 
#endif
#line 1419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2D(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1420
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1425
::exit(___);}
#if 0
#line 1420
{ 
#line 1421
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1422
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1424
return make_float2(w.x, w.y); 
#line 1425
} 
#endif
#line 1427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2D(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1428
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1433
::exit(___);}
#if 0
#line 1428
{ 
#line 1429
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1430
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1432
return make_float4(w.x, w.y, w.z, w.w); 
#line 1433
} 
#endif
#line 1435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2D(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1436
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1441
::exit(___);}
#if 0
#line 1436
{ 
#line 1437
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1438
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1440
return make_float4(w.x, w.y, w.z, w.w); 
#line 1441
} 
#endif
#line 1449 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex1DLayered(texture< char, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1450
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1458 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 1450 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 1454 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1457 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 1458
} 
#endif
#line 1460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1DLayered(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1461
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1465
::exit(___);}
#if 0
#line 1461
{ 
#line 1462
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1464
return (signed char)(v.x); 
#line 1465
} 
#endif
#line 1467 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1DLayered(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1468
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1472
::exit(___);}
#if 0
#line 1468
{ 
#line 1469
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1471
return (unsigned char)(v.x); 
#line 1472
} 
#endif
#line 1474 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1DLayered(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1475
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1479
::exit(___);}
#if 0
#line 1475
{ 
#line 1476
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1478
return make_char1(v.x); 
#line 1479
} 
#endif
#line 1481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1DLayered(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1482
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1486
::exit(___);}
#if 0
#line 1482
{ 
#line 1483
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1485
return make_uchar1(v.x); 
#line 1486
} 
#endif
#line 1488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1DLayered(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1489
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1493
::exit(___);}
#if 0
#line 1489
{ 
#line 1490
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1492
return make_char2(v.x, v.y); 
#line 1493
} 
#endif
#line 1495 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1DLayered(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1496
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1500
::exit(___);}
#if 0
#line 1496
{ 
#line 1497
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1499
return make_uchar2(v.x, v.y); 
#line 1500
} 
#endif
#line 1502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1DLayered(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1503
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1507
::exit(___);}
#if 0
#line 1503
{ 
#line 1504
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1506
return make_char4(v.x, v.y, v.z, v.w); 
#line 1507
} 
#endif
#line 1509 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1DLayered(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1510
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1514
::exit(___);}
#if 0
#line 1510
{ 
#line 1511
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1513
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 1514
} 
#endif
#line 1522 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex1DLayered(texture< short, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1523
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1527
::exit(___);}
#if 0
#line 1523
{ 
#line 1524
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1526
return (short)(v.x); 
#line 1527
} 
#endif
#line 1529 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1DLayered(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1530
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1534
::exit(___);}
#if 0
#line 1530
{ 
#line 1531
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1533
return (unsigned short)(v.x); 
#line 1534
} 
#endif
#line 1536 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1DLayered(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1537
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1541
::exit(___);}
#if 0
#line 1537
{ 
#line 1538
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1540
return make_short1(v.x); 
#line 1541
} 
#endif
#line 1543 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1DLayered(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1544
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1548
::exit(___);}
#if 0
#line 1544
{ 
#line 1545
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1547
return make_ushort1(v.x); 
#line 1548
} 
#endif
#line 1550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1DLayered(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1551
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1555
::exit(___);}
#if 0
#line 1551
{ 
#line 1552
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1554
return make_short2(v.x, v.y); 
#line 1555
} 
#endif
#line 1557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1DLayered(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1558
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1562
::exit(___);}
#if 0
#line 1558
{ 
#line 1559
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1561
return make_ushort2(v.x, v.y); 
#line 1562
} 
#endif
#line 1564 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1DLayered(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1565
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1569
::exit(___);}
#if 0
#line 1565
{ 
#line 1566
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1568
return make_short4(v.x, v.y, v.z, v.w); 
#line 1569
} 
#endif
#line 1571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1DLayered(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1572
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1576
::exit(___);}
#if 0
#line 1572
{ 
#line 1573
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1575
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 1576
} 
#endif
#line 1584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex1DLayered(texture< int, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1585
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1589
::exit(___);}
#if 0
#line 1585
{ 
#line 1586
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1588
return v.x; 
#line 1589
} 
#endif
#line 1591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1DLayered(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1592
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1596
::exit(___);}
#if 0
#line 1592
{ 
#line 1593
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1595
return v.x; 
#line 1596
} 
#endif
#line 1598 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1DLayered(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1599
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1603
::exit(___);}
#if 0
#line 1599
{ 
#line 1600
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1602
return make_int1(v.x); 
#line 1603
} 
#endif
#line 1605 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1DLayered(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1606
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1610
::exit(___);}
#if 0
#line 1606
{ 
#line 1607
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1609
return make_uint1(v.x); 
#line 1610
} 
#endif
#line 1612 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1DLayered(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1613
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1617
::exit(___);}
#if 0
#line 1613
{ 
#line 1614
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1616
return make_int2(v.x, v.y); 
#line 1617
} 
#endif
#line 1619 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1DLayered(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1620
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1624
::exit(___);}
#if 0
#line 1620
{ 
#line 1621
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1623
return make_uint2(v.x, v.y); 
#line 1624
} 
#endif
#line 1626 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1DLayered(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1627
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1631
::exit(___);}
#if 0
#line 1627
{ 
#line 1628
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1630
return make_int4(v.x, v.y, v.z, v.w); 
#line 1631
} 
#endif
#line 1633 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1DLayered(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1634
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1638
::exit(___);}
#if 0
#line 1634
{ 
#line 1635
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1637
return make_uint4(v.x, v.y, v.z, v.w); 
#line 1638
} 
#endif
#line 1648 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex1DLayered(texture< long, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1649
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1653
::exit(___);}
#if 0
#line 1649
{ 
#line 1650
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1652
return (long)(v.x); 
#line 1653
} 
#endif
#line 1655 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1DLayered(texture< unsigned long, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1656
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1660
::exit(___);}
#if 0
#line 1656
{ 
#line 1657
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1659
return (unsigned long)(v.x); 
#line 1660
} 
#endif
#line 1662 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1DLayered(texture< long1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1663
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1667
::exit(___);}
#if 0
#line 1663
{ 
#line 1664
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1666
return make_long1(v.x); 
#line 1667
} 
#endif
#line 1669 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1DLayered(texture< ulong1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1670
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1674
::exit(___);}
#if 0
#line 1670
{ 
#line 1671
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1673
return make_ulong1(v.x); 
#line 1674
} 
#endif
#line 1676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1DLayered(texture< long2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1677
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1681
::exit(___);}
#if 0
#line 1677
{ 
#line 1678
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1680
return make_long2(v.x, v.y); 
#line 1681
} 
#endif
#line 1683 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1DLayered(texture< ulong2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1684
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1688
::exit(___);}
#if 0
#line 1684
{ 
#line 1685
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1687
return make_ulong2(v.x, v.y); 
#line 1688
} 
#endif
#line 1690 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1DLayered(texture< long4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1691
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1695
::exit(___);}
#if 0
#line 1691
{ 
#line 1692
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1694
return make_long4(v.x, v.y, v.z, v.w); 
#line 1695
} 
#endif
#line 1697 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1DLayered(texture< ulong4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1698
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1702
::exit(___);}
#if 0
#line 1698
{ 
#line 1699
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1701
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 1702
} 
#endif
#line 1712 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< float, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1713
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1717
::exit(___);}
#if 0
#line 1713
{ 
#line 1714
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1716
return v.x; 
#line 1717
} 
#endif
#line 1719 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayered(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1720
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1724
::exit(___);}
#if 0
#line 1720
{ 
#line 1721
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1723
return make_float1(v.x); 
#line 1724
} 
#endif
#line 1726 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayered(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1727
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1731
::exit(___);}
#if 0
#line 1727
{ 
#line 1728
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1730
return make_float2(v.x, v.y); 
#line 1731
} 
#endif
#line 1733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayered(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1734
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1738
::exit(___);}
#if 0
#line 1734
{ 
#line 1735
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1737
return make_float4(v.x, v.y, v.z, v.w); 
#line 1738
} 
#endif
#line 1746 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1747
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1756 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 1747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 1751 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1753 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1755
return w.x; 
#line 1756
} 
#endif
#line 1758 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1759
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1764
::exit(___);}
#if 0
#line 1759
{ 
#line 1760
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1761
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1763
return w.x; 
#line 1764
} 
#endif
#line 1766 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1767
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1772
::exit(___);}
#if 0
#line 1767
{ 
#line 1768
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1769
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1771
return w.x; 
#line 1772
} 
#endif
#line 1774 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayered(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1775
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1780
::exit(___);}
#if 0
#line 1775
{ 
#line 1776
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1777
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1779
return make_float1(w.x); 
#line 1780
} 
#endif
#line 1782 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayered(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1783
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1788
::exit(___);}
#if 0
#line 1783
{ 
#line 1784
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1785
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1787
return make_float1(w.x); 
#line 1788
} 
#endif
#line 1790 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayered(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1791
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1796
::exit(___);}
#if 0
#line 1791
{ 
#line 1792
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1793
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1795
return make_float2(w.x, w.y); 
#line 1796
} 
#endif
#line 1798 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayered(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1799
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1804
::exit(___);}
#if 0
#line 1799
{ 
#line 1800
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1801
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1803
return make_float2(w.x, w.y); 
#line 1804
} 
#endif
#line 1806 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayered(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1807
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1812
::exit(___);}
#if 0
#line 1807
{ 
#line 1808
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1809
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1811
return make_float4(w.x, w.y, w.z, w.w); 
#line 1812
} 
#endif
#line 1814 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayered(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1815
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1820
::exit(___);}
#if 0
#line 1815
{ 
#line 1816
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1817
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1819
return make_float4(w.x, w.y, w.z, w.w); 
#line 1820
} 
#endif
#line 1828 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1829
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1834
::exit(___);}
#if 0
#line 1829
{ 
#line 1830
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1831
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1833
return w.x; 
#line 1834
} 
#endif
#line 1836 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1837
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1842
::exit(___);}
#if 0
#line 1837
{ 
#line 1838
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1839
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1841
return w.x; 
#line 1842
} 
#endif
#line 1844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayered(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1845
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1850
::exit(___);}
#if 0
#line 1845
{ 
#line 1846
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1847
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1849
return make_float1(w.x); 
#line 1850
} 
#endif
#line 1852 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayered(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1853
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1858
::exit(___);}
#if 0
#line 1853
{ 
#line 1854
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1855
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1857
return make_float1(w.x); 
#line 1858
} 
#endif
#line 1860 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayered(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1861
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1866
::exit(___);}
#if 0
#line 1861
{ 
#line 1862
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1863
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1865
return make_float2(w.x, w.y); 
#line 1866
} 
#endif
#line 1868 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayered(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1869
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1874
::exit(___);}
#if 0
#line 1869
{ 
#line 1870
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1871
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1873
return make_float2(w.x, w.y); 
#line 1874
} 
#endif
#line 1876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayered(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1877
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1882
::exit(___);}
#if 0
#line 1877
{ 
#line 1878
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1879
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1881
return make_float4(w.x, w.y, w.z, w.w); 
#line 1882
} 
#endif
#line 1884 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayered(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1885
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1890
::exit(___);}
#if 0
#line 1885
{ 
#line 1886
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1887
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1889
return make_float4(w.x, w.y, w.z, w.w); 
#line 1890
} 
#endif
#line 1898 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex2DLayered(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1899
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 1899 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 1903 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 1907
} 
#endif
#line 1909 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex2DLayered(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1910
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1914
::exit(___);}
#if 0
#line 1910
{ 
#line 1911
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1913
return (signed char)(v.x); 
#line 1914
} 
#endif
#line 1916 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex2DLayered(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1917
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1921
::exit(___);}
#if 0
#line 1917
{ 
#line 1918
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1920
return (unsigned char)(v.x); 
#line 1921
} 
#endif
#line 1923 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex2DLayered(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1924
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1928
::exit(___);}
#if 0
#line 1924
{ 
#line 1925
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1927
return make_char1(v.x); 
#line 1928
} 
#endif
#line 1930 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex2DLayered(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1931
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1935
::exit(___);}
#if 0
#line 1931
{ 
#line 1932
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1934
return make_uchar1(v.x); 
#line 1935
} 
#endif
#line 1937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex2DLayered(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1942
::exit(___);}
#if 0
#line 1938
{ 
#line 1939
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1941
return make_char2(v.x, v.y); 
#line 1942
} 
#endif
#line 1944 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex2DLayered(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1945
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1949
::exit(___);}
#if 0
#line 1945
{ 
#line 1946
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1948
return make_uchar2(v.x, v.y); 
#line 1949
} 
#endif
#line 1951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2DLayered(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1952
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1956
::exit(___);}
#if 0
#line 1952
{ 
#line 1953
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1955
return make_char4(v.x, v.y, v.z, v.w); 
#line 1956
} 
#endif
#line 1958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2DLayered(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1959
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1963
::exit(___);}
#if 0
#line 1959
{ 
#line 1960
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1962
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 1963
} 
#endif
#line 1971 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex2DLayered(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1972
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1976
::exit(___);}
#if 0
#line 1972
{ 
#line 1973
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1975
return (short)(v.x); 
#line 1976
} 
#endif
#line 1978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex2DLayered(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1979
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1983
::exit(___);}
#if 0
#line 1979
{ 
#line 1980
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1982
return (unsigned short)(v.x); 
#line 1983
} 
#endif
#line 1985 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex2DLayered(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1986
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1990
::exit(___);}
#if 0
#line 1986
{ 
#line 1987
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1989
return make_short1(v.x); 
#line 1990
} 
#endif
#line 1992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex2DLayered(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1993
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1997
::exit(___);}
#if 0
#line 1993
{ 
#line 1994
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1996
return make_ushort1(v.x); 
#line 1997
} 
#endif
#line 1999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex2DLayered(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2004
::exit(___);}
#if 0
#line 2000
{ 
#line 2001
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2003
return make_short2(v.x, v.y); 
#line 2004
} 
#endif
#line 2006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex2DLayered(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2007
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2011
::exit(___);}
#if 0
#line 2007
{ 
#line 2008
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2010
return make_ushort2(v.x, v.y); 
#line 2011
} 
#endif
#line 2013 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2DLayered(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2014
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2018
::exit(___);}
#if 0
#line 2014
{ 
#line 2015
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2017
return make_short4(v.x, v.y, v.z, v.w); 
#line 2018
} 
#endif
#line 2020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2DLayered(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2021
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2025
::exit(___);}
#if 0
#line 2021
{ 
#line 2022
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2024
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 2025
} 
#endif
#line 2033 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex2DLayered(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2034
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2038
::exit(___);}
#if 0
#line 2034
{ 
#line 2035
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2037
return v.x; 
#line 2038
} 
#endif
#line 2040 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex2DLayered(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2041
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2045
::exit(___);}
#if 0
#line 2041
{ 
#line 2042
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2044
return v.x; 
#line 2045
} 
#endif
#line 2047 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex2DLayered(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2048
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2052
::exit(___);}
#if 0
#line 2048
{ 
#line 2049
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2051
return make_int1(v.x); 
#line 2052
} 
#endif
#line 2054 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex2DLayered(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2055
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2059
::exit(___);}
#if 0
#line 2055
{ 
#line 2056
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2058
return make_uint1(v.x); 
#line 2059
} 
#endif
#line 2061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex2DLayered(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2062
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2066
::exit(___);}
#if 0
#line 2062
{ 
#line 2063
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2065
return make_int2(v.x, v.y); 
#line 2066
} 
#endif
#line 2068 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex2DLayered(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2069
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2073
::exit(___);}
#if 0
#line 2069
{ 
#line 2070
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2072
return make_uint2(v.x, v.y); 
#line 2073
} 
#endif
#line 2075 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2DLayered(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2076
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2080
::exit(___);}
#if 0
#line 2076
{ 
#line 2077
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2079
return make_int4(v.x, v.y, v.z, v.w); 
#line 2080
} 
#endif
#line 2082 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2DLayered(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2083
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2087
::exit(___);}
#if 0
#line 2083
{ 
#line 2084
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2086
return make_uint4(v.x, v.y, v.z, v.w); 
#line 2087
} 
#endif
#line 2097 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex2DLayered(texture< long, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2098
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2102
::exit(___);}
#if 0
#line 2098
{ 
#line 2099
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2101
return (long)(v.x); 
#line 2102
} 
#endif
#line 2104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex2DLayered(texture< unsigned long, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2105
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2109
::exit(___);}
#if 0
#line 2105
{ 
#line 2106
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2108
return (unsigned long)(v.x); 
#line 2109
} 
#endif
#line 2111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex2DLayered(texture< long1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2112
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2116
::exit(___);}
#if 0
#line 2112
{ 
#line 2113
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2115
return make_long1(v.x); 
#line 2116
} 
#endif
#line 2118 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex2DLayered(texture< ulong1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2119
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2123
::exit(___);}
#if 0
#line 2119
{ 
#line 2120
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2122
return make_ulong1(v.x); 
#line 2123
} 
#endif
#line 2125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex2DLayered(texture< long2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2126
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2130
::exit(___);}
#if 0
#line 2126
{ 
#line 2127
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2129
return make_long2(v.x, v.y); 
#line 2130
} 
#endif
#line 2132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex2DLayered(texture< ulong2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2133
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2137
::exit(___);}
#if 0
#line 2133
{ 
#line 2134
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2136
return make_ulong2(v.x, v.y); 
#line 2137
} 
#endif
#line 2139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex2DLayered(texture< long4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2140
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2144
::exit(___);}
#if 0
#line 2140
{ 
#line 2141
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2143
return make_long4(v.x, v.y, v.z, v.w); 
#line 2144
} 
#endif
#line 2146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex2DLayered(texture< ulong4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2147
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2151
::exit(___);}
#if 0
#line 2147
{ 
#line 2148
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2150
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 2151
} 
#endif
#line 2161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2162
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2166
::exit(___);}
#if 0
#line 2162
{ 
#line 2163
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2165
return v.x; 
#line 2166
} 
#endif
#line 2168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayered(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2169
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2173
::exit(___);}
#if 0
#line 2169
{ 
#line 2170
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2172
return make_float1(v.x); 
#line 2173
} 
#endif
#line 2175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayered(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2176
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2180
::exit(___);}
#if 0
#line 2176
{ 
#line 2177
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2179
return make_float2(v.x, v.y); 
#line 2180
} 
#endif
#line 2182 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayered(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2183
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2187
::exit(___);}
#if 0
#line 2183
{ 
#line 2184
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2186
return make_float4(v.x, v.y, v.z, v.w); 
#line 2187
} 
#endif
#line 2195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2196
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 2196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 2200 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2204
return w.x; 
#line 2205
} 
#endif
#line 2207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2208
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2213
::exit(___);}
#if 0
#line 2208
{ 
#line 2209
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2210
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2212
return w.x; 
#line 2213
} 
#endif
#line 2215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2216
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2221
::exit(___);}
#if 0
#line 2216
{ 
#line 2217
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2218
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2220
return w.x; 
#line 2221
} 
#endif
#line 2223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayered(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2224
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2229
::exit(___);}
#if 0
#line 2224
{ 
#line 2225
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2226
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2228
return make_float1(w.x); 
#line 2229
} 
#endif
#line 2231 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayered(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2232
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2237
::exit(___);}
#if 0
#line 2232
{ 
#line 2233
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2234
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2236
return make_float1(w.x); 
#line 2237
} 
#endif
#line 2239 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayered(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2240
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2245
::exit(___);}
#if 0
#line 2240
{ 
#line 2241
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2242
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2244
return make_float2(w.x, w.y); 
#line 2245
} 
#endif
#line 2247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayered(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2248
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2253
::exit(___);}
#if 0
#line 2248
{ 
#line 2249
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2250
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2252
return make_float2(w.x, w.y); 
#line 2253
} 
#endif
#line 2255 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayered(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2256
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2261
::exit(___);}
#if 0
#line 2256
{ 
#line 2257
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2258
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2260
return make_float4(w.x, w.y, w.z, w.w); 
#line 2261
} 
#endif
#line 2263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayered(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2264
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2269
::exit(___);}
#if 0
#line 2264
{ 
#line 2265
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2266
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2268
return make_float4(w.x, w.y, w.z, w.w); 
#line 2269
} 
#endif
#line 2277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2278
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2283
::exit(___);}
#if 0
#line 2278
{ 
#line 2279
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2280
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2282
return w.x; 
#line 2283
} 
#endif
#line 2285 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2286
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2291
::exit(___);}
#if 0
#line 2286
{ 
#line 2287
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2288
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2290
return w.x; 
#line 2291
} 
#endif
#line 2293 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayered(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2294
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2299
::exit(___);}
#if 0
#line 2294
{ 
#line 2295
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2296
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2298
return make_float1(w.x); 
#line 2299
} 
#endif
#line 2301 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayered(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2302
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2307
::exit(___);}
#if 0
#line 2302
{ 
#line 2303
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2304
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2306
return make_float1(w.x); 
#line 2307
} 
#endif
#line 2309 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayered(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2310
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2315
::exit(___);}
#if 0
#line 2310
{ 
#line 2311
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2312
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2314
return make_float2(w.x, w.y); 
#line 2315
} 
#endif
#line 2317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayered(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2318
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2323
::exit(___);}
#if 0
#line 2318
{ 
#line 2319
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2320
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2322
return make_float2(w.x, w.y); 
#line 2323
} 
#endif
#line 2325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayered(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2326
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2331
::exit(___);}
#if 0
#line 2326
{ 
#line 2327
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2328
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2330
return make_float4(w.x, w.y, w.z, w.w); 
#line 2331
} 
#endif
#line 2333 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayered(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2334
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2339
::exit(___);}
#if 0
#line 2334
{ 
#line 2335
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2336
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2338
return make_float4(w.x, w.y, w.z, w.w); 
#line 2339
} 
#endif
#line 2347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex3D(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2348
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2356 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 2348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 2352 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2355 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 2356
} 
#endif
#line 2358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex3D(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2359
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2363
::exit(___);}
#if 0
#line 2359
{ 
#line 2360
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2362
return (signed char)(v.x); 
#line 2363
} 
#endif
#line 2365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex3D(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2366
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2370
::exit(___);}
#if 0
#line 2366
{ 
#line 2367
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2369
return (unsigned char)(v.x); 
#line 2370
} 
#endif
#line 2372 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex3D(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2373
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2377
::exit(___);}
#if 0
#line 2373
{ 
#line 2374
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2376
return make_char1(v.x); 
#line 2377
} 
#endif
#line 2379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex3D(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2380
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2384
::exit(___);}
#if 0
#line 2380
{ 
#line 2381
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2383
return make_uchar1(v.x); 
#line 2384
} 
#endif
#line 2386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex3D(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2387
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2391
::exit(___);}
#if 0
#line 2387
{ 
#line 2388
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2390
return make_char2(v.x, v.y); 
#line 2391
} 
#endif
#line 2393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex3D(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2394
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2398
::exit(___);}
#if 0
#line 2394
{ 
#line 2395
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2397
return make_uchar2(v.x, v.y); 
#line 2398
} 
#endif
#line 2400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex3D(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2401
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2405
::exit(___);}
#if 0
#line 2401
{ 
#line 2402
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2404
return make_char4(v.x, v.y, v.z, v.w); 
#line 2405
} 
#endif
#line 2407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex3D(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2408
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2412
::exit(___);}
#if 0
#line 2408
{ 
#line 2409
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2411
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 2412
} 
#endif
#line 2420 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex3D(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2421
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2425
::exit(___);}
#if 0
#line 2421
{ 
#line 2422
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2424
return (short)(v.x); 
#line 2425
} 
#endif
#line 2427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex3D(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2428
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2432
::exit(___);}
#if 0
#line 2428
{ 
#line 2429
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2431
return (unsigned short)(v.x); 
#line 2432
} 
#endif
#line 2434 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex3D(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2435
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2439
::exit(___);}
#if 0
#line 2435
{ 
#line 2436
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2438
return make_short1(v.x); 
#line 2439
} 
#endif
#line 2441 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex3D(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2442
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2446
::exit(___);}
#if 0
#line 2442
{ 
#line 2443
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2445
return make_ushort1(v.x); 
#line 2446
} 
#endif
#line 2448 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex3D(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2449
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2453
::exit(___);}
#if 0
#line 2449
{ 
#line 2450
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2452
return make_short2(v.x, v.y); 
#line 2453
} 
#endif
#line 2455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex3D(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2456
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2460
::exit(___);}
#if 0
#line 2456
{ 
#line 2457
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2459
return make_ushort2(v.x, v.y); 
#line 2460
} 
#endif
#line 2462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex3D(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2463
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2467
::exit(___);}
#if 0
#line 2463
{ 
#line 2464
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2466
return make_short4(v.x, v.y, v.z, v.w); 
#line 2467
} 
#endif
#line 2469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex3D(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2470
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2474
::exit(___);}
#if 0
#line 2470
{ 
#line 2471
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2473
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 2474
} 
#endif
#line 2482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex3D(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2483
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2487
::exit(___);}
#if 0
#line 2483
{ 
#line 2484
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2486
return v.x; 
#line 2487
} 
#endif
#line 2489 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex3D(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2490
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2494
::exit(___);}
#if 0
#line 2490
{ 
#line 2491
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2493
return v.x; 
#line 2494
} 
#endif
#line 2496 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex3D(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2497
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2501
::exit(___);}
#if 0
#line 2497
{ 
#line 2498
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2500
return make_int1(v.x); 
#line 2501
} 
#endif
#line 2503 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex3D(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2504
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2508
::exit(___);}
#if 0
#line 2504
{ 
#line 2505
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2507
return make_uint1(v.x); 
#line 2508
} 
#endif
#line 2510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex3D(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2511
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2515
::exit(___);}
#if 0
#line 2511
{ 
#line 2512
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2514
return make_int2(v.x, v.y); 
#line 2515
} 
#endif
#line 2517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex3D(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2518
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2522
::exit(___);}
#if 0
#line 2518
{ 
#line 2519
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2521
return make_uint2(v.x, v.y); 
#line 2522
} 
#endif
#line 2524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex3D(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2525
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2529
::exit(___);}
#if 0
#line 2525
{ 
#line 2526
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2528
return make_int4(v.x, v.y, v.z, v.w); 
#line 2529
} 
#endif
#line 2531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex3D(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2532
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2536
::exit(___);}
#if 0
#line 2532
{ 
#line 2533
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2535
return make_uint4(v.x, v.y, v.z, v.w); 
#line 2536
} 
#endif
#line 2546 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex3D(texture< long, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2547
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2551
::exit(___);}
#if 0
#line 2547
{ 
#line 2548
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2550
return (long)(v.x); 
#line 2551
} 
#endif
#line 2553 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex3D(texture< unsigned long, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2554
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2558
::exit(___);}
#if 0
#line 2554
{ 
#line 2555
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2557
return (unsigned long)(v.x); 
#line 2558
} 
#endif
#line 2560 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex3D(texture< long1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2561
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2565
::exit(___);}
#if 0
#line 2561
{ 
#line 2562
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2564
return make_long1(v.x); 
#line 2565
} 
#endif
#line 2567 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex3D(texture< ulong1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2568
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2572
::exit(___);}
#if 0
#line 2568
{ 
#line 2569
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2571
return make_ulong1(v.x); 
#line 2572
} 
#endif
#line 2574 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex3D(texture< long2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2575
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2579
::exit(___);}
#if 0
#line 2575
{ 
#line 2576
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2578
return make_long2(v.x, v.y); 
#line 2579
} 
#endif
#line 2581 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex3D(texture< ulong2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2582
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2586
::exit(___);}
#if 0
#line 2582
{ 
#line 2583
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2585
return make_ulong2(v.x, v.y); 
#line 2586
} 
#endif
#line 2588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex3D(texture< long4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2589
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2593
::exit(___);}
#if 0
#line 2589
{ 
#line 2590
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2592
return make_long4(v.x, v.y, v.z, v.w); 
#line 2593
} 
#endif
#line 2595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex3D(texture< ulong4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2596
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2600
::exit(___);}
#if 0
#line 2596
{ 
#line 2597
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2599
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 2600
} 
#endif
#line 2610 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2611
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2615
::exit(___);}
#if 0
#line 2611
{ 
#line 2612
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
#line 2614
return v.x; 
#line 2615
} 
#endif
#line 2617 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3D(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2618
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2622
::exit(___);}
#if 0
#line 2618
{ 
#line 2619
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
#line 2621
return make_float1(v.x); 
#line 2622
} 
#endif
#line 2624 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3D(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2625
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2629
::exit(___);}
#if 0
#line 2625
{ 
#line 2626
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
#line 2628
return make_float2(v.x, v.y); 
#line 2629
} 
#endif
#line 2631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3D(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2632
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2636
::exit(___);}
#if 0
#line 2632
{ 
#line 2633
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
#line 2635
return make_float4(v.x, v.y, v.z, v.w); 
#line 2636
} 
#endif
#line 2644 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2645
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2654 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 2645 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 2649 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2651 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2653
return w.x; 
#line 2654
} 
#endif
#line 2656 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2657
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2662
::exit(___);}
#if 0
#line 2657
{ 
#line 2658
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2659
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2661
return w.x; 
#line 2662
} 
#endif
#line 2664 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2665
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2670
::exit(___);}
#if 0
#line 2665
{ 
#line 2666
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2667
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2669
return w.x; 
#line 2670
} 
#endif
#line 2672 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3D(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2678
::exit(___);}
#if 0
#line 2673
{ 
#line 2674
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2675
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2677
return make_float1(w.x); 
#line 2678
} 
#endif
#line 2680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3D(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2686
::exit(___);}
#if 0
#line 2681
{ 
#line 2682
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2683
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2685
return make_float1(w.x); 
#line 2686
} 
#endif
#line 2688 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3D(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2689
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2694
::exit(___);}
#if 0
#line 2689
{ 
#line 2690
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2691
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2693
return make_float2(w.x, w.y); 
#line 2694
} 
#endif
#line 2696 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3D(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2697
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2702
::exit(___);}
#if 0
#line 2697
{ 
#line 2698
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2699
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2701
return make_float2(w.x, w.y); 
#line 2702
} 
#endif
#line 2704 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3D(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2705
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2710
::exit(___);}
#if 0
#line 2705
{ 
#line 2706
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2707
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2709
return make_float4(w.x, w.y, w.z, w.w); 
#line 2710
} 
#endif
#line 2712 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3D(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2713
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2718
::exit(___);}
#if 0
#line 2713
{ 
#line 2714
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2715
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2717
return make_float4(w.x, w.y, w.z, w.w); 
#line 2718
} 
#endif
#line 2726 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2727
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2732
::exit(___);}
#if 0
#line 2727
{ 
#line 2728
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2729
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2731
return w.x; 
#line 2732
} 
#endif
#line 2734 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2735
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2740
::exit(___);}
#if 0
#line 2735
{ 
#line 2736
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2737
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2739
return w.x; 
#line 2740
} 
#endif
#line 2742 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3D(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2743
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2748
::exit(___);}
#if 0
#line 2743
{ 
#line 2744
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2745
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2747
return make_float1(w.x); 
#line 2748
} 
#endif
#line 2750 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3D(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2751
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2756
::exit(___);}
#if 0
#line 2751
{ 
#line 2752
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2753
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2755
return make_float1(w.x); 
#line 2756
} 
#endif
#line 2758 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3D(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2759
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2764
::exit(___);}
#if 0
#line 2759
{ 
#line 2760
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2761
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2763
return make_float2(w.x, w.y); 
#line 2764
} 
#endif
#line 2766 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3D(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2767
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2772
::exit(___);}
#if 0
#line 2767
{ 
#line 2768
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2769
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2771
return make_float2(w.x, w.y); 
#line 2772
} 
#endif
#line 2774 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3D(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2775
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2780
::exit(___);}
#if 0
#line 2775
{ 
#line 2776
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2777
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2779
return make_float4(w.x, w.y, w.z, w.w); 
#line 2780
} 
#endif
#line 2782 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3D(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2783
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2788
::exit(___);}
#if 0
#line 2783
{ 
#line 2784
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2785
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2787
return make_float4(w.x, w.y, w.z, w.w); 
#line 2788
} 
#endif
#line 2796 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char texCubemap(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2797
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2805 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 2797 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 2801 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2804 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 2805
} 
#endif
#line 2807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char texCubemap(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2808
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2812
::exit(___);}
#if 0
#line 2808
{ 
#line 2809
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2811
return (signed char)(v.x); 
#line 2812
} 
#endif
#line 2814 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char texCubemap(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2815
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2819
::exit(___);}
#if 0
#line 2815
{ 
#line 2816
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2818
return (unsigned char)(v.x); 
#line 2819
} 
#endif
#line 2821 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 texCubemap(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2822
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2826
::exit(___);}
#if 0
#line 2822
{ 
#line 2823
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2825
return make_char1(v.x); 
#line 2826
} 
#endif
#line 2828 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 texCubemap(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2829
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2833
::exit(___);}
#if 0
#line 2829
{ 
#line 2830
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2832
return make_uchar1(v.x); 
#line 2833
} 
#endif
#line 2835 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 texCubemap(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2836
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2840
::exit(___);}
#if 0
#line 2836
{ 
#line 2837
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2839
return make_char2(v.x, v.y); 
#line 2840
} 
#endif
#line 2842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 texCubemap(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2847
::exit(___);}
#if 0
#line 2843
{ 
#line 2844
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2846
return make_uchar2(v.x, v.y); 
#line 2847
} 
#endif
#line 2849 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 texCubemap(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2854
::exit(___);}
#if 0
#line 2850
{ 
#line 2851
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2853
return make_char4(v.x, v.y, v.z, v.w); 
#line 2854
} 
#endif
#line 2856 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 texCubemap(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2861
::exit(___);}
#if 0
#line 2857
{ 
#line 2858
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2860
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 2861
} 
#endif
#line 2869 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short texCubemap(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2870
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2874
::exit(___);}
#if 0
#line 2870
{ 
#line 2871
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2873
return (short)(v.x); 
#line 2874
} 
#endif
#line 2876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short texCubemap(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2877
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2881
::exit(___);}
#if 0
#line 2877
{ 
#line 2878
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2880
return (unsigned short)(v.x); 
#line 2881
} 
#endif
#line 2883 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 texCubemap(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2884
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2888
::exit(___);}
#if 0
#line 2884
{ 
#line 2885
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2887
return make_short1(v.x); 
#line 2888
} 
#endif
#line 2890 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 texCubemap(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2891
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2895
::exit(___);}
#if 0
#line 2891
{ 
#line 2892
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2894
return make_ushort1(v.x); 
#line 2895
} 
#endif
#line 2897 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 texCubemap(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2902
::exit(___);}
#if 0
#line 2898
{ 
#line 2899
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2901
return make_short2(v.x, v.y); 
#line 2902
} 
#endif
#line 2904 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 texCubemap(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2909
::exit(___);}
#if 0
#line 2905
{ 
#line 2906
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2908
return make_ushort2(v.x, v.y); 
#line 2909
} 
#endif
#line 2911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 texCubemap(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2912
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2916
::exit(___);}
#if 0
#line 2912
{ 
#line 2913
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2915
return make_short4(v.x, v.y, v.z, v.w); 
#line 2916
} 
#endif
#line 2918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 texCubemap(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2919
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2923
::exit(___);}
#if 0
#line 2919
{ 
#line 2920
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2922
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 2923
} 
#endif
#line 2931 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int texCubemap(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2932
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2936
::exit(___);}
#if 0
#line 2932
{ 
#line 2933
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2935
return v.x; 
#line 2936
} 
#endif
#line 2938 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned texCubemap(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2939
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2943
::exit(___);}
#if 0
#line 2939
{ 
#line 2940
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2942
return v.x; 
#line 2943
} 
#endif
#line 2945 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 texCubemap(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2946
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2950
::exit(___);}
#if 0
#line 2946
{ 
#line 2947
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2949
return make_int1(v.x); 
#line 2950
} 
#endif
#line 2952 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 texCubemap(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2953
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2957
::exit(___);}
#if 0
#line 2953
{ 
#line 2954
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2956
return make_uint1(v.x); 
#line 2957
} 
#endif
#line 2959 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 texCubemap(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2960
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2964
::exit(___);}
#if 0
#line 2960
{ 
#line 2961
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2963
return make_int2(v.x, v.y); 
#line 2964
} 
#endif
#line 2966 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 texCubemap(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2967
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2971
::exit(___);}
#if 0
#line 2967
{ 
#line 2968
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2970
return make_uint2(v.x, v.y); 
#line 2971
} 
#endif
#line 2973 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 texCubemap(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2974
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2978
::exit(___);}
#if 0
#line 2974
{ 
#line 2975
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2977
return make_int4(v.x, v.y, v.z, v.w); 
#line 2978
} 
#endif
#line 2980 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 texCubemap(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2981
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2985
::exit(___);}
#if 0
#line 2981
{ 
#line 2982
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2984
return make_uint4(v.x, v.y, v.z, v.w); 
#line 2985
} 
#endif
#line 2995 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long texCubemap(texture< long, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2996
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3000
::exit(___);}
#if 0
#line 2996
{ 
#line 2997
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2999
return (long)(v.x); 
#line 3000
} 
#endif
#line 3002 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long texCubemap(texture< unsigned long, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3003
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3007
::exit(___);}
#if 0
#line 3003
{ 
#line 3004
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3006
return (unsigned long)(v.x); 
#line 3007
} 
#endif
#line 3009 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 texCubemap(texture< long1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3010
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3014
::exit(___);}
#if 0
#line 3010
{ 
#line 3011
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3013
return make_long1(v.x); 
#line 3014
} 
#endif
#line 3016 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 texCubemap(texture< ulong1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3017
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3021
::exit(___);}
#if 0
#line 3017
{ 
#line 3018
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3020
return make_ulong1(v.x); 
#line 3021
} 
#endif
#line 3023 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 texCubemap(texture< long2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3024
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3028
::exit(___);}
#if 0
#line 3024
{ 
#line 3025
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3027
return make_long2(v.x, v.y); 
#line 3028
} 
#endif
#line 3030 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 texCubemap(texture< ulong2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3031
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3035
::exit(___);}
#if 0
#line 3031
{ 
#line 3032
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3034
return make_ulong2(v.x, v.y); 
#line 3035
} 
#endif
#line 3037 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 texCubemap(texture< long4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3038
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3042
::exit(___);}
#if 0
#line 3038
{ 
#line 3039
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3041
return make_long4(v.x, v.y, v.z, v.w); 
#line 3042
} 
#endif
#line 3044 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 texCubemap(texture< ulong4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3045
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3049
::exit(___);}
#if 0
#line 3045
{ 
#line 3046
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3048
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 3049
} 
#endif
#line 3059 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3060
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3064
::exit(___);}
#if 0
#line 3060
{ 
#line 3061
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
#line 3063
return v.x; 
#line 3064
} 
#endif
#line 3066 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemap(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3067
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3071
::exit(___);}
#if 0
#line 3067
{ 
#line 3068
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
#line 3070
return make_float1(v.x); 
#line 3071
} 
#endif
#line 3073 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemap(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3074
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3078
::exit(___);}
#if 0
#line 3074
{ 
#line 3075
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
#line 3077
return make_float2(v.x, v.y); 
#line 3078
} 
#endif
#line 3080 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemap(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3081
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3085
::exit(___);}
#if 0
#line 3081
{ 
#line 3082
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
#line 3084
return make_float4(v.x, v.y, v.z, v.w); 
#line 3085
} 
#endif
#line 3093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3094
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 3094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 3098 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3102
return w.x; 
#line 3103
} 
#endif
#line 3105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3106
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3111
::exit(___);}
#if 0
#line 3106
{ 
#line 3107
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3108
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3110
return w.x; 
#line 3111
} 
#endif
#line 3113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3114
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3119
::exit(___);}
#if 0
#line 3114
{ 
#line 3115
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3116
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3118
return w.x; 
#line 3119
} 
#endif
#line 3121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemap(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3122
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3127
::exit(___);}
#if 0
#line 3122
{ 
#line 3123
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3124
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3126
return make_float1(w.x); 
#line 3127
} 
#endif
#line 3129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemap(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3130
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3135
::exit(___);}
#if 0
#line 3130
{ 
#line 3131
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3132
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3134
return make_float1(w.x); 
#line 3135
} 
#endif
#line 3137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemap(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3138
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3143
::exit(___);}
#if 0
#line 3138
{ 
#line 3139
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3140
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3142
return make_float2(w.x, w.y); 
#line 3143
} 
#endif
#line 3145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemap(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3146
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3151
::exit(___);}
#if 0
#line 3146
{ 
#line 3147
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3148
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3150
return make_float2(w.x, w.y); 
#line 3151
} 
#endif
#line 3153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemap(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3154
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3159
::exit(___);}
#if 0
#line 3154
{ 
#line 3155
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3156
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3158
return make_float4(w.x, w.y, w.z, w.w); 
#line 3159
} 
#endif
#line 3161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemap(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3162
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3167
::exit(___);}
#if 0
#line 3162
{ 
#line 3163
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3164
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3166
return make_float4(w.x, w.y, w.z, w.w); 
#line 3167
} 
#endif
#line 3175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3176
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3181
::exit(___);}
#if 0
#line 3176
{ 
#line 3177
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3178
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3180
return w.x; 
#line 3181
} 
#endif
#line 3183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3184
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3189
::exit(___);}
#if 0
#line 3184
{ 
#line 3185
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3186
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3188
return w.x; 
#line 3189
} 
#endif
#line 3191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemap(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3192
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3197
::exit(___);}
#if 0
#line 3192
{ 
#line 3193
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3194
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3196
return make_float1(w.x); 
#line 3197
} 
#endif
#line 3199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemap(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3200
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3205
::exit(___);}
#if 0
#line 3200
{ 
#line 3201
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3202
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3204
return make_float1(w.x); 
#line 3205
} 
#endif
#line 3207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemap(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3208
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3213
::exit(___);}
#if 0
#line 3208
{ 
#line 3209
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3210
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3212
return make_float2(w.x, w.y); 
#line 3213
} 
#endif
#line 3215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemap(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3216
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3221
::exit(___);}
#if 0
#line 3216
{ 
#line 3217
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3218
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3220
return make_float2(w.x, w.y); 
#line 3221
} 
#endif
#line 3223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemap(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3224
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3229
::exit(___);}
#if 0
#line 3224
{ 
#line 3225
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3226
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3228
return make_float4(w.x, w.y, w.z, w.w); 
#line 3229
} 
#endif
#line 3231 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemap(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3232
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3237
::exit(___);}
#if 0
#line 3232
{ 
#line 3233
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3234
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3236
return make_float4(w.x, w.y, w.z, w.w); 
#line 3237
} 
#endif
#line 3245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char texCubemapLayered(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3246
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 3246 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 3250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3253 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 3254
} 
#endif
#line 3256 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char texCubemapLayered(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3257
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3261
::exit(___);}
#if 0
#line 3257
{ 
#line 3258
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3260
return (signed char)(v.x); 
#line 3261
} 
#endif
#line 3263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char texCubemapLayered(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3264
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3268
::exit(___);}
#if 0
#line 3264
{ 
#line 3265
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3267
return (unsigned char)(v.x); 
#line 3268
} 
#endif
#line 3270 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 texCubemapLayered(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3271
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3275
::exit(___);}
#if 0
#line 3271
{ 
#line 3272
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3274
return make_char1(v.x); 
#line 3275
} 
#endif
#line 3277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 texCubemapLayered(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3278
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3282
::exit(___);}
#if 0
#line 3278
{ 
#line 3279
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3281
return make_uchar1(v.x); 
#line 3282
} 
#endif
#line 3284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 texCubemapLayered(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3285
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3289
::exit(___);}
#if 0
#line 3285
{ 
#line 3286
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3288
return make_char2(v.x, v.y); 
#line 3289
} 
#endif
#line 3291 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 texCubemapLayered(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3292
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3296
::exit(___);}
#if 0
#line 3292
{ 
#line 3293
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3295
return make_uchar2(v.x, v.y); 
#line 3296
} 
#endif
#line 3298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 texCubemapLayered(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3299
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3303
::exit(___);}
#if 0
#line 3299
{ 
#line 3300
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3302
return make_char4(v.x, v.y, v.z, v.w); 
#line 3303
} 
#endif
#line 3305 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 texCubemapLayered(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3306
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3310
::exit(___);}
#if 0
#line 3306
{ 
#line 3307
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3309
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 3310
} 
#endif
#line 3318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short texCubemapLayered(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3319
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3323
::exit(___);}
#if 0
#line 3319
{ 
#line 3320
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3322
return (short)(v.x); 
#line 3323
} 
#endif
#line 3325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short texCubemapLayered(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3326
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3330
::exit(___);}
#if 0
#line 3326
{ 
#line 3327
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3329
return (unsigned short)(v.x); 
#line 3330
} 
#endif
#line 3332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 texCubemapLayered(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3333
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3337
::exit(___);}
#if 0
#line 3333
{ 
#line 3334
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3336
return make_short1(v.x); 
#line 3337
} 
#endif
#line 3339 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 texCubemapLayered(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3340
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3344
::exit(___);}
#if 0
#line 3340
{ 
#line 3341
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3343
return make_ushort1(v.x); 
#line 3344
} 
#endif
#line 3346 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 texCubemapLayered(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3347
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3351
::exit(___);}
#if 0
#line 3347
{ 
#line 3348
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3350
return make_short2(v.x, v.y); 
#line 3351
} 
#endif
#line 3353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 texCubemapLayered(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3354
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3358
::exit(___);}
#if 0
#line 3354
{ 
#line 3355
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3357
return make_ushort2(v.x, v.y); 
#line 3358
} 
#endif
#line 3360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 texCubemapLayered(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3361
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3365
::exit(___);}
#if 0
#line 3361
{ 
#line 3362
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3364
return make_short4(v.x, v.y, v.z, v.w); 
#line 3365
} 
#endif
#line 3367 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 texCubemapLayered(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3368
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3372
::exit(___);}
#if 0
#line 3368
{ 
#line 3369
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3371
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 3372
} 
#endif
#line 3380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int texCubemapLayered(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3381
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3385
::exit(___);}
#if 0
#line 3381
{ 
#line 3382
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3384
return v.x; 
#line 3385
} 
#endif
#line 3387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned texCubemapLayered(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3388
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3392
::exit(___);}
#if 0
#line 3388
{ 
#line 3389
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3391
return v.x; 
#line 3392
} 
#endif
#line 3394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 texCubemapLayered(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3395
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3399
::exit(___);}
#if 0
#line 3395
{ 
#line 3396
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3398
return make_int1(v.x); 
#line 3399
} 
#endif
#line 3401 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 texCubemapLayered(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3402
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3406
::exit(___);}
#if 0
#line 3402
{ 
#line 3403
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3405
return make_uint1(v.x); 
#line 3406
} 
#endif
#line 3408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 texCubemapLayered(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3409
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3413
::exit(___);}
#if 0
#line 3409
{ 
#line 3410
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3412
return make_int2(v.x, v.y); 
#line 3413
} 
#endif
#line 3415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 texCubemapLayered(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3416
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3420
::exit(___);}
#if 0
#line 3416
{ 
#line 3417
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3419
return make_uint2(v.x, v.y); 
#line 3420
} 
#endif
#line 3422 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 texCubemapLayered(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3423
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3427
::exit(___);}
#if 0
#line 3423
{ 
#line 3424
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3426
return make_int4(v.x, v.y, v.z, v.w); 
#line 3427
} 
#endif
#line 3429 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 texCubemapLayered(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3430
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3434
::exit(___);}
#if 0
#line 3430
{ 
#line 3431
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3433
return make_uint4(v.x, v.y, v.z, v.w); 
#line 3434
} 
#endif
#line 3444 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long texCubemapLayered(texture< long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3445
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3449
::exit(___);}
#if 0
#line 3445
{ 
#line 3446
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3448
return (long)(v.x); 
#line 3449
} 
#endif
#line 3451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long texCubemapLayered(texture< unsigned long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3452
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3456
::exit(___);}
#if 0
#line 3452
{ 
#line 3453
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3455
return (unsigned long)(v.x); 
#line 3456
} 
#endif
#line 3458 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 texCubemapLayered(texture< long1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3459
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3463
::exit(___);}
#if 0
#line 3459
{ 
#line 3460
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3462
return make_long1(v.x); 
#line 3463
} 
#endif
#line 3465 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 texCubemapLayered(texture< ulong1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3466
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3470
::exit(___);}
#if 0
#line 3466
{ 
#line 3467
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3469
return make_ulong1(v.x); 
#line 3470
} 
#endif
#line 3472 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 texCubemapLayered(texture< long2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3473
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3477
::exit(___);}
#if 0
#line 3473
{ 
#line 3474
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3476
return make_long2(v.x, v.y); 
#line 3477
} 
#endif
#line 3479 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 texCubemapLayered(texture< ulong2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3480
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3484
::exit(___);}
#if 0
#line 3480
{ 
#line 3481
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3483
return make_ulong2(v.x, v.y); 
#line 3484
} 
#endif
#line 3486 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 texCubemapLayered(texture< long4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3487
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3491
::exit(___);}
#if 0
#line 3487
{ 
#line 3488
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3490
return make_long4(v.x, v.y, v.z, v.w); 
#line 3491
} 
#endif
#line 3493 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 texCubemapLayered(texture< ulong4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3494
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3498
::exit(___);}
#if 0
#line 3494
{ 
#line 3495
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3497
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 3498
} 
#endif
#line 3508 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3509
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3513
::exit(___);}
#if 0
#line 3509
{ 
#line 3510
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3512
return v.x; 
#line 3513
} 
#endif
#line 3515 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayered(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3516
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3520
::exit(___);}
#if 0
#line 3516
{ 
#line 3517
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3519
return make_float1(v.x); 
#line 3520
} 
#endif
#line 3522 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayered(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3523
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3527
::exit(___);}
#if 0
#line 3523
{ 
#line 3524
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3526
return make_float2(v.x, v.y); 
#line 3527
} 
#endif
#line 3529 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayered(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3530
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3534
::exit(___);}
#if 0
#line 3530
{ 
#line 3531
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3533
return make_float4(v.x, v.y, v.z, v.w); 
#line 3534
} 
#endif
#line 3542 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3543
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 3543 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 3547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3549 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3551
return w.x; 
#line 3552
} 
#endif
#line 3554 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3555
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3560
::exit(___);}
#if 0
#line 3555
{ 
#line 3556
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3557
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3559
return w.x; 
#line 3560
} 
#endif
#line 3562 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3563
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3568
::exit(___);}
#if 0
#line 3563
{ 
#line 3564
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3565
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3567
return w.x; 
#line 3568
} 
#endif
#line 3570 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayered(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3571
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3576
::exit(___);}
#if 0
#line 3571
{ 
#line 3572
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3573
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3575
return make_float1(w.x); 
#line 3576
} 
#endif
#line 3578 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayered(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3579
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3584
::exit(___);}
#if 0
#line 3579
{ 
#line 3580
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3581
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3583
return make_float1(w.x); 
#line 3584
} 
#endif
#line 3586 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayered(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3587
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3592
::exit(___);}
#if 0
#line 3587
{ 
#line 3588
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3589
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3591
return make_float2(w.x, w.y); 
#line 3592
} 
#endif
#line 3594 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayered(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3595
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3600
::exit(___);}
#if 0
#line 3595
{ 
#line 3596
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3597
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3599
return make_float2(w.x, w.y); 
#line 3600
} 
#endif
#line 3602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayered(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3603
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3608
::exit(___);}
#if 0
#line 3603
{ 
#line 3604
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3605
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3607
return make_float4(w.x, w.y, w.z, w.w); 
#line 3608
} 
#endif
#line 3610 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayered(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3611
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3616
::exit(___);}
#if 0
#line 3611
{ 
#line 3612
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3613
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3615
return make_float4(w.x, w.y, w.z, w.w); 
#line 3616
} 
#endif
#line 3624 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3625
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3630
::exit(___);}
#if 0
#line 3625
{ 
#line 3626
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3627
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3629
return w.x; 
#line 3630
} 
#endif
#line 3632 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3633
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3638
::exit(___);}
#if 0
#line 3633
{ 
#line 3634
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3635
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3637
return w.x; 
#line 3638
} 
#endif
#line 3640 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayered(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3641
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3646
::exit(___);}
#if 0
#line 3641
{ 
#line 3642
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3643
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3645
return make_float1(w.x); 
#line 3646
} 
#endif
#line 3648 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayered(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3649
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3654
::exit(___);}
#if 0
#line 3649
{ 
#line 3650
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3651
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3653
return make_float1(w.x); 
#line 3654
} 
#endif
#line 3656 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayered(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3657
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3662
::exit(___);}
#if 0
#line 3657
{ 
#line 3658
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3659
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3661
return make_float2(w.x, w.y); 
#line 3662
} 
#endif
#line 3664 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayered(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3665
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3670
::exit(___);}
#if 0
#line 3665
{ 
#line 3666
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3667
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3669
return make_float2(w.x, w.y); 
#line 3670
} 
#endif
#line 3672 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayered(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3678
::exit(___);}
#if 0
#line 3673
{ 
#line 3674
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3675
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3677
return make_float4(w.x, w.y, w.z, w.w); 
#line 3678
} 
#endif
#line 3680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayered(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3686
::exit(___);}
#if 0
#line 3681
{ 
#line 3682
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3683
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3685
return make_float4(w.x, w.y, w.z, w.w); 
#line 3686
} 
#endif
#line 3807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3808
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3810
::exit(___);}
#if 0
#line 3808
{ 
#line 3809
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
#line 3810
} 
#endif
#line 3812 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3813
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3815
::exit(___);}
#if 0
#line 3813
{ 
#line 3814
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
#line 3815
} 
#endif
#line 3817 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2Dgather(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3818
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3820
::exit(___);}
#if 0
#line 3818
{ 
#line 3819
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } ; 
#line 3820
} 
#endif
#line 3822 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3823
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3825
::exit(___);}
#if 0
#line 3823
{ 
#line 3824
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
#line 3825
} 
#endif
#line 3827 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2Dgather(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3828
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3830
::exit(___);}
#if 0
#line 3828
{ 
#line 3829
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } ; 
#line 3830
} 
#endif
#line 3832 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3833
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3835
::exit(___);}
#if 0
#line 3833
{ 
#line 3834
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  ; 
#line 3835
} 
#endif
#line 3837 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2Dgather(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3838
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3840
::exit(___);}
#if 0
#line 3838
{ 
#line 3839
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  ; 
#line 3840
} 
#endif
#line 3842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< char3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3845
::exit(___);}
#if 0
#line 3843
{ 
#line 3844
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  }  ; 
#line 3845
} 
#endif
#line 3847 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2Dgather(texture< uchar3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3848
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3850
::exit(___);}
#if 0
#line 3848
{ 
#line 3849
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  }  ; 
#line 3850
} 
#endif
#line 3852 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3853
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3855
::exit(___);}
#if 0
#line 3853
{ 
#line 3854
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  }  }  ; 
#line 3855
} 
#endif
#line 3857 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2Dgather(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3858
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3860
::exit(___);}
#if 0
#line 3858
{ 
#line 3859
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  }  }  ; 
#line 3860
} 
#endif
#line 3862 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2Dgather(texture< short, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3863
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3865
::exit(___);}
#if 0
#line 3863
{ 
#line 3864
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } ; 
#line 3865
} 
#endif
#line 3867 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2Dgather(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3868
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3870
::exit(___);}
#if 0
#line 3868
{ 
#line 3869
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } ; 
#line 3870
} 
#endif
#line 3872 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2Dgather(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3873
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3875
::exit(___);}
#if 0
#line 3873
{ 
#line 3874
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } ; 
#line 3875
} 
#endif
#line 3877 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2Dgather(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3878
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3880
::exit(___);}
#if 0
#line 3878
{ 
#line 3879
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } ; 
#line 3880
} 
#endif
#line 3882 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2Dgather(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3883
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3885
::exit(___);}
#if 0
#line 3883
{ 
#line 3884
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  ; 
#line 3885
} 
#endif
#line 3887 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2Dgather(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3888
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3890
::exit(___);}
#if 0
#line 3888
{ 
#line 3889
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  ; 
#line 3890
} 
#endif
#line 3892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2Dgather(texture< short3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3893
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3895
::exit(___);}
#if 0
#line 3893
{ 
#line 3894
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  }  ; 
#line 3895
} 
#endif
#line 3897 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2Dgather(texture< ushort3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3900
::exit(___);}
#if 0
#line 3898
{ 
#line 3899
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  }  ; 
#line 3900
} 
#endif
#line 3902 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2Dgather(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3903
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3905
::exit(___);}
#if 0
#line 3903
{ 
#line 3904
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  }  }  ; 
#line 3905
} 
#endif
#line 3907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2Dgather(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3908
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3910
::exit(___);}
#if 0
#line 3908
{ 
#line 3909
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  }  }  ; 
#line 3910
} 
#endif
#line 3912 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2Dgather(texture< int, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3913
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3915
::exit(___);}
#if 0
#line 3913
{ 
#line 3914
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3915
} 
#endif
#line 3917 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2Dgather(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3918
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3920
::exit(___);}
#if 0
#line 3918
{ 
#line 3919
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3920
} 
#endif
#line 3922 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2Dgather(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3923
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3925
::exit(___);}
#if 0
#line 3923
{ 
#line 3924
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3925
} 
#endif
#line 3927 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2Dgather(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3928
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3930
::exit(___);}
#if 0
#line 3928
{ 
#line 3929
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3930
} 
#endif
#line 3932 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2Dgather(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3933
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3935
::exit(___);}
#if 0
#line 3933
{ 
#line 3934
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
#line 3935
} 
#endif
#line 3937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2Dgather(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3940
::exit(___);}
#if 0
#line 3938
{ 
#line 3939
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
#line 3940
} 
#endif
#line 3942 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2Dgather(texture< int3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3943
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3945
::exit(___);}
#if 0
#line 3943
{ 
#line 3944
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
#line 3945
} 
#endif
#line 3947 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2Dgather(texture< uint3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3948
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3950
::exit(___);}
#if 0
#line 3948
{ 
#line 3949
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
#line 3950
} 
#endif
#line 3952 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2Dgather(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3953
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3955
::exit(___);}
#if 0
#line 3953
{ 
#line 3954
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
#line 3955
} 
#endif
#line 3957 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2Dgather(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3958
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3960
::exit(___);}
#if 0
#line 3958
{ 
#line 3959
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
#line 3960
} 
#endif
#line 3962 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< float, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3963
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3965
::exit(___);}
#if 0
#line 3963
{ 
#line 3964
{ float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3965
} 
#endif
#line 3967 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3968
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3970
::exit(___);}
#if 0
#line 3968
{ 
#line 3969
{ float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3970
} 
#endif
#line 3972 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3973
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3975
::exit(___);}
#if 0
#line 3973
{ 
#line 3974
if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
#line 3975
} 
#endif
#line 3977 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< float3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3978
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3980
::exit(___);}
#if 0
#line 3978
{ 
#line 3979
if (comp == 2) { float4 v = __ftex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
#line 3980
} 
#endif
#line 3982 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3983
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3985
::exit(___);}
#if 0
#line 3983
{ 
#line 3984
if (comp == 3) { float4 v = __ftex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { float4 v = __ftex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
#line 3985
} 
#endif
#line 3994 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 3995
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3997
::exit(___);}
#if 0
#line 3995
{ 
#line 3996
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 3997
} 
#endif
#line 3999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4002
::exit(___);}
#if 0
#line 4000
{ 
#line 4001
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4002
} 
#endif
#line 4004 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4005
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4007
::exit(___);}
#if 0
#line 4005
{ 
#line 4006
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4007
} 
#endif
#line 4009 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4010
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4012
::exit(___);}
#if 0
#line 4010
{ 
#line 4011
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4012
} 
#endif
#line 4014 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4015
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4017
::exit(___);}
#if 0
#line 4015
{ 
#line 4016
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4017
} 
#endif
#line 4019 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4020
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4022
::exit(___);}
#if 0
#line 4020
{ 
#line 4021
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
#line 4022
} 
#endif
#line 4024 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4025
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4027
::exit(___);}
#if 0
#line 4025
{ 
#line 4026
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
#line 4027
} 
#endif
#line 4029 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< char3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4030
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4032
::exit(___);}
#if 0
#line 4030
{ 
#line 4031
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
#line 4032
} 
#endif
#line 4034 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< uchar3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4035
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4037
::exit(___);}
#if 0
#line 4035
{ 
#line 4036
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
#line 4037
} 
#endif
#line 4039 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4040
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4042
::exit(___);}
#if 0
#line 4040
{ 
#line 4041
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
#line 4042
} 
#endif
#line 4044 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4045
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4047
::exit(___);}
#if 0
#line 4045
{ 
#line 4046
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
#line 4047
} 
#endif
#line 4049 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4050
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4052
::exit(___);}
#if 0
#line 4050
{ 
#line 4051
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4052
} 
#endif
#line 4054 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4055
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4057
::exit(___);}
#if 0
#line 4055
{ 
#line 4056
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4057
} 
#endif
#line 4059 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4060
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4062
::exit(___);}
#if 0
#line 4060
{ 
#line 4061
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4062
} 
#endif
#line 4064 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4065
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4067
::exit(___);}
#if 0
#line 4065
{ 
#line 4066
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4067
} 
#endif
#line 4069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4070
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4072
::exit(___);}
#if 0
#line 4070
{ 
#line 4071
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
#line 4072
} 
#endif
#line 4074 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4075
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4077
::exit(___);}
#if 0
#line 4075
{ 
#line 4076
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
#line 4077
} 
#endif
#line 4079 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< short3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4080
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4082
::exit(___);}
#if 0
#line 4080
{ 
#line 4081
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
#line 4082
} 
#endif
#line 4084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< ushort3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4085
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4087
::exit(___);}
#if 0
#line 4085
{ 
#line 4086
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
#line 4087
} 
#endif
#line 4089 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4090
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4092
::exit(___);}
#if 0
#line 4090
{ 
#line 4091
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
#line 4092
} 
#endif
#line 4094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4097
::exit(___);}
#if 0
#line 4095
{ 
#line 4096
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
#line 4097
} 
#endif
#line 4124 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex1DLod(texture< char, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4125
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 4125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 4129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 4133
} 
#endif
#line 4135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1DLod(texture< signed char, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4136
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4140
::exit(___);}
#if 0
#line 4136
{ 
#line 4137
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4139
return (signed char)(v.x); 
#line 4140
} 
#endif
#line 4142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1DLod(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4143
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4147
::exit(___);}
#if 0
#line 4143
{ 
#line 4144
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4146
return (unsigned char)(v.x); 
#line 4147
} 
#endif
#line 4149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1DLod(texture< char1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4150
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4154
::exit(___);}
#if 0
#line 4150
{ 
#line 4151
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4153
return make_char1(v.x); 
#line 4154
} 
#endif
#line 4156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1DLod(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4157
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4161
::exit(___);}
#if 0
#line 4157
{ 
#line 4158
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4160
return make_uchar1(v.x); 
#line 4161
} 
#endif
#line 4163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1DLod(texture< char2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4164
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4168
::exit(___);}
#if 0
#line 4164
{ 
#line 4165
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4167
return make_char2(v.x, v.y); 
#line 4168
} 
#endif
#line 4170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1DLod(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4171
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4175
::exit(___);}
#if 0
#line 4171
{ 
#line 4172
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4174
return make_uchar2(v.x, v.y); 
#line 4175
} 
#endif
#line 4177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1DLod(texture< char4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4178
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4182
::exit(___);}
#if 0
#line 4178
{ 
#line 4179
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4181
return make_char4(v.x, v.y, v.z, v.w); 
#line 4182
} 
#endif
#line 4184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1DLod(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4185
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4189
::exit(___);}
#if 0
#line 4185
{ 
#line 4186
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4188
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 4189
} 
#endif
#line 4197 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex1DLod(texture< short, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4198
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4202
::exit(___);}
#if 0
#line 4198
{ 
#line 4199
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4201
return (short)(v.x); 
#line 4202
} 
#endif
#line 4204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1DLod(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4205
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4209
::exit(___);}
#if 0
#line 4205
{ 
#line 4206
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4208
return (unsigned short)(v.x); 
#line 4209
} 
#endif
#line 4211 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1DLod(texture< short1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4212
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4216
::exit(___);}
#if 0
#line 4212
{ 
#line 4213
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4215
return make_short1(v.x); 
#line 4216
} 
#endif
#line 4218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1DLod(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4219
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4223
::exit(___);}
#if 0
#line 4219
{ 
#line 4220
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4222
return make_ushort1(v.x); 
#line 4223
} 
#endif
#line 4225 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1DLod(texture< short2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4226
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4230
::exit(___);}
#if 0
#line 4226
{ 
#line 4227
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4229
return make_short2(v.x, v.y); 
#line 4230
} 
#endif
#line 4232 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1DLod(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4233
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4237
::exit(___);}
#if 0
#line 4233
{ 
#line 4234
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4236
return make_ushort2(v.x, v.y); 
#line 4237
} 
#endif
#line 4239 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1DLod(texture< short4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4240
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4244
::exit(___);}
#if 0
#line 4240
{ 
#line 4241
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4243
return make_short4(v.x, v.y, v.z, v.w); 
#line 4244
} 
#endif
#line 4246 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1DLod(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4247
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4251
::exit(___);}
#if 0
#line 4247
{ 
#line 4248
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4250
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 4251
} 
#endif
#line 4259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex1DLod(texture< int, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4260
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4264
::exit(___);}
#if 0
#line 4260
{ 
#line 4261
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4263
return v.x; 
#line 4264
} 
#endif
#line 4266 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1DLod(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4267
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4271
::exit(___);}
#if 0
#line 4267
{ 
#line 4268
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4270
return v.x; 
#line 4271
} 
#endif
#line 4273 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1DLod(texture< int1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4274
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4278
::exit(___);}
#if 0
#line 4274
{ 
#line 4275
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4277
return make_int1(v.x); 
#line 4278
} 
#endif
#line 4280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1DLod(texture< uint1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4281
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4285
::exit(___);}
#if 0
#line 4281
{ 
#line 4282
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4284
return make_uint1(v.x); 
#line 4285
} 
#endif
#line 4287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1DLod(texture< int2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4288
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4292
::exit(___);}
#if 0
#line 4288
{ 
#line 4289
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4291
return make_int2(v.x, v.y); 
#line 4292
} 
#endif
#line 4294 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1DLod(texture< uint2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4295
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4299
::exit(___);}
#if 0
#line 4295
{ 
#line 4296
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4298
return make_uint2(v.x, v.y); 
#line 4299
} 
#endif
#line 4301 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1DLod(texture< int4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4302
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4306
::exit(___);}
#if 0
#line 4302
{ 
#line 4303
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4305
return make_int4(v.x, v.y, v.z, v.w); 
#line 4306
} 
#endif
#line 4308 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1DLod(texture< uint4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4309
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4313
::exit(___);}
#if 0
#line 4309
{ 
#line 4310
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4312
return make_uint4(v.x, v.y, v.z, v.w); 
#line 4313
} 
#endif
#line 4329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex1DLod(texture< long, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4330
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4334
::exit(___);}
#if 0
#line 4330
{ 
#line 4331
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4333
return (long)(v.x); 
#line 4334
} 
#endif
#line 4336 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1DLod(texture< unsigned long, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4337
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4341
::exit(___);}
#if 0
#line 4337
{ 
#line 4338
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4340
return (unsigned long)(v.x); 
#line 4341
} 
#endif
#line 4343 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1DLod(texture< long1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4344
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4348
::exit(___);}
#if 0
#line 4344
{ 
#line 4345
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4347
return make_long1(v.x); 
#line 4348
} 
#endif
#line 4350 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1DLod(texture< ulong1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4351
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4355
::exit(___);}
#if 0
#line 4351
{ 
#line 4352
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4354
return make_ulong1(v.x); 
#line 4355
} 
#endif
#line 4357 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1DLod(texture< long2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4358
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4362
::exit(___);}
#if 0
#line 4358
{ 
#line 4359
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4361
return make_long2(v.x, v.y); 
#line 4362
} 
#endif
#line 4364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1DLod(texture< ulong2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4365
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4369
::exit(___);}
#if 0
#line 4365
{ 
#line 4366
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4368
return make_ulong2(v.x, v.y); 
#line 4369
} 
#endif
#line 4371 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1DLod(texture< long4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4372
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4376
::exit(___);}
#if 0
#line 4372
{ 
#line 4373
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4375
return make_long4(v.x, v.y, v.z, v.w); 
#line 4376
} 
#endif
#line 4378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1DLod(texture< ulong4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4379
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4383
::exit(___);}
#if 0
#line 4379
{ 
#line 4380
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4382
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 4383
} 
#endif
#line 4393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< float, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4394
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4398
::exit(___);}
#if 0
#line 4394
{ 
#line 4395
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4397
return v.x; 
#line 4398
} 
#endif
#line 4400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLod(texture< float1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4401
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4405
::exit(___);}
#if 0
#line 4401
{ 
#line 4402
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4404
return make_float1(v.x); 
#line 4405
} 
#endif
#line 4407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLod(texture< float2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4408
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4412
::exit(___);}
#if 0
#line 4408
{ 
#line 4409
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4411
return make_float2(v.x, v.y); 
#line 4412
} 
#endif
#line 4414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLod(texture< float4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4415
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4419
::exit(___);}
#if 0
#line 4415
{ 
#line 4416
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4418
return make_float4(v.x, v.y, v.z, v.w); 
#line 4419
} 
#endif
#line 4427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4428
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4437 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 4428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 4432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4434 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4436
return w.x; 
#line 4437
} 
#endif
#line 4439 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4440
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4445
::exit(___);}
#if 0
#line 4440
{ 
#line 4441
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4442
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4444
return w.x; 
#line 4445
} 
#endif
#line 4447 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4448
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4453
::exit(___);}
#if 0
#line 4448
{ 
#line 4449
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4450
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4452
return w.x; 
#line 4453
} 
#endif
#line 4455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLod(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4456
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4461
::exit(___);}
#if 0
#line 4456
{ 
#line 4457
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4458
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4460
return make_float1(w.x); 
#line 4461
} 
#endif
#line 4463 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLod(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4464
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4469
::exit(___);}
#if 0
#line 4464
{ 
#line 4465
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4466
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4468
return make_float1(w.x); 
#line 4469
} 
#endif
#line 4471 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLod(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4472
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4477
::exit(___);}
#if 0
#line 4472
{ 
#line 4473
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4474
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4476
return make_float2(w.x, w.y); 
#line 4477
} 
#endif
#line 4479 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLod(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4480
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4485
::exit(___);}
#if 0
#line 4480
{ 
#line 4481
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4482
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4484
return make_float2(w.x, w.y); 
#line 4485
} 
#endif
#line 4487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLod(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4488
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4493
::exit(___);}
#if 0
#line 4488
{ 
#line 4489
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4490
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4492
return make_float4(w.x, w.y, w.z, w.w); 
#line 4493
} 
#endif
#line 4495 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLod(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4496
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4501
::exit(___);}
#if 0
#line 4496
{ 
#line 4497
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4498
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4500
return make_float4(w.x, w.y, w.z, w.w); 
#line 4501
} 
#endif
#line 4509 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4510
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4515
::exit(___);}
#if 0
#line 4510
{ 
#line 4511
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4512
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4514
return w.x; 
#line 4515
} 
#endif
#line 4517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4518
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4523
::exit(___);}
#if 0
#line 4518
{ 
#line 4519
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4520
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4522
return w.x; 
#line 4523
} 
#endif
#line 4525 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLod(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4526
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4531
::exit(___);}
#if 0
#line 4526
{ 
#line 4527
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4528
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4530
return make_float1(w.x); 
#line 4531
} 
#endif
#line 4533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLod(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4534
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4539
::exit(___);}
#if 0
#line 4534
{ 
#line 4535
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4536
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4538
return make_float1(w.x); 
#line 4539
} 
#endif
#line 4541 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLod(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4542
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4547
::exit(___);}
#if 0
#line 4542
{ 
#line 4543
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4544
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4546
return make_float2(w.x, w.y); 
#line 4547
} 
#endif
#line 4549 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLod(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4550
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4555
::exit(___);}
#if 0
#line 4550
{ 
#line 4551
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4552
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4554
return make_float2(w.x, w.y); 
#line 4555
} 
#endif
#line 4557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLod(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4558
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4563
::exit(___);}
#if 0
#line 4558
{ 
#line 4559
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4560
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4562
return make_float4(w.x, w.y, w.z, w.w); 
#line 4563
} 
#endif
#line 4565 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLod(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4566
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4571
::exit(___);}
#if 0
#line 4566
{ 
#line 4567
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4568
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4570
return make_float4(w.x, w.y, w.z, w.w); 
#line 4571
} 
#endif
#line 4579 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex2DLod(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4580
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 4580 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 4584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4587 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 4588
} 
#endif
#line 4590 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex2DLod(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4591
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4595
::exit(___);}
#if 0
#line 4591
{ 
#line 4592
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4594
return (signed char)(v.x); 
#line 4595
} 
#endif
#line 4597 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex2DLod(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4598
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4602
::exit(___);}
#if 0
#line 4598
{ 
#line 4599
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4601
return (unsigned char)(v.x); 
#line 4602
} 
#endif
#line 4604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex2DLod(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4605
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4609
::exit(___);}
#if 0
#line 4605
{ 
#line 4606
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4608
return make_char1(v.x); 
#line 4609
} 
#endif
#line 4611 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex2DLod(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4612
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4616
::exit(___);}
#if 0
#line 4612
{ 
#line 4613
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4615
return make_uchar1(v.x); 
#line 4616
} 
#endif
#line 4618 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex2DLod(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4619
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4623
::exit(___);}
#if 0
#line 4619
{ 
#line 4620
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4622
return make_char2(v.x, v.y); 
#line 4623
} 
#endif
#line 4625 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex2DLod(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4626
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4630
::exit(___);}
#if 0
#line 4626
{ 
#line 4627
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4629
return make_uchar2(v.x, v.y); 
#line 4630
} 
#endif
#line 4632 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2DLod(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4633
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4637
::exit(___);}
#if 0
#line 4633
{ 
#line 4634
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4636
return make_char4(v.x, v.y, v.z, v.w); 
#line 4637
} 
#endif
#line 4639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2DLod(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4640
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4644
::exit(___);}
#if 0
#line 4640
{ 
#line 4641
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4643
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 4644
} 
#endif
#line 4652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex2DLod(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4653
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4657
::exit(___);}
#if 0
#line 4653
{ 
#line 4654
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4656
return (short)(v.x); 
#line 4657
} 
#endif
#line 4659 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex2DLod(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4660
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4664
::exit(___);}
#if 0
#line 4660
{ 
#line 4661
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4663
return (unsigned short)(v.x); 
#line 4664
} 
#endif
#line 4666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex2DLod(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4667
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4671
::exit(___);}
#if 0
#line 4667
{ 
#line 4668
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4670
return make_short1(v.x); 
#line 4671
} 
#endif
#line 4673 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex2DLod(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4674
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4678
::exit(___);}
#if 0
#line 4674
{ 
#line 4675
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4677
return make_ushort1(v.x); 
#line 4678
} 
#endif
#line 4680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex2DLod(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4685
::exit(___);}
#if 0
#line 4681
{ 
#line 4682
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4684
return make_short2(v.x, v.y); 
#line 4685
} 
#endif
#line 4687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex2DLod(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4688
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4692
::exit(___);}
#if 0
#line 4688
{ 
#line 4689
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4691
return make_ushort2(v.x, v.y); 
#line 4692
} 
#endif
#line 4694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2DLod(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4695
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4699
::exit(___);}
#if 0
#line 4695
{ 
#line 4696
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4698
return make_short4(v.x, v.y, v.z, v.w); 
#line 4699
} 
#endif
#line 4701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2DLod(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4702
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4706
::exit(___);}
#if 0
#line 4702
{ 
#line 4703
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4705
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 4706
} 
#endif
#line 4714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex2DLod(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4715
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4719
::exit(___);}
#if 0
#line 4715
{ 
#line 4716
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4718
return v.x; 
#line 4719
} 
#endif
#line 4721 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex2DLod(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4722
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4726
::exit(___);}
#if 0
#line 4722
{ 
#line 4723
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4725
return v.x; 
#line 4726
} 
#endif
#line 4728 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex2DLod(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4729
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4733
::exit(___);}
#if 0
#line 4729
{ 
#line 4730
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4732
return make_int1(v.x); 
#line 4733
} 
#endif
#line 4735 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex2DLod(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4736
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4740
::exit(___);}
#if 0
#line 4736
{ 
#line 4737
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4739
return make_uint1(v.x); 
#line 4740
} 
#endif
#line 4742 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex2DLod(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4743
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4747
::exit(___);}
#if 0
#line 4743
{ 
#line 4744
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4746
return make_int2(v.x, v.y); 
#line 4747
} 
#endif
#line 4749 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex2DLod(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4750
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4754
::exit(___);}
#if 0
#line 4750
{ 
#line 4751
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4753
return make_uint2(v.x, v.y); 
#line 4754
} 
#endif
#line 4756 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2DLod(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4757
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4761
::exit(___);}
#if 0
#line 4757
{ 
#line 4758
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4760
return make_int4(v.x, v.y, v.z, v.w); 
#line 4761
} 
#endif
#line 4763 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2DLod(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4764
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4768
::exit(___);}
#if 0
#line 4764
{ 
#line 4765
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4767
return make_uint4(v.x, v.y, v.z, v.w); 
#line 4768
} 
#endif
#line 4778 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex2DLod(texture< long, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4779
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4783
::exit(___);}
#if 0
#line 4779
{ 
#line 4780
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4782
return (long)(v.x); 
#line 4783
} 
#endif
#line 4785 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex2DLod(texture< unsigned long, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4786
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4790
::exit(___);}
#if 0
#line 4786
{ 
#line 4787
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4789
return (unsigned long)(v.x); 
#line 4790
} 
#endif
#line 4792 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex2DLod(texture< long1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4793
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4797
::exit(___);}
#if 0
#line 4793
{ 
#line 4794
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4796
return make_long1(v.x); 
#line 4797
} 
#endif
#line 4799 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex2DLod(texture< ulong1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4800
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4804
::exit(___);}
#if 0
#line 4800
{ 
#line 4801
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4803
return make_ulong1(v.x); 
#line 4804
} 
#endif
#line 4806 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex2DLod(texture< long2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4807
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4811
::exit(___);}
#if 0
#line 4807
{ 
#line 4808
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4810
return make_long2(v.x, v.y); 
#line 4811
} 
#endif
#line 4813 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex2DLod(texture< ulong2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4814
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4818
::exit(___);}
#if 0
#line 4814
{ 
#line 4815
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4817
return make_ulong2(v.x, v.y); 
#line 4818
} 
#endif
#line 4820 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex2DLod(texture< long4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4821
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4825
::exit(___);}
#if 0
#line 4821
{ 
#line 4822
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4824
return make_long4(v.x, v.y, v.z, v.w); 
#line 4825
} 
#endif
#line 4827 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex2DLod(texture< ulong4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4828
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4832
::exit(___);}
#if 0
#line 4828
{ 
#line 4829
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4831
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 4832
} 
#endif
#line 4842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4847
::exit(___);}
#if 0
#line 4843
{ 
#line 4844
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4846
return v.x; 
#line 4847
} 
#endif
#line 4849 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLod(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4854
::exit(___);}
#if 0
#line 4850
{ 
#line 4851
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4853
return make_float1(v.x); 
#line 4854
} 
#endif
#line 4856 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLod(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4861
::exit(___);}
#if 0
#line 4857
{ 
#line 4858
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4860
return make_float2(v.x, v.y); 
#line 4861
} 
#endif
#line 4863 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLod(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4864
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4868
::exit(___);}
#if 0
#line 4864
{ 
#line 4865
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4867
return make_float4(v.x, v.y, v.z, v.w); 
#line 4868
} 
#endif
#line 4876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4877
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4886 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 4877 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 4881 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4883 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4885
return w.x; 
#line 4886
} 
#endif
#line 4888 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4889
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4894
::exit(___);}
#if 0
#line 4889
{ 
#line 4890
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4891
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4893
return w.x; 
#line 4894
} 
#endif
#line 4896 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4897
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4902
::exit(___);}
#if 0
#line 4897
{ 
#line 4898
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4899
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4901
return w.x; 
#line 4902
} 
#endif
#line 4904 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLod(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4910
::exit(___);}
#if 0
#line 4905
{ 
#line 4906
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4907
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4909
return make_float1(w.x); 
#line 4910
} 
#endif
#line 4912 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLod(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4913
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4918
::exit(___);}
#if 0
#line 4913
{ 
#line 4914
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4915
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4917
return make_float1(w.x); 
#line 4918
} 
#endif
#line 4920 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLod(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4921
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4926
::exit(___);}
#if 0
#line 4921
{ 
#line 4922
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4923
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4925
return make_float2(w.x, w.y); 
#line 4926
} 
#endif
#line 4928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLod(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4929
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4934
::exit(___);}
#if 0
#line 4929
{ 
#line 4930
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4931
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4933
return make_float2(w.x, w.y); 
#line 4934
} 
#endif
#line 4936 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLod(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4937
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4942
::exit(___);}
#if 0
#line 4937
{ 
#line 4938
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4939
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4941
return make_float4(w.x, w.y, w.z, w.w); 
#line 4942
} 
#endif
#line 4944 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLod(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4945
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4950
::exit(___);}
#if 0
#line 4945
{ 
#line 4946
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4947
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4949
return make_float4(w.x, w.y, w.z, w.w); 
#line 4950
} 
#endif
#line 4958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4959
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4964
::exit(___);}
#if 0
#line 4959
{ 
#line 4960
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4961
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4963
return w.x; 
#line 4964
} 
#endif
#line 4966 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4967
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4972
::exit(___);}
#if 0
#line 4967
{ 
#line 4968
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4969
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4971
return w.x; 
#line 4972
} 
#endif
#line 4974 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLod(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4975
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4980
::exit(___);}
#if 0
#line 4975
{ 
#line 4976
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4977
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4979
return make_float1(w.x); 
#line 4980
} 
#endif
#line 4982 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLod(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4983
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4988
::exit(___);}
#if 0
#line 4983
{ 
#line 4984
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4985
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4987
return make_float1(w.x); 
#line 4988
} 
#endif
#line 4990 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLod(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4991
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4996
::exit(___);}
#if 0
#line 4991
{ 
#line 4992
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4993
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4995
return make_float2(w.x, w.y); 
#line 4996
} 
#endif
#line 4998 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLod(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4999
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 5004
::exit(___);}
#if 0
#line 4999
{ 
#line 5000
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 5001
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5003
return make_float2(w.x, w.y); 
#line 5004
} 
#endif
#line 5006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLod(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 5007
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 5012
::exit(___);}
#if 0
#line 5007
{ 
#line 5008
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 5009
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5011
return make_float4(w.x, w.y, w.z, w.w); 
#line 5012
} 
#endif
#line 5014 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLod(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 5015
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 5020
::exit(___);}
#if 0
#line 5015
{ 
#line 5016
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 5017
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5019
return make_float4(w.x, w.y, w.z, w.w); 
#line 5020
} 
#endif
#line 5028 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex1DLayeredLod(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5029
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5037 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 5029 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 5033 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5036 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 5037
} 
#endif
#line 5039 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1DLayeredLod(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5040
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5044
::exit(___);}
#if 0
#line 5040
{ 
#line 5041
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5043
return (signed char)(v.x); 
#line 5044
} 
#endif
#line 5046 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5047
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5051
::exit(___);}
#if 0
#line 5047
{ 
#line 5048
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5050
return (unsigned char)(v.x); 
#line 5051
} 
#endif
#line 5053 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1DLayeredLod(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5054
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5058
::exit(___);}
#if 0
#line 5054
{ 
#line 5055
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5057
return make_char1(v.x); 
#line 5058
} 
#endif
#line 5060 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5061
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5065
::exit(___);}
#if 0
#line 5061
{ 
#line 5062
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5064
return make_uchar1(v.x); 
#line 5065
} 
#endif
#line 5067 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1DLayeredLod(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5068
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5072
::exit(___);}
#if 0
#line 5068
{ 
#line 5069
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5071
return make_char2(v.x, v.y); 
#line 5072
} 
#endif
#line 5074 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5075
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5079
::exit(___);}
#if 0
#line 5075
{ 
#line 5076
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5078
return make_uchar2(v.x, v.y); 
#line 5079
} 
#endif
#line 5081 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1DLayeredLod(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5082
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5086
::exit(___);}
#if 0
#line 5082
{ 
#line 5083
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5085
return make_char4(v.x, v.y, v.z, v.w); 
#line 5086
} 
#endif
#line 5088 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5089
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5093
::exit(___);}
#if 0
#line 5089
{ 
#line 5090
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5092
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 5093
} 
#endif
#line 5101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex1DLayeredLod(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5102
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5106
::exit(___);}
#if 0
#line 5102
{ 
#line 5103
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5105
return (short)(v.x); 
#line 5106
} 
#endif
#line 5108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5109
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5113
::exit(___);}
#if 0
#line 5109
{ 
#line 5110
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5112
return (unsigned short)(v.x); 
#line 5113
} 
#endif
#line 5115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1DLayeredLod(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5116
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5120
::exit(___);}
#if 0
#line 5116
{ 
#line 5117
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5119
return make_short1(v.x); 
#line 5120
} 
#endif
#line 5122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5123
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5127
::exit(___);}
#if 0
#line 5123
{ 
#line 5124
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5126
return make_ushort1(v.x); 
#line 5127
} 
#endif
#line 5129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1DLayeredLod(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5130
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5134
::exit(___);}
#if 0
#line 5130
{ 
#line 5131
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5133
return make_short2(v.x, v.y); 
#line 5134
} 
#endif
#line 5136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5137
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5141
::exit(___);}
#if 0
#line 5137
{ 
#line 5138
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5140
return make_ushort2(v.x, v.y); 
#line 5141
} 
#endif
#line 5143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1DLayeredLod(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5144
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5148
::exit(___);}
#if 0
#line 5144
{ 
#line 5145
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5147
return make_short4(v.x, v.y, v.z, v.w); 
#line 5148
} 
#endif
#line 5150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5151
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5155
::exit(___);}
#if 0
#line 5151
{ 
#line 5152
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5154
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 5155
} 
#endif
#line 5163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex1DLayeredLod(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5164
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5168
::exit(___);}
#if 0
#line 5164
{ 
#line 5165
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5167
return v.x; 
#line 5168
} 
#endif
#line 5170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1DLayeredLod(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5171
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5175
::exit(___);}
#if 0
#line 5171
{ 
#line 5172
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5174
return v.x; 
#line 5175
} 
#endif
#line 5177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1DLayeredLod(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5178
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5182
::exit(___);}
#if 0
#line 5178
{ 
#line 5179
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5181
return make_int1(v.x); 
#line 5182
} 
#endif
#line 5184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1DLayeredLod(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5185
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5189
::exit(___);}
#if 0
#line 5185
{ 
#line 5186
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5188
return make_uint1(v.x); 
#line 5189
} 
#endif
#line 5191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1DLayeredLod(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5192
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5196
::exit(___);}
#if 0
#line 5192
{ 
#line 5193
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5195
return make_int2(v.x, v.y); 
#line 5196
} 
#endif
#line 5198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1DLayeredLod(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5199
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5203
::exit(___);}
#if 0
#line 5199
{ 
#line 5200
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5202
return make_uint2(v.x, v.y); 
#line 5203
} 
#endif
#line 5205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1DLayeredLod(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5206
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5210
::exit(___);}
#if 0
#line 5206
{ 
#line 5207
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5209
return make_int4(v.x, v.y, v.z, v.w); 
#line 5210
} 
#endif
#line 5212 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1DLayeredLod(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5213
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5217
::exit(___);}
#if 0
#line 5213
{ 
#line 5214
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5216
return make_uint4(v.x, v.y, v.z, v.w); 
#line 5217
} 
#endif
#line 5227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex1DLayeredLod(texture< long, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5228
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5232
::exit(___);}
#if 0
#line 5228
{ 
#line 5229
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5231
return (long)(v.x); 
#line 5232
} 
#endif
#line 5234 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1DLayeredLod(texture< unsigned long, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5235
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5239
::exit(___);}
#if 0
#line 5235
{ 
#line 5236
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5238
return (unsigned long)(v.x); 
#line 5239
} 
#endif
#line 5241 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1DLayeredLod(texture< long1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5242
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5246
::exit(___);}
#if 0
#line 5242
{ 
#line 5243
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5245
return make_long1(v.x); 
#line 5246
} 
#endif
#line 5248 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1DLayeredLod(texture< ulong1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5249
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5253
::exit(___);}
#if 0
#line 5249
{ 
#line 5250
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5252
return make_ulong1(v.x); 
#line 5253
} 
#endif
#line 5255 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1DLayeredLod(texture< long2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5256
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5260
::exit(___);}
#if 0
#line 5256
{ 
#line 5257
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5259
return make_long2(v.x, v.y); 
#line 5260
} 
#endif
#line 5262 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1DLayeredLod(texture< ulong2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5263
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5267
::exit(___);}
#if 0
#line 5263
{ 
#line 5264
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5266
return make_ulong2(v.x, v.y); 
#line 5267
} 
#endif
#line 5269 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1DLayeredLod(texture< long4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5270
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5274
::exit(___);}
#if 0
#line 5270
{ 
#line 5271
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5273
return make_long4(v.x, v.y, v.z, v.w); 
#line 5274
} 
#endif
#line 5276 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1DLayeredLod(texture< ulong4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5277
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5281
::exit(___);}
#if 0
#line 5277
{ 
#line 5278
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5280
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 5281
} 
#endif
#line 5291 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5292
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5296
::exit(___);}
#if 0
#line 5292
{ 
#line 5293
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5295
return v.x; 
#line 5296
} 
#endif
#line 5298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredLod(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5299
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5303
::exit(___);}
#if 0
#line 5299
{ 
#line 5300
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5302
return make_float1(v.x); 
#line 5303
} 
#endif
#line 5305 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredLod(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5306
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5310
::exit(___);}
#if 0
#line 5306
{ 
#line 5307
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5309
return make_float2(v.x, v.y); 
#line 5310
} 
#endif
#line 5312 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredLod(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5313
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5317
::exit(___);}
#if 0
#line 5313
{ 
#line 5314
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5316
return make_float4(v.x, v.y, v.z, v.w); 
#line 5317
} 
#endif
#line 5325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5326
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5335 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 5326 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 5330 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5334
return w.x; 
#line 5335
} 
#endif
#line 5337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5338
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5343
::exit(___);}
#if 0
#line 5338
{ 
#line 5339
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5340
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5342
return w.x; 
#line 5343
} 
#endif
#line 5345 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5346
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5351
::exit(___);}
#if 0
#line 5346
{ 
#line 5347
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5348
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5350
return w.x; 
#line 5351
} 
#endif
#line 5353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredLod(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5354
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5359
::exit(___);}
#if 0
#line 5354
{ 
#line 5355
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5356
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5358
return make_float1(w.x); 
#line 5359
} 
#endif
#line 5361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5362
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5367
::exit(___);}
#if 0
#line 5362
{ 
#line 5363
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5364
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5366
return make_float1(w.x); 
#line 5367
} 
#endif
#line 5369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredLod(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5370
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5375
::exit(___);}
#if 0
#line 5370
{ 
#line 5371
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5372
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5374
return make_float2(w.x, w.y); 
#line 5375
} 
#endif
#line 5377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5378
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5383
::exit(___);}
#if 0
#line 5378
{ 
#line 5379
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5380
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5382
return make_float2(w.x, w.y); 
#line 5383
} 
#endif
#line 5385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredLod(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5386
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5391
::exit(___);}
#if 0
#line 5386
{ 
#line 5387
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5388
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5390
return make_float4(w.x, w.y, w.z, w.w); 
#line 5391
} 
#endif
#line 5393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5394
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5399
::exit(___);}
#if 0
#line 5394
{ 
#line 5395
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5396
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5398
return make_float4(w.x, w.y, w.z, w.w); 
#line 5399
} 
#endif
#line 5407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5408
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5413
::exit(___);}
#if 0
#line 5408
{ 
#line 5409
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5410
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5412
return w.x; 
#line 5413
} 
#endif
#line 5415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5416
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5421
::exit(___);}
#if 0
#line 5416
{ 
#line 5417
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5418
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5420
return w.x; 
#line 5421
} 
#endif
#line 5423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredLod(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5424
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5429
::exit(___);}
#if 0
#line 5424
{ 
#line 5425
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5426
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5428
return make_float1(w.x); 
#line 5429
} 
#endif
#line 5431 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5432
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5437
::exit(___);}
#if 0
#line 5432
{ 
#line 5433
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5434
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5436
return make_float1(w.x); 
#line 5437
} 
#endif
#line 5439 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredLod(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5440
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5445
::exit(___);}
#if 0
#line 5440
{ 
#line 5441
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5442
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5444
return make_float2(w.x, w.y); 
#line 5445
} 
#endif
#line 5447 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5448
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5453
::exit(___);}
#if 0
#line 5448
{ 
#line 5449
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5450
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5452
return make_float2(w.x, w.y); 
#line 5453
} 
#endif
#line 5455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredLod(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5456
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5461
::exit(___);}
#if 0
#line 5456
{ 
#line 5457
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5458
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5460
return make_float4(w.x, w.y, w.z, w.w); 
#line 5461
} 
#endif
#line 5463 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5464
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5469
::exit(___);}
#if 0
#line 5464
{ 
#line 5465
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5466
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5468
return make_float4(w.x, w.y, w.z, w.w); 
#line 5469
} 
#endif
#line 5477 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex2DLayeredLod(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5478
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5486 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 5478 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 5482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5485 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 5486
} 
#endif
#line 5488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex2DLayeredLod(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5489
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5493
::exit(___);}
#if 0
#line 5489
{ 
#line 5490
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5492
return (signed char)(v.x); 
#line 5493
} 
#endif
#line 5495 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5496
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5500
::exit(___);}
#if 0
#line 5496
{ 
#line 5497
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5499
return (unsigned char)(v.x); 
#line 5500
} 
#endif
#line 5502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex2DLayeredLod(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5503
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5507
::exit(___);}
#if 0
#line 5503
{ 
#line 5504
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5506
return make_char1(v.x); 
#line 5507
} 
#endif
#line 5509 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5510
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5514
::exit(___);}
#if 0
#line 5510
{ 
#line 5511
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5513
return make_uchar1(v.x); 
#line 5514
} 
#endif
#line 5516 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex2DLayeredLod(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5517
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5521
::exit(___);}
#if 0
#line 5517
{ 
#line 5518
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5520
return make_char2(v.x, v.y); 
#line 5521
} 
#endif
#line 5523 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5524
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5528
::exit(___);}
#if 0
#line 5524
{ 
#line 5525
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5527
return make_uchar2(v.x, v.y); 
#line 5528
} 
#endif
#line 5530 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2DLayeredLod(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5531
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5535
::exit(___);}
#if 0
#line 5531
{ 
#line 5532
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5534
return make_char4(v.x, v.y, v.z, v.w); 
#line 5535
} 
#endif
#line 5537 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5538
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5542
::exit(___);}
#if 0
#line 5538
{ 
#line 5539
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5541
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 5542
} 
#endif
#line 5550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex2DLayeredLod(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5551
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5555
::exit(___);}
#if 0
#line 5551
{ 
#line 5552
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5554
return (short)(v.x); 
#line 5555
} 
#endif
#line 5557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5558
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5562
::exit(___);}
#if 0
#line 5558
{ 
#line 5559
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5561
return (unsigned short)(v.x); 
#line 5562
} 
#endif
#line 5564 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex2DLayeredLod(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5565
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5569
::exit(___);}
#if 0
#line 5565
{ 
#line 5566
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5568
return make_short1(v.x); 
#line 5569
} 
#endif
#line 5571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5572
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5576
::exit(___);}
#if 0
#line 5572
{ 
#line 5573
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5575
return make_ushort1(v.x); 
#line 5576
} 
#endif
#line 5578 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex2DLayeredLod(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5579
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5583
::exit(___);}
#if 0
#line 5579
{ 
#line 5580
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5582
return make_short2(v.x, v.y); 
#line 5583
} 
#endif
#line 5585 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5586
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5590
::exit(___);}
#if 0
#line 5586
{ 
#line 5587
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5589
return make_ushort2(v.x, v.y); 
#line 5590
} 
#endif
#line 5592 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2DLayeredLod(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5593
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5597
::exit(___);}
#if 0
#line 5593
{ 
#line 5594
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5596
return make_short4(v.x, v.y, v.z, v.w); 
#line 5597
} 
#endif
#line 5599 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5600
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5604
::exit(___);}
#if 0
#line 5600
{ 
#line 5601
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5603
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 5604
} 
#endif
#line 5612 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex2DLayeredLod(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5613
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5617
::exit(___);}
#if 0
#line 5613
{ 
#line 5614
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5616
return v.x; 
#line 5617
} 
#endif
#line 5619 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex2DLayeredLod(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5620
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5624
::exit(___);}
#if 0
#line 5620
{ 
#line 5621
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5623
return v.x; 
#line 5624
} 
#endif
#line 5626 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex2DLayeredLod(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5627
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5631
::exit(___);}
#if 0
#line 5627
{ 
#line 5628
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5630
return make_int1(v.x); 
#line 5631
} 
#endif
#line 5633 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex2DLayeredLod(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5634
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5638
::exit(___);}
#if 0
#line 5634
{ 
#line 5635
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5637
return make_uint1(v.x); 
#line 5638
} 
#endif
#line 5640 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex2DLayeredLod(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5641
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5645
::exit(___);}
#if 0
#line 5641
{ 
#line 5642
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5644
return make_int2(v.x, v.y); 
#line 5645
} 
#endif
#line 5647 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex2DLayeredLod(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5648
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5652
::exit(___);}
#if 0
#line 5648
{ 
#line 5649
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5651
return make_uint2(v.x, v.y); 
#line 5652
} 
#endif
#line 5654 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2DLayeredLod(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5655
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5659
::exit(___);}
#if 0
#line 5655
{ 
#line 5656
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5658
return make_int4(v.x, v.y, v.z, v.w); 
#line 5659
} 
#endif
#line 5661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2DLayeredLod(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5662
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5666
::exit(___);}
#if 0
#line 5662
{ 
#line 5663
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5665
return make_uint4(v.x, v.y, v.z, v.w); 
#line 5666
} 
#endif
#line 5676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex2DLayeredLod(texture< long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5677
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5681
::exit(___);}
#if 0
#line 5677
{ 
#line 5678
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5680
return (long)(v.x); 
#line 5681
} 
#endif
#line 5683 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex2DLayeredLod(texture< unsigned long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5684
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5688
::exit(___);}
#if 0
#line 5684
{ 
#line 5685
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5687
return (unsigned long)(v.x); 
#line 5688
} 
#endif
#line 5690 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex2DLayeredLod(texture< long1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5691
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5695
::exit(___);}
#if 0
#line 5691
{ 
#line 5692
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5694
return make_long1(v.x); 
#line 5695
} 
#endif
#line 5697 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex2DLayeredLod(texture< ulong1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5698
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5702
::exit(___);}
#if 0
#line 5698
{ 
#line 5699
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5701
return make_ulong1(v.x); 
#line 5702
} 
#endif
#line 5704 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex2DLayeredLod(texture< long2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5705
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5709
::exit(___);}
#if 0
#line 5705
{ 
#line 5706
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5708
return make_long2(v.x, v.y); 
#line 5709
} 
#endif
#line 5711 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex2DLayeredLod(texture< ulong2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5712
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5716
::exit(___);}
#if 0
#line 5712
{ 
#line 5713
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5715
return make_ulong2(v.x, v.y); 
#line 5716
} 
#endif
#line 5718 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex2DLayeredLod(texture< long4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5719
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5723
::exit(___);}
#if 0
#line 5719
{ 
#line 5720
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5722
return make_long4(v.x, v.y, v.z, v.w); 
#line 5723
} 
#endif
#line 5725 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex2DLayeredLod(texture< ulong4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5726
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5730
::exit(___);}
#if 0
#line 5726
{ 
#line 5727
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5729
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 5730
} 
#endif
#line 5740 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5741
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5745
::exit(___);}
#if 0
#line 5741
{ 
#line 5742
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5744
return v.x; 
#line 5745
} 
#endif
#line 5747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredLod(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5748
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5752
::exit(___);}
#if 0
#line 5748
{ 
#line 5749
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5751
return make_float1(v.x); 
#line 5752
} 
#endif
#line 5754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredLod(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5755
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5759
::exit(___);}
#if 0
#line 5755
{ 
#line 5756
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5758
return make_float2(v.x, v.y); 
#line 5759
} 
#endif
#line 5761 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredLod(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5762
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5766
::exit(___);}
#if 0
#line 5762
{ 
#line 5763
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5765
return make_float4(v.x, v.y, v.z, v.w); 
#line 5766
} 
#endif
#line 5774 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5775
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5784 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 5775 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 5779 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5783
return w.x; 
#line 5784
} 
#endif
#line 5786 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5787
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5792
::exit(___);}
#if 0
#line 5787
{ 
#line 5788
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5789
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5791
return w.x; 
#line 5792
} 
#endif
#line 5794 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5795
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5800
::exit(___);}
#if 0
#line 5795
{ 
#line 5796
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5797
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5799
return w.x; 
#line 5800
} 
#endif
#line 5802 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredLod(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5803
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5808
::exit(___);}
#if 0
#line 5803
{ 
#line 5804
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5805
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5807
return make_float1(w.x); 
#line 5808
} 
#endif
#line 5810 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5811
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5816
::exit(___);}
#if 0
#line 5811
{ 
#line 5812
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5813
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5815
return make_float1(w.x); 
#line 5816
} 
#endif
#line 5818 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredLod(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5819
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5824
::exit(___);}
#if 0
#line 5819
{ 
#line 5820
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5821
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5823
return make_float2(w.x, w.y); 
#line 5824
} 
#endif
#line 5826 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5827
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5832
::exit(___);}
#if 0
#line 5827
{ 
#line 5828
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5829
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5831
return make_float2(w.x, w.y); 
#line 5832
} 
#endif
#line 5834 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredLod(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5835
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5840
::exit(___);}
#if 0
#line 5835
{ 
#line 5836
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5837
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5839
return make_float4(w.x, w.y, w.z, w.w); 
#line 5840
} 
#endif
#line 5842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5848
::exit(___);}
#if 0
#line 5843
{ 
#line 5844
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5845
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5847
return make_float4(w.x, w.y, w.z, w.w); 
#line 5848
} 
#endif
#line 5856 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5862
::exit(___);}
#if 0
#line 5857
{ 
#line 5858
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5859
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5861
return w.x; 
#line 5862
} 
#endif
#line 5864 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5865
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5870
::exit(___);}
#if 0
#line 5865
{ 
#line 5866
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5867
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5869
return w.x; 
#line 5870
} 
#endif
#line 5872 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredLod(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5873
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5878
::exit(___);}
#if 0
#line 5873
{ 
#line 5874
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5875
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5877
return make_float1(w.x); 
#line 5878
} 
#endif
#line 5880 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5881
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5886
::exit(___);}
#if 0
#line 5881
{ 
#line 5882
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5883
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5885
return make_float1(w.x); 
#line 5886
} 
#endif
#line 5888 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredLod(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5889
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5894
::exit(___);}
#if 0
#line 5889
{ 
#line 5890
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5891
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5893
return make_float2(w.x, w.y); 
#line 5894
} 
#endif
#line 5896 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5897
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5902
::exit(___);}
#if 0
#line 5897
{ 
#line 5898
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5899
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5901
return make_float2(w.x, w.y); 
#line 5902
} 
#endif
#line 5904 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredLod(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5910
::exit(___);}
#if 0
#line 5905
{ 
#line 5906
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5907
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5909
return make_float4(w.x, w.y, w.z, w.w); 
#line 5910
} 
#endif
#line 5912 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5913
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5918
::exit(___);}
#if 0
#line 5913
{ 
#line 5914
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5915
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5917
return make_float4(w.x, w.y, w.z, w.w); 
#line 5918
} 
#endif
#line 5926 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex3DLod(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5927
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5935 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 5927 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 5931 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5934 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 5935
} 
#endif
#line 5937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex3DLod(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5942
::exit(___);}
#if 0
#line 5938
{ 
#line 5939
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5941
return (signed char)(v.x); 
#line 5942
} 
#endif
#line 5944 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex3DLod(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5945
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5949
::exit(___);}
#if 0
#line 5945
{ 
#line 5946
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5948
return (unsigned char)(v.x); 
#line 5949
} 
#endif
#line 5951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex3DLod(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5952
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5956
::exit(___);}
#if 0
#line 5952
{ 
#line 5953
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5955
return make_char1(v.x); 
#line 5956
} 
#endif
#line 5958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex3DLod(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5959
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5963
::exit(___);}
#if 0
#line 5959
{ 
#line 5960
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5962
return make_uchar1(v.x); 
#line 5963
} 
#endif
#line 5965 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex3DLod(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5966
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5970
::exit(___);}
#if 0
#line 5966
{ 
#line 5967
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5969
return make_char2(v.x, v.y); 
#line 5970
} 
#endif
#line 5972 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex3DLod(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5973
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5977
::exit(___);}
#if 0
#line 5973
{ 
#line 5974
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5976
return make_uchar2(v.x, v.y); 
#line 5977
} 
#endif
#line 5979 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex3DLod(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5980
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5984
::exit(___);}
#if 0
#line 5980
{ 
#line 5981
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5983
return make_char4(v.x, v.y, v.z, v.w); 
#line 5984
} 
#endif
#line 5986 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex3DLod(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5987
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5991
::exit(___);}
#if 0
#line 5987
{ 
#line 5988
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5990
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 5991
} 
#endif
#line 5999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex3DLod(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6004
::exit(___);}
#if 0
#line 6000
{ 
#line 6001
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6003
return (short)(v.x); 
#line 6004
} 
#endif
#line 6006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex3DLod(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6007
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6011
::exit(___);}
#if 0
#line 6007
{ 
#line 6008
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6010
return (unsigned short)(v.x); 
#line 6011
} 
#endif
#line 6013 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex3DLod(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6014
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6018
::exit(___);}
#if 0
#line 6014
{ 
#line 6015
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6017
return make_short1(v.x); 
#line 6018
} 
#endif
#line 6020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex3DLod(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6021
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6025
::exit(___);}
#if 0
#line 6021
{ 
#line 6022
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6024
return make_ushort1(v.x); 
#line 6025
} 
#endif
#line 6027 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex3DLod(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6028
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6032
::exit(___);}
#if 0
#line 6028
{ 
#line 6029
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6031
return make_short2(v.x, v.y); 
#line 6032
} 
#endif
#line 6034 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex3DLod(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6035
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6039
::exit(___);}
#if 0
#line 6035
{ 
#line 6036
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6038
return make_ushort2(v.x, v.y); 
#line 6039
} 
#endif
#line 6041 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex3DLod(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6042
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6046
::exit(___);}
#if 0
#line 6042
{ 
#line 6043
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6045
return make_short4(v.x, v.y, v.z, v.w); 
#line 6046
} 
#endif
#line 6048 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex3DLod(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6049
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6053
::exit(___);}
#if 0
#line 6049
{ 
#line 6050
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6052
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 6053
} 
#endif
#line 6061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex3DLod(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6062
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6066
::exit(___);}
#if 0
#line 6062
{ 
#line 6063
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6065
return v.x; 
#line 6066
} 
#endif
#line 6068 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex3DLod(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6069
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6073
::exit(___);}
#if 0
#line 6069
{ 
#line 6070
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6072
return v.x; 
#line 6073
} 
#endif
#line 6075 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex3DLod(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6076
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6080
::exit(___);}
#if 0
#line 6076
{ 
#line 6077
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6079
return make_int1(v.x); 
#line 6080
} 
#endif
#line 6082 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex3DLod(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6083
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6087
::exit(___);}
#if 0
#line 6083
{ 
#line 6084
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6086
return make_uint1(v.x); 
#line 6087
} 
#endif
#line 6089 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex3DLod(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6090
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6094
::exit(___);}
#if 0
#line 6090
{ 
#line 6091
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6093
return make_int2(v.x, v.y); 
#line 6094
} 
#endif
#line 6096 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex3DLod(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6097
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6101
::exit(___);}
#if 0
#line 6097
{ 
#line 6098
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6100
return make_uint2(v.x, v.y); 
#line 6101
} 
#endif
#line 6103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex3DLod(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6104
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6108
::exit(___);}
#if 0
#line 6104
{ 
#line 6105
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6107
return make_int4(v.x, v.y, v.z, v.w); 
#line 6108
} 
#endif
#line 6110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex3DLod(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6111
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6115
::exit(___);}
#if 0
#line 6111
{ 
#line 6112
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6114
return make_uint4(v.x, v.y, v.z, v.w); 
#line 6115
} 
#endif
#line 6125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex3DLod(texture< long, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6126
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6130
::exit(___);}
#if 0
#line 6126
{ 
#line 6127
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6129
return (long)(v.x); 
#line 6130
} 
#endif
#line 6132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex3DLod(texture< unsigned long, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6133
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6137
::exit(___);}
#if 0
#line 6133
{ 
#line 6134
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6136
return (unsigned long)(v.x); 
#line 6137
} 
#endif
#line 6139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex3DLod(texture< long1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6140
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6144
::exit(___);}
#if 0
#line 6140
{ 
#line 6141
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6143
return make_long1(v.x); 
#line 6144
} 
#endif
#line 6146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex3DLod(texture< ulong1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6147
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6151
::exit(___);}
#if 0
#line 6147
{ 
#line 6148
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6150
return make_ulong1(v.x); 
#line 6151
} 
#endif
#line 6153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex3DLod(texture< long2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6154
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6158
::exit(___);}
#if 0
#line 6154
{ 
#line 6155
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6157
return make_long2(v.x, v.y); 
#line 6158
} 
#endif
#line 6160 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex3DLod(texture< ulong2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6161
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6165
::exit(___);}
#if 0
#line 6161
{ 
#line 6162
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6164
return make_ulong2(v.x, v.y); 
#line 6165
} 
#endif
#line 6167 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex3DLod(texture< long4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6168
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6172
::exit(___);}
#if 0
#line 6168
{ 
#line 6169
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6171
return make_long4(v.x, v.y, v.z, v.w); 
#line 6172
} 
#endif
#line 6174 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex3DLod(texture< ulong4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6175
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6179
::exit(___);}
#if 0
#line 6175
{ 
#line 6176
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6178
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 6179
} 
#endif
#line 6189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6190
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6194
::exit(___);}
#if 0
#line 6190
{ 
#line 6191
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6193
return v.x; 
#line 6194
} 
#endif
#line 6196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DLod(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6197
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6201
::exit(___);}
#if 0
#line 6197
{ 
#line 6198
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6200
return make_float1(v.x); 
#line 6201
} 
#endif
#line 6203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DLod(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6204
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6208
::exit(___);}
#if 0
#line 6204
{ 
#line 6205
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6207
return make_float2(v.x, v.y); 
#line 6208
} 
#endif
#line 6210 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DLod(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6211
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6215
::exit(___);}
#if 0
#line 6211
{ 
#line 6212
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6214
return make_float4(v.x, v.y, v.z, v.w); 
#line 6215
} 
#endif
#line 6223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6224
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 6224 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 6228 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6232
return w.x; 
#line 6233
} 
#endif
#line 6235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6236
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6241
::exit(___);}
#if 0
#line 6236
{ 
#line 6237
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6238
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6240
return w.x; 
#line 6241
} 
#endif
#line 6243 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6244
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6249
::exit(___);}
#if 0
#line 6244
{ 
#line 6245
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6246
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6248
return w.x; 
#line 6249
} 
#endif
#line 6251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DLod(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6252
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6257
::exit(___);}
#if 0
#line 6252
{ 
#line 6253
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6254
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6256
return make_float1(w.x); 
#line 6257
} 
#endif
#line 6259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DLod(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6260
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6265
::exit(___);}
#if 0
#line 6260
{ 
#line 6261
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6262
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6264
return make_float1(w.x); 
#line 6265
} 
#endif
#line 6267 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DLod(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6268
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6273
::exit(___);}
#if 0
#line 6268
{ 
#line 6269
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6270
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6272
return make_float2(w.x, w.y); 
#line 6273
} 
#endif
#line 6275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DLod(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6276
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6281
::exit(___);}
#if 0
#line 6276
{ 
#line 6277
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6278
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6280
return make_float2(w.x, w.y); 
#line 6281
} 
#endif
#line 6283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DLod(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6284
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6289
::exit(___);}
#if 0
#line 6284
{ 
#line 6285
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6286
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6288
return make_float4(w.x, w.y, w.z, w.w); 
#line 6289
} 
#endif
#line 6291 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DLod(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6292
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6297
::exit(___);}
#if 0
#line 6292
{ 
#line 6293
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6294
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6296
return make_float4(w.x, w.y, w.z, w.w); 
#line 6297
} 
#endif
#line 6305 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6306
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6311
::exit(___);}
#if 0
#line 6306
{ 
#line 6307
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6308
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6310
return w.x; 
#line 6311
} 
#endif
#line 6313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6314
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6319
::exit(___);}
#if 0
#line 6314
{ 
#line 6315
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6316
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6318
return w.x; 
#line 6319
} 
#endif
#line 6321 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DLod(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6322
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6327
::exit(___);}
#if 0
#line 6322
{ 
#line 6323
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6324
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6326
return make_float1(w.x); 
#line 6327
} 
#endif
#line 6329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DLod(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6330
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6335
::exit(___);}
#if 0
#line 6330
{ 
#line 6331
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6332
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6334
return make_float1(w.x); 
#line 6335
} 
#endif
#line 6337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DLod(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6338
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6343
::exit(___);}
#if 0
#line 6338
{ 
#line 6339
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6340
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6342
return make_float2(w.x, w.y); 
#line 6343
} 
#endif
#line 6345 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DLod(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6346
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6351
::exit(___);}
#if 0
#line 6346
{ 
#line 6347
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6348
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6350
return make_float2(w.x, w.y); 
#line 6351
} 
#endif
#line 6353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DLod(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6354
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6359
::exit(___);}
#if 0
#line 6354
{ 
#line 6355
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6356
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6358
return make_float4(w.x, w.y, w.z, w.w); 
#line 6359
} 
#endif
#line 6361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DLod(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6362
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6367
::exit(___);}
#if 0
#line 6362
{ 
#line 6363
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6364
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6366
return make_float4(w.x, w.y, w.z, w.w); 
#line 6367
} 
#endif
#line 6375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char texCubemapLod(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6376
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 6376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 6380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 6384
} 
#endif
#line 6386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char texCubemapLod(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6387
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6391
::exit(___);}
#if 0
#line 6387
{ 
#line 6388
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6390
return (signed char)(v.x); 
#line 6391
} 
#endif
#line 6393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char texCubemapLod(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6394
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6398
::exit(___);}
#if 0
#line 6394
{ 
#line 6395
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6397
return (unsigned char)(v.x); 
#line 6398
} 
#endif
#line 6400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 texCubemapLod(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6401
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6405
::exit(___);}
#if 0
#line 6401
{ 
#line 6402
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6404
return make_char1(v.x); 
#line 6405
} 
#endif
#line 6407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 texCubemapLod(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6408
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6412
::exit(___);}
#if 0
#line 6408
{ 
#line 6409
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6411
return make_uchar1(v.x); 
#line 6412
} 
#endif
#line 6414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 texCubemapLod(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6415
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6419
::exit(___);}
#if 0
#line 6415
{ 
#line 6416
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6418
return make_char2(v.x, v.y); 
#line 6419
} 
#endif
#line 6421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 texCubemapLod(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6422
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6426
::exit(___);}
#if 0
#line 6422
{ 
#line 6423
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6425
return make_uchar2(v.x, v.y); 
#line 6426
} 
#endif
#line 6428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 texCubemapLod(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6429
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6433
::exit(___);}
#if 0
#line 6429
{ 
#line 6430
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6432
return make_char4(v.x, v.y, v.z, v.w); 
#line 6433
} 
#endif
#line 6435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 texCubemapLod(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6436
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6440
::exit(___);}
#if 0
#line 6436
{ 
#line 6437
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6439
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 6440
} 
#endif
#line 6448 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short texCubemapLod(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6449
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6453
::exit(___);}
#if 0
#line 6449
{ 
#line 6450
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6452
return (short)(v.x); 
#line 6453
} 
#endif
#line 6455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short texCubemapLod(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6456
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6460
::exit(___);}
#if 0
#line 6456
{ 
#line 6457
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6459
return (unsigned short)(v.x); 
#line 6460
} 
#endif
#line 6462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 texCubemapLod(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6463
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6467
::exit(___);}
#if 0
#line 6463
{ 
#line 6464
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6466
return make_short1(v.x); 
#line 6467
} 
#endif
#line 6469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 texCubemapLod(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6470
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6474
::exit(___);}
#if 0
#line 6470
{ 
#line 6471
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6473
return make_ushort1(v.x); 
#line 6474
} 
#endif
#line 6476 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 texCubemapLod(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6477
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6481
::exit(___);}
#if 0
#line 6477
{ 
#line 6478
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6480
return make_short2(v.x, v.y); 
#line 6481
} 
#endif
#line 6483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 texCubemapLod(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6484
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6488
::exit(___);}
#if 0
#line 6484
{ 
#line 6485
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6487
return make_ushort2(v.x, v.y); 
#line 6488
} 
#endif
#line 6490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 texCubemapLod(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6491
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6495
::exit(___);}
#if 0
#line 6491
{ 
#line 6492
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6494
return make_short4(v.x, v.y, v.z, v.w); 
#line 6495
} 
#endif
#line 6497 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 texCubemapLod(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6498
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6502
::exit(___);}
#if 0
#line 6498
{ 
#line 6499
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6501
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 6502
} 
#endif
#line 6510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int texCubemapLod(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6511
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6515
::exit(___);}
#if 0
#line 6511
{ 
#line 6512
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6514
return v.x; 
#line 6515
} 
#endif
#line 6517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned texCubemapLod(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6518
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6522
::exit(___);}
#if 0
#line 6518
{ 
#line 6519
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6521
return v.x; 
#line 6522
} 
#endif
#line 6524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 texCubemapLod(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6525
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6529
::exit(___);}
#if 0
#line 6525
{ 
#line 6526
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6528
return make_int1(v.x); 
#line 6529
} 
#endif
#line 6531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 texCubemapLod(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6532
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6536
::exit(___);}
#if 0
#line 6532
{ 
#line 6533
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6535
return make_uint1(v.x); 
#line 6536
} 
#endif
#line 6538 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 texCubemapLod(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6539
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6543
::exit(___);}
#if 0
#line 6539
{ 
#line 6540
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6542
return make_int2(v.x, v.y); 
#line 6543
} 
#endif
#line 6545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 texCubemapLod(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6546
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6550
::exit(___);}
#if 0
#line 6546
{ 
#line 6547
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6549
return make_uint2(v.x, v.y); 
#line 6550
} 
#endif
#line 6552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 texCubemapLod(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6553
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6557
::exit(___);}
#if 0
#line 6553
{ 
#line 6554
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6556
return make_int4(v.x, v.y, v.z, v.w); 
#line 6557
} 
#endif
#line 6559 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 texCubemapLod(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6560
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6564
::exit(___);}
#if 0
#line 6560
{ 
#line 6561
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6563
return make_uint4(v.x, v.y, v.z, v.w); 
#line 6564
} 
#endif
#line 6574 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long texCubemapLod(texture< long, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6575
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6579
::exit(___);}
#if 0
#line 6575
{ 
#line 6576
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6578
return (long)(v.x); 
#line 6579
} 
#endif
#line 6581 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long texCubemapLod(texture< unsigned long, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6582
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6586
::exit(___);}
#if 0
#line 6582
{ 
#line 6583
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6585
return (unsigned long)(v.x); 
#line 6586
} 
#endif
#line 6588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 texCubemapLod(texture< long1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6589
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6593
::exit(___);}
#if 0
#line 6589
{ 
#line 6590
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6592
return make_long1(v.x); 
#line 6593
} 
#endif
#line 6595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 texCubemapLod(texture< ulong1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6596
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6600
::exit(___);}
#if 0
#line 6596
{ 
#line 6597
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6599
return make_ulong1(v.x); 
#line 6600
} 
#endif
#line 6602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 texCubemapLod(texture< long2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6603
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6607
::exit(___);}
#if 0
#line 6603
{ 
#line 6604
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6606
return make_long2(v.x, v.y); 
#line 6607
} 
#endif
#line 6609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 texCubemapLod(texture< ulong2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6610
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6614
::exit(___);}
#if 0
#line 6610
{ 
#line 6611
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6613
return make_ulong2(v.x, v.y); 
#line 6614
} 
#endif
#line 6616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 texCubemapLod(texture< long4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6617
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6621
::exit(___);}
#if 0
#line 6617
{ 
#line 6618
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6620
return make_long4(v.x, v.y, v.z, v.w); 
#line 6621
} 
#endif
#line 6623 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 texCubemapLod(texture< ulong4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6624
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6628
::exit(___);}
#if 0
#line 6624
{ 
#line 6625
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6627
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 6628
} 
#endif
#line 6638 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6639
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6643
::exit(___);}
#if 0
#line 6639
{ 
#line 6640
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6642
return v.x; 
#line 6643
} 
#endif
#line 6645 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLod(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6646
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6650
::exit(___);}
#if 0
#line 6646
{ 
#line 6647
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6649
return make_float1(v.x); 
#line 6650
} 
#endif
#line 6652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLod(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6653
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6657
::exit(___);}
#if 0
#line 6653
{ 
#line 6654
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6656
return make_float2(v.x, v.y); 
#line 6657
} 
#endif
#line 6659 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLod(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6660
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6664
::exit(___);}
#if 0
#line 6660
{ 
#line 6661
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6663
return make_float4(v.x, v.y, v.z, v.w); 
#line 6664
} 
#endif
#line 6672 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6682 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 6673 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 6677 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6679 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6681
return w.x; 
#line 6682
} 
#endif
#line 6684 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6685
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6690
::exit(___);}
#if 0
#line 6685
{ 
#line 6686
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6687
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6689
return w.x; 
#line 6690
} 
#endif
#line 6692 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6693
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6698
::exit(___);}
#if 0
#line 6693
{ 
#line 6694
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6695
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6697
return w.x; 
#line 6698
} 
#endif
#line 6700 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLod(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6701
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6706
::exit(___);}
#if 0
#line 6701
{ 
#line 6702
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6703
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6705
return make_float1(w.x); 
#line 6706
} 
#endif
#line 6708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLod(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6709
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6714
::exit(___);}
#if 0
#line 6709
{ 
#line 6710
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6711
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6713
return make_float1(w.x); 
#line 6714
} 
#endif
#line 6716 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLod(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6717
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6722
::exit(___);}
#if 0
#line 6717
{ 
#line 6718
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6719
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6721
return make_float2(w.x, w.y); 
#line 6722
} 
#endif
#line 6724 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLod(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6725
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6730
::exit(___);}
#if 0
#line 6725
{ 
#line 6726
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6727
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6729
return make_float2(w.x, w.y); 
#line 6730
} 
#endif
#line 6732 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLod(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6733
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6738
::exit(___);}
#if 0
#line 6733
{ 
#line 6734
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6735
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6737
return make_float4(w.x, w.y, w.z, w.w); 
#line 6738
} 
#endif
#line 6740 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLod(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6741
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6746
::exit(___);}
#if 0
#line 6741
{ 
#line 6742
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6743
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6745
return make_float4(w.x, w.y, w.z, w.w); 
#line 6746
} 
#endif
#line 6754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6755
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6760
::exit(___);}
#if 0
#line 6755
{ 
#line 6756
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6757
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6759
return w.x; 
#line 6760
} 
#endif
#line 6762 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6763
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6768
::exit(___);}
#if 0
#line 6763
{ 
#line 6764
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6765
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6767
return w.x; 
#line 6768
} 
#endif
#line 6770 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLod(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6771
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6776
::exit(___);}
#if 0
#line 6771
{ 
#line 6772
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6773
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6775
return make_float1(w.x); 
#line 6776
} 
#endif
#line 6778 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLod(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6779
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6784
::exit(___);}
#if 0
#line 6779
{ 
#line 6780
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6781
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6783
return make_float1(w.x); 
#line 6784
} 
#endif
#line 6786 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLod(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6787
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6792
::exit(___);}
#if 0
#line 6787
{ 
#line 6788
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6789
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6791
return make_float2(w.x, w.y); 
#line 6792
} 
#endif
#line 6794 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLod(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6795
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6800
::exit(___);}
#if 0
#line 6795
{ 
#line 6796
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6797
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6799
return make_float2(w.x, w.y); 
#line 6800
} 
#endif
#line 6802 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLod(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6803
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6808
::exit(___);}
#if 0
#line 6803
{ 
#line 6804
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6805
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6807
return make_float4(w.x, w.y, w.z, w.w); 
#line 6808
} 
#endif
#line 6810 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLod(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6811
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6816
::exit(___);}
#if 0
#line 6811
{ 
#line 6812
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6813
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6815
return make_float4(w.x, w.y, w.z, w.w); 
#line 6816
} 
#endif
#line 6824 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char texCubemapLayeredLod(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6825
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6833 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 6825 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 6829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6832 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 6833
} 
#endif
#line 6835 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char texCubemapLayeredLod(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6836
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6840
::exit(___);}
#if 0
#line 6836
{ 
#line 6837
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6839
return (signed char)(v.x); 
#line 6840
} 
#endif
#line 6842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6847
::exit(___);}
#if 0
#line 6843
{ 
#line 6844
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6846
return (unsigned char)(v.x); 
#line 6847
} 
#endif
#line 6849 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6854
::exit(___);}
#if 0
#line 6850
{ 
#line 6851
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6853
return make_char1(v.x); 
#line 6854
} 
#endif
#line 6856 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6861
::exit(___);}
#if 0
#line 6857
{ 
#line 6858
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6860
return make_uchar1(v.x); 
#line 6861
} 
#endif
#line 6863 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6864
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6868
::exit(___);}
#if 0
#line 6864
{ 
#line 6865
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6867
return make_char2(v.x, v.y); 
#line 6868
} 
#endif
#line 6870 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6871
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6875
::exit(___);}
#if 0
#line 6871
{ 
#line 6872
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6874
return make_uchar2(v.x, v.y); 
#line 6875
} 
#endif
#line 6877 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6878
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6882
::exit(___);}
#if 0
#line 6878
{ 
#line 6879
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6881
return make_char4(v.x, v.y, v.z, v.w); 
#line 6882
} 
#endif
#line 6884 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6885
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6889
::exit(___);}
#if 0
#line 6885
{ 
#line 6886
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6888
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 6889
} 
#endif
#line 6897 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short texCubemapLayeredLod(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6902
::exit(___);}
#if 0
#line 6898
{ 
#line 6899
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6901
return (short)(v.x); 
#line 6902
} 
#endif
#line 6904 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6909
::exit(___);}
#if 0
#line 6905
{ 
#line 6906
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6908
return (unsigned short)(v.x); 
#line 6909
} 
#endif
#line 6911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6912
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6916
::exit(___);}
#if 0
#line 6912
{ 
#line 6913
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6915
return make_short1(v.x); 
#line 6916
} 
#endif
#line 6918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6919
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6923
::exit(___);}
#if 0
#line 6919
{ 
#line 6920
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6922
return make_ushort1(v.x); 
#line 6923
} 
#endif
#line 6925 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6926
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6930
::exit(___);}
#if 0
#line 6926
{ 
#line 6927
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6929
return make_short2(v.x, v.y); 
#line 6930
} 
#endif
#line 6932 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6933
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6937
::exit(___);}
#if 0
#line 6933
{ 
#line 6934
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6936
return make_ushort2(v.x, v.y); 
#line 6937
} 
#endif
#line 6939 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6940
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6944
::exit(___);}
#if 0
#line 6940
{ 
#line 6941
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6943
return make_short4(v.x, v.y, v.z, v.w); 
#line 6944
} 
#endif
#line 6946 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6947
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6951
::exit(___);}
#if 0
#line 6947
{ 
#line 6948
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6950
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 6951
} 
#endif
#line 6959 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int texCubemapLayeredLod(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6960
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6964
::exit(___);}
#if 0
#line 6960
{ 
#line 6961
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6963
return v.x; 
#line 6964
} 
#endif
#line 6966 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned texCubemapLayeredLod(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6967
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6971
::exit(___);}
#if 0
#line 6967
{ 
#line 6968
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6970
return v.x; 
#line 6971
} 
#endif
#line 6973 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 texCubemapLayeredLod(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6974
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6978
::exit(___);}
#if 0
#line 6974
{ 
#line 6975
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6977
return make_int1(v.x); 
#line 6978
} 
#endif
#line 6980 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 texCubemapLayeredLod(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6981
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6985
::exit(___);}
#if 0
#line 6981
{ 
#line 6982
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6984
return make_uint1(v.x); 
#line 6985
} 
#endif
#line 6987 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 texCubemapLayeredLod(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6988
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6992
::exit(___);}
#if 0
#line 6988
{ 
#line 6989
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6991
return make_int2(v.x, v.y); 
#line 6992
} 
#endif
#line 6994 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 texCubemapLayeredLod(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6995
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6999
::exit(___);}
#if 0
#line 6995
{ 
#line 6996
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6998
return make_uint2(v.x, v.y); 
#line 6999
} 
#endif
#line 7001 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 texCubemapLayeredLod(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7002
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7006
::exit(___);}
#if 0
#line 7002
{ 
#line 7003
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7005
return make_int4(v.x, v.y, v.z, v.w); 
#line 7006
} 
#endif
#line 7008 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 texCubemapLayeredLod(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7009
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7013
::exit(___);}
#if 0
#line 7009
{ 
#line 7010
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7012
return make_uint4(v.x, v.y, v.z, v.w); 
#line 7013
} 
#endif
#line 7023 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long texCubemapLayeredLod(texture< long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7024
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7028
::exit(___);}
#if 0
#line 7024
{ 
#line 7025
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7027
return (long)(v.x); 
#line 7028
} 
#endif
#line 7030 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long texCubemapLayeredLod(texture< unsigned long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7031
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7035
::exit(___);}
#if 0
#line 7031
{ 
#line 7032
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7034
return (unsigned long)(v.x); 
#line 7035
} 
#endif
#line 7037 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 texCubemapLayeredLod(texture< long1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7038
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7042
::exit(___);}
#if 0
#line 7038
{ 
#line 7039
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7041
return make_long1(v.x); 
#line 7042
} 
#endif
#line 7044 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 texCubemapLayeredLod(texture< ulong1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7045
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7049
::exit(___);}
#if 0
#line 7045
{ 
#line 7046
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7048
return make_ulong1(v.x); 
#line 7049
} 
#endif
#line 7051 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 texCubemapLayeredLod(texture< long2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7052
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7056
::exit(___);}
#if 0
#line 7052
{ 
#line 7053
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7055
return make_long2(v.x, v.y); 
#line 7056
} 
#endif
#line 7058 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 texCubemapLayeredLod(texture< ulong2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7059
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7063
::exit(___);}
#if 0
#line 7059
{ 
#line 7060
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7062
return make_ulong2(v.x, v.y); 
#line 7063
} 
#endif
#line 7065 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 texCubemapLayeredLod(texture< long4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7066
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7070
::exit(___);}
#if 0
#line 7066
{ 
#line 7067
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7069
return make_long4(v.x, v.y, v.z, v.w); 
#line 7070
} 
#endif
#line 7072 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 texCubemapLayeredLod(texture< ulong4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7073
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7077
::exit(___);}
#if 0
#line 7073
{ 
#line 7074
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7076
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 7077
} 
#endif
#line 7087 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7088
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7092
::exit(___);}
#if 0
#line 7088
{ 
#line 7089
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7091
return v.x; 
#line 7092
} 
#endif
#line 7094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayeredLod(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7099
::exit(___);}
#if 0
#line 7095
{ 
#line 7096
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7098
return make_float1(v.x); 
#line 7099
} 
#endif
#line 7101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayeredLod(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7102
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7106
::exit(___);}
#if 0
#line 7102
{ 
#line 7103
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7105
return make_float2(v.x, v.y); 
#line 7106
} 
#endif
#line 7108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayeredLod(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7109
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7113
::exit(___);}
#if 0
#line 7109
{ 
#line 7110
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7112
return make_float4(v.x, v.y, v.z, v.w); 
#line 7113
} 
#endif
#line 7121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7122
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 7122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 7126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7130
return w.x; 
#line 7131
} 
#endif
#line 7133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7134
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7139
::exit(___);}
#if 0
#line 7134
{ 
#line 7135
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7136
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7138
return w.x; 
#line 7139
} 
#endif
#line 7141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7142
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7147
::exit(___);}
#if 0
#line 7142
{ 
#line 7143
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7144
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7146
return w.x; 
#line 7147
} 
#endif
#line 7149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7150
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7155
::exit(___);}
#if 0
#line 7150
{ 
#line 7151
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7152
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7154
return make_float1(w.x); 
#line 7155
} 
#endif
#line 7157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7158
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7163
::exit(___);}
#if 0
#line 7158
{ 
#line 7159
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7160
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7162
return make_float1(w.x); 
#line 7163
} 
#endif
#line 7165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7166
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7171
::exit(___);}
#if 0
#line 7166
{ 
#line 7167
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7168
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7170
return make_float2(w.x, w.y); 
#line 7171
} 
#endif
#line 7173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7174
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7179
::exit(___);}
#if 0
#line 7174
{ 
#line 7175
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7176
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7178
return make_float2(w.x, w.y); 
#line 7179
} 
#endif
#line 7181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7182
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7187
::exit(___);}
#if 0
#line 7182
{ 
#line 7183
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7184
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7186
return make_float4(w.x, w.y, w.z, w.w); 
#line 7187
} 
#endif
#line 7189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7190
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7195
::exit(___);}
#if 0
#line 7190
{ 
#line 7191
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7192
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7194
return make_float4(w.x, w.y, w.z, w.w); 
#line 7195
} 
#endif
#line 7203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7204
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7209
::exit(___);}
#if 0
#line 7204
{ 
#line 7205
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7206
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7208
return w.x; 
#line 7209
} 
#endif
#line 7211 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7212
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7217
::exit(___);}
#if 0
#line 7212
{ 
#line 7213
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7214
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7216
return w.x; 
#line 7217
} 
#endif
#line 7219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7220
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7225
::exit(___);}
#if 0
#line 7220
{ 
#line 7221
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7222
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7224
return make_float1(w.x); 
#line 7225
} 
#endif
#line 7227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7228
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7233
::exit(___);}
#if 0
#line 7228
{ 
#line 7229
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7230
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7232
return make_float1(w.x); 
#line 7233
} 
#endif
#line 7235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7236
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7241
::exit(___);}
#if 0
#line 7236
{ 
#line 7237
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7238
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7240
return make_float2(w.x, w.y); 
#line 7241
} 
#endif
#line 7243 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7244
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7249
::exit(___);}
#if 0
#line 7244
{ 
#line 7245
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7246
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7248
return make_float2(w.x, w.y); 
#line 7249
} 
#endif
#line 7251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7252
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7257
::exit(___);}
#if 0
#line 7252
{ 
#line 7253
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7254
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7256
return make_float4(w.x, w.y, w.z, w.w); 
#line 7257
} 
#endif
#line 7259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7260
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7265
::exit(___);}
#if 0
#line 7260
{ 
#line 7261
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7262
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7264
return make_float4(w.x, w.y, w.z, w.w); 
#line 7265
} 
#endif
#line 7281 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex1DGrad(texture< char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7282
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7290 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 7282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 7286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 7290
} 
#endif
#line 7292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1DGrad(texture< signed char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7293
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7297
::exit(___);}
#if 0
#line 7293
{ 
#line 7294
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7296
return (signed char)(v.x); 
#line 7297
} 
#endif
#line 7299 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1DGrad(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7300
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7304
::exit(___);}
#if 0
#line 7300
{ 
#line 7301
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7303
return (unsigned char)(v.x); 
#line 7304
} 
#endif
#line 7306 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1DGrad(texture< char1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7307
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7311
::exit(___);}
#if 0
#line 7307
{ 
#line 7308
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7310
return make_char1(v.x); 
#line 7311
} 
#endif
#line 7313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1DGrad(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7314
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7318
::exit(___);}
#if 0
#line 7314
{ 
#line 7315
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7317
return make_uchar1(v.x); 
#line 7318
} 
#endif
#line 7320 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1DGrad(texture< char2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7321
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7325
::exit(___);}
#if 0
#line 7321
{ 
#line 7322
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7324
return make_char2(v.x, v.y); 
#line 7325
} 
#endif
#line 7327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1DGrad(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7328
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7332
::exit(___);}
#if 0
#line 7328
{ 
#line 7329
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7331
return make_uchar2(v.x, v.y); 
#line 7332
} 
#endif
#line 7334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1DGrad(texture< char4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7335
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7339
::exit(___);}
#if 0
#line 7335
{ 
#line 7336
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7338
return make_char4(v.x, v.y, v.z, v.w); 
#line 7339
} 
#endif
#line 7341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1DGrad(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7342
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7346
::exit(___);}
#if 0
#line 7342
{ 
#line 7343
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7345
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 7346
} 
#endif
#line 7354 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex1DGrad(texture< short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7355
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7359
::exit(___);}
#if 0
#line 7355
{ 
#line 7356
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7358
return (short)(v.x); 
#line 7359
} 
#endif
#line 7361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1DGrad(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7362
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7366
::exit(___);}
#if 0
#line 7362
{ 
#line 7363
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7365
return (unsigned short)(v.x); 
#line 7366
} 
#endif
#line 7368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1DGrad(texture< short1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7369
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7373
::exit(___);}
#if 0
#line 7369
{ 
#line 7370
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7372
return make_short1(v.x); 
#line 7373
} 
#endif
#line 7375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1DGrad(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7376
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7380
::exit(___);}
#if 0
#line 7376
{ 
#line 7377
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7379
return make_ushort1(v.x); 
#line 7380
} 
#endif
#line 7382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1DGrad(texture< short2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7383
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7387
::exit(___);}
#if 0
#line 7383
{ 
#line 7384
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7386
return make_short2(v.x, v.y); 
#line 7387
} 
#endif
#line 7389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1DGrad(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7390
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7394
::exit(___);}
#if 0
#line 7390
{ 
#line 7391
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7393
return make_ushort2(v.x, v.y); 
#line 7394
} 
#endif
#line 7396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1DGrad(texture< short4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7397
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7401
::exit(___);}
#if 0
#line 7397
{ 
#line 7398
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7400
return make_short4(v.x, v.y, v.z, v.w); 
#line 7401
} 
#endif
#line 7403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1DGrad(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7404
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7408
::exit(___);}
#if 0
#line 7404
{ 
#line 7405
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7407
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 7408
} 
#endif
#line 7416 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex1DGrad(texture< int, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7417
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7421
::exit(___);}
#if 0
#line 7417
{ 
#line 7418
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7420
return v.x; 
#line 7421
} 
#endif
#line 7423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1DGrad(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7424
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7428
::exit(___);}
#if 0
#line 7424
{ 
#line 7425
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7427
return v.x; 
#line 7428
} 
#endif
#line 7430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1DGrad(texture< int1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7431
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7435
::exit(___);}
#if 0
#line 7431
{ 
#line 7432
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7434
return make_int1(v.x); 
#line 7435
} 
#endif
#line 7437 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1DGrad(texture< uint1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7438
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7442
::exit(___);}
#if 0
#line 7438
{ 
#line 7439
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7441
return make_uint1(v.x); 
#line 7442
} 
#endif
#line 7444 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1DGrad(texture< int2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7445
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7449
::exit(___);}
#if 0
#line 7445
{ 
#line 7446
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7448
return make_int2(v.x, v.y); 
#line 7449
} 
#endif
#line 7451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1DGrad(texture< uint2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7452
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7456
::exit(___);}
#if 0
#line 7452
{ 
#line 7453
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7455
return make_uint2(v.x, v.y); 
#line 7456
} 
#endif
#line 7458 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1DGrad(texture< int4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7459
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7463
::exit(___);}
#if 0
#line 7459
{ 
#line 7460
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7462
return make_int4(v.x, v.y, v.z, v.w); 
#line 7463
} 
#endif
#line 7465 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1DGrad(texture< uint4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7466
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7470
::exit(___);}
#if 0
#line 7466
{ 
#line 7467
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7469
return make_uint4(v.x, v.y, v.z, v.w); 
#line 7470
} 
#endif
#line 7486 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex1DGrad(texture< long, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7487
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7491
::exit(___);}
#if 0
#line 7487
{ 
#line 7488
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7490
return (long)(v.x); 
#line 7491
} 
#endif
#line 7493 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1DGrad(texture< unsigned long, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7494
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7498
::exit(___);}
#if 0
#line 7494
{ 
#line 7495
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7497
return (unsigned long)(v.x); 
#line 7498
} 
#endif
#line 7500 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1DGrad(texture< long1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7501
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7505
::exit(___);}
#if 0
#line 7501
{ 
#line 7502
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7504
return make_long1(v.x); 
#line 7505
} 
#endif
#line 7507 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1DGrad(texture< ulong1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7508
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7512
::exit(___);}
#if 0
#line 7508
{ 
#line 7509
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7511
return make_ulong1(v.x); 
#line 7512
} 
#endif
#line 7514 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1DGrad(texture< long2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7515
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7519
::exit(___);}
#if 0
#line 7515
{ 
#line 7516
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7518
return make_long2(v.x, v.y); 
#line 7519
} 
#endif
#line 7521 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1DGrad(texture< ulong2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7522
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7526
::exit(___);}
#if 0
#line 7522
{ 
#line 7523
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7525
return make_ulong2(v.x, v.y); 
#line 7526
} 
#endif
#line 7528 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1DGrad(texture< long4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7529
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7533
::exit(___);}
#if 0
#line 7529
{ 
#line 7530
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7532
return make_long4(v.x, v.y, v.z, v.w); 
#line 7533
} 
#endif
#line 7535 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1DGrad(texture< ulong4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7536
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7540
::exit(___);}
#if 0
#line 7536
{ 
#line 7537
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7539
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 7540
} 
#endif
#line 7550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< float, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7551
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7555
::exit(___);}
#if 0
#line 7551
{ 
#line 7552
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7554
return v.x; 
#line 7555
} 
#endif
#line 7557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DGrad(texture< float1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7558
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7562
::exit(___);}
#if 0
#line 7558
{ 
#line 7559
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7561
return make_float1(v.x); 
#line 7562
} 
#endif
#line 7564 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DGrad(texture< float2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7565
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7569
::exit(___);}
#if 0
#line 7565
{ 
#line 7566
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7568
return make_float2(v.x, v.y); 
#line 7569
} 
#endif
#line 7571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DGrad(texture< float4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7572
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7576
::exit(___);}
#if 0
#line 7572
{ 
#line 7573
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7575
return make_float4(v.x, v.y, v.z, v.w); 
#line 7576
} 
#endif
#line 7584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7585
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7594 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 7585 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 7589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7593
return w.x; 
#line 7594
} 
#endif
#line 7596 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7597
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7602
::exit(___);}
#if 0
#line 7597
{ 
#line 7598
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7599
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7601
return w.x; 
#line 7602
} 
#endif
#line 7604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7605
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7610
::exit(___);}
#if 0
#line 7605
{ 
#line 7606
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7607
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7609
return w.x; 
#line 7610
} 
#endif
#line 7612 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DGrad(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7613
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7618
::exit(___);}
#if 0
#line 7613
{ 
#line 7614
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7615
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7617
return make_float1(w.x); 
#line 7618
} 
#endif
#line 7620 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DGrad(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7621
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7626
::exit(___);}
#if 0
#line 7621
{ 
#line 7622
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7623
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7625
return make_float1(w.x); 
#line 7626
} 
#endif
#line 7628 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DGrad(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7629
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7634
::exit(___);}
#if 0
#line 7629
{ 
#line 7630
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7631
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7633
return make_float2(w.x, w.y); 
#line 7634
} 
#endif
#line 7636 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DGrad(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7637
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7642
::exit(___);}
#if 0
#line 7637
{ 
#line 7638
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7639
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7641
return make_float2(w.x, w.y); 
#line 7642
} 
#endif
#line 7644 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DGrad(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7645
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7650
::exit(___);}
#if 0
#line 7645
{ 
#line 7646
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7647
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7649
return make_float4(w.x, w.y, w.z, w.w); 
#line 7650
} 
#endif
#line 7652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DGrad(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7653
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7658
::exit(___);}
#if 0
#line 7653
{ 
#line 7654
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7655
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7657
return make_float4(w.x, w.y, w.z, w.w); 
#line 7658
} 
#endif
#line 7666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7667
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7672
::exit(___);}
#if 0
#line 7667
{ 
#line 7668
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7669
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7671
return w.x; 
#line 7672
} 
#endif
#line 7674 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7675
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7680
::exit(___);}
#if 0
#line 7675
{ 
#line 7676
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7677
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7679
return w.x; 
#line 7680
} 
#endif
#line 7682 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DGrad(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7683
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7688
::exit(___);}
#if 0
#line 7683
{ 
#line 7684
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7685
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7687
return make_float1(w.x); 
#line 7688
} 
#endif
#line 7690 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DGrad(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7691
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7696
::exit(___);}
#if 0
#line 7691
{ 
#line 7692
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7693
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7695
return make_float1(w.x); 
#line 7696
} 
#endif
#line 7698 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DGrad(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7699
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7704
::exit(___);}
#if 0
#line 7699
{ 
#line 7700
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7701
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7703
return make_float2(w.x, w.y); 
#line 7704
} 
#endif
#line 7706 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DGrad(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7707
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7712
::exit(___);}
#if 0
#line 7707
{ 
#line 7708
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7709
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7711
return make_float2(w.x, w.y); 
#line 7712
} 
#endif
#line 7714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DGrad(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7715
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7720
::exit(___);}
#if 0
#line 7715
{ 
#line 7716
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7717
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7719
return make_float4(w.x, w.y, w.z, w.w); 
#line 7720
} 
#endif
#line 7722 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DGrad(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7723
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7728
::exit(___);}
#if 0
#line 7723
{ 
#line 7724
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7725
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7727
return make_float4(w.x, w.y, w.z, w.w); 
#line 7728
} 
#endif
#line 7736 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex2DGrad(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7737
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 7737 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 7741 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7744 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 7745
} 
#endif
#line 7747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex2DGrad(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7748
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7752
::exit(___);}
#if 0
#line 7748
{ 
#line 7749
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7751
return (signed char)(v.x); 
#line 7752
} 
#endif
#line 7754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex2DGrad(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7755
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7759
::exit(___);}
#if 0
#line 7755
{ 
#line 7756
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7758
return (unsigned char)(v.x); 
#line 7759
} 
#endif
#line 7761 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex2DGrad(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7762
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7766
::exit(___);}
#if 0
#line 7762
{ 
#line 7763
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7765
return make_char1(v.x); 
#line 7766
} 
#endif
#line 7768 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex2DGrad(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7769
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7773
::exit(___);}
#if 0
#line 7769
{ 
#line 7770
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7772
return make_uchar1(v.x); 
#line 7773
} 
#endif
#line 7775 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex2DGrad(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7776
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7780
::exit(___);}
#if 0
#line 7776
{ 
#line 7777
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7779
return make_char2(v.x, v.y); 
#line 7780
} 
#endif
#line 7782 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex2DGrad(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7783
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7787
::exit(___);}
#if 0
#line 7783
{ 
#line 7784
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7786
return make_uchar2(v.x, v.y); 
#line 7787
} 
#endif
#line 7789 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2DGrad(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7790
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7794
::exit(___);}
#if 0
#line 7790
{ 
#line 7791
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7793
return make_char4(v.x, v.y, v.z, v.w); 
#line 7794
} 
#endif
#line 7796 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2DGrad(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7797
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7801
::exit(___);}
#if 0
#line 7797
{ 
#line 7798
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7800
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 7801
} 
#endif
#line 7809 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex2DGrad(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7810
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7814
::exit(___);}
#if 0
#line 7810
{ 
#line 7811
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7813
return (short)(v.x); 
#line 7814
} 
#endif
#line 7816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex2DGrad(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7817
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7821
::exit(___);}
#if 0
#line 7817
{ 
#line 7818
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7820
return (unsigned short)(v.x); 
#line 7821
} 
#endif
#line 7823 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex2DGrad(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7824
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7828
::exit(___);}
#if 0
#line 7824
{ 
#line 7825
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7827
return make_short1(v.x); 
#line 7828
} 
#endif
#line 7830 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex2DGrad(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7831
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7835
::exit(___);}
#if 0
#line 7831
{ 
#line 7832
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7834
return make_ushort1(v.x); 
#line 7835
} 
#endif
#line 7837 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex2DGrad(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7838
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7842
::exit(___);}
#if 0
#line 7838
{ 
#line 7839
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7841
return make_short2(v.x, v.y); 
#line 7842
} 
#endif
#line 7844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex2DGrad(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7845
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7849
::exit(___);}
#if 0
#line 7845
{ 
#line 7846
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7848
return make_ushort2(v.x, v.y); 
#line 7849
} 
#endif
#line 7851 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2DGrad(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7852
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7856
::exit(___);}
#if 0
#line 7852
{ 
#line 7853
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7855
return make_short4(v.x, v.y, v.z, v.w); 
#line 7856
} 
#endif
#line 7858 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2DGrad(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7859
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7863
::exit(___);}
#if 0
#line 7859
{ 
#line 7860
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7862
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 7863
} 
#endif
#line 7871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex2DGrad(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7872
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7876
::exit(___);}
#if 0
#line 7872
{ 
#line 7873
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7875
return v.x; 
#line 7876
} 
#endif
#line 7878 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex2DGrad(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7879
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7883
::exit(___);}
#if 0
#line 7879
{ 
#line 7880
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7882
return v.x; 
#line 7883
} 
#endif
#line 7885 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex2DGrad(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7886
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7890
::exit(___);}
#if 0
#line 7886
{ 
#line 7887
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7889
return make_int1(v.x); 
#line 7890
} 
#endif
#line 7892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex2DGrad(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7893
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7897
::exit(___);}
#if 0
#line 7893
{ 
#line 7894
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7896
return make_uint1(v.x); 
#line 7897
} 
#endif
#line 7899 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex2DGrad(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7900
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7904
::exit(___);}
#if 0
#line 7900
{ 
#line 7901
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7903
return make_int2(v.x, v.y); 
#line 7904
} 
#endif
#line 7906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex2DGrad(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7907
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7911
::exit(___);}
#if 0
#line 7907
{ 
#line 7908
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7910
return make_uint2(v.x, v.y); 
#line 7911
} 
#endif
#line 7913 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2DGrad(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7914
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7918
::exit(___);}
#if 0
#line 7914
{ 
#line 7915
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7917
return make_int4(v.x, v.y, v.z, v.w); 
#line 7918
} 
#endif
#line 7920 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2DGrad(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7921
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7925
::exit(___);}
#if 0
#line 7921
{ 
#line 7922
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7924
return make_uint4(v.x, v.y, v.z, v.w); 
#line 7925
} 
#endif
#line 7935 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex2DGrad(texture< long, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7936
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7940
::exit(___);}
#if 0
#line 7936
{ 
#line 7937
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7939
return (long)(v.x); 
#line 7940
} 
#endif
#line 7942 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex2DGrad(texture< unsigned long, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7943
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7947
::exit(___);}
#if 0
#line 7943
{ 
#line 7944
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7946
return (unsigned long)(v.x); 
#line 7947
} 
#endif
#line 7949 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex2DGrad(texture< long1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7950
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7954
::exit(___);}
#if 0
#line 7950
{ 
#line 7951
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7953
return make_long1(v.x); 
#line 7954
} 
#endif
#line 7956 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex2DGrad(texture< ulong1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7957
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7961
::exit(___);}
#if 0
#line 7957
{ 
#line 7958
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7960
return make_ulong1(v.x); 
#line 7961
} 
#endif
#line 7963 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex2DGrad(texture< long2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7964
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7968
::exit(___);}
#if 0
#line 7964
{ 
#line 7965
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7967
return make_long2(v.x, v.y); 
#line 7968
} 
#endif
#line 7970 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex2DGrad(texture< ulong2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7971
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7975
::exit(___);}
#if 0
#line 7971
{ 
#line 7972
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7974
return make_ulong2(v.x, v.y); 
#line 7975
} 
#endif
#line 7977 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex2DGrad(texture< long4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7978
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7982
::exit(___);}
#if 0
#line 7978
{ 
#line 7979
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7981
return make_long4(v.x, v.y, v.z, v.w); 
#line 7982
} 
#endif
#line 7984 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex2DGrad(texture< ulong4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7985
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7989
::exit(___);}
#if 0
#line 7985
{ 
#line 7986
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7988
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 7989
} 
#endif
#line 7999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8004
::exit(___);}
#if 0
#line 8000
{ 
#line 8001
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8003
return v.x; 
#line 8004
} 
#endif
#line 8006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DGrad(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8007
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8011
::exit(___);}
#if 0
#line 8007
{ 
#line 8008
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8010
return make_float1(v.x); 
#line 8011
} 
#endif
#line 8013 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DGrad(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8014
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8018
::exit(___);}
#if 0
#line 8014
{ 
#line 8015
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8017
return make_float2(v.x, v.y); 
#line 8018
} 
#endif
#line 8020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DGrad(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8021
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8025
::exit(___);}
#if 0
#line 8021
{ 
#line 8022
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8024
return make_float4(v.x, v.y, v.z, v.w); 
#line 8025
} 
#endif
#line 8033 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8034
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8043 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 8034 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 8038 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8040 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8042
return w.x; 
#line 8043
} 
#endif
#line 8045 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8046
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8051
::exit(___);}
#if 0
#line 8046
{ 
#line 8047
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8048
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8050
return w.x; 
#line 8051
} 
#endif
#line 8053 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8054
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8059
::exit(___);}
#if 0
#line 8054
{ 
#line 8055
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8056
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8058
return w.x; 
#line 8059
} 
#endif
#line 8061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DGrad(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8062
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8067
::exit(___);}
#if 0
#line 8062
{ 
#line 8063
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8064
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8066
return make_float1(w.x); 
#line 8067
} 
#endif
#line 8069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DGrad(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8070
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8075
::exit(___);}
#if 0
#line 8070
{ 
#line 8071
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8072
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8074
return make_float1(w.x); 
#line 8075
} 
#endif
#line 8077 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DGrad(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8078
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8083
::exit(___);}
#if 0
#line 8078
{ 
#line 8079
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8080
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8082
return make_float2(w.x, w.y); 
#line 8083
} 
#endif
#line 8085 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DGrad(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8086
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8091
::exit(___);}
#if 0
#line 8086
{ 
#line 8087
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8088
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8090
return make_float2(w.x, w.y); 
#line 8091
} 
#endif
#line 8093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DGrad(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8094
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8099
::exit(___);}
#if 0
#line 8094
{ 
#line 8095
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8096
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8098
return make_float4(w.x, w.y, w.z, w.w); 
#line 8099
} 
#endif
#line 8101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DGrad(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8102
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8107
::exit(___);}
#if 0
#line 8102
{ 
#line 8103
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8104
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8106
return make_float4(w.x, w.y, w.z, w.w); 
#line 8107
} 
#endif
#line 8115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8116
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8121
::exit(___);}
#if 0
#line 8116
{ 
#line 8117
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8118
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8120
return w.x; 
#line 8121
} 
#endif
#line 8123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8124
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8129
::exit(___);}
#if 0
#line 8124
{ 
#line 8125
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8126
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8128
return w.x; 
#line 8129
} 
#endif
#line 8131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DGrad(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8132
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8137
::exit(___);}
#if 0
#line 8132
{ 
#line 8133
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8134
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8136
return make_float1(w.x); 
#line 8137
} 
#endif
#line 8139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DGrad(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8140
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8145
::exit(___);}
#if 0
#line 8140
{ 
#line 8141
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8142
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8144
return make_float1(w.x); 
#line 8145
} 
#endif
#line 8147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DGrad(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8148
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8153
::exit(___);}
#if 0
#line 8148
{ 
#line 8149
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8150
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8152
return make_float2(w.x, w.y); 
#line 8153
} 
#endif
#line 8155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DGrad(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8156
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8161
::exit(___);}
#if 0
#line 8156
{ 
#line 8157
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8158
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8160
return make_float2(w.x, w.y); 
#line 8161
} 
#endif
#line 8163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DGrad(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8164
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8169
::exit(___);}
#if 0
#line 8164
{ 
#line 8165
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8166
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8168
return make_float4(w.x, w.y, w.z, w.w); 
#line 8169
} 
#endif
#line 8171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DGrad(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8172
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8177
::exit(___);}
#if 0
#line 8172
{ 
#line 8173
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8174
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8176
return make_float4(w.x, w.y, w.z, w.w); 
#line 8177
} 
#endif
#line 8185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex1DLayeredGrad(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8186
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8194 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 8186 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 8190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 8194
} 
#endif
#line 8196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1DLayeredGrad(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8197
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8201
::exit(___);}
#if 0
#line 8197
{ 
#line 8198
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8200
return (signed char)(v.x); 
#line 8201
} 
#endif
#line 8203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8204
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8208
::exit(___);}
#if 0
#line 8204
{ 
#line 8205
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8207
return (unsigned char)(v.x); 
#line 8208
} 
#endif
#line 8210 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8211
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8215
::exit(___);}
#if 0
#line 8211
{ 
#line 8212
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8214
return make_char1(v.x); 
#line 8215
} 
#endif
#line 8217 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8218
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8222
::exit(___);}
#if 0
#line 8218
{ 
#line 8219
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8221
return make_uchar1(v.x); 
#line 8222
} 
#endif
#line 8224 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8225
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8229
::exit(___);}
#if 0
#line 8225
{ 
#line 8226
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8228
return make_char2(v.x, v.y); 
#line 8229
} 
#endif
#line 8231 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8232
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8236
::exit(___);}
#if 0
#line 8232
{ 
#line 8233
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8235
return make_uchar2(v.x, v.y); 
#line 8236
} 
#endif
#line 8238 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8239
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8243
::exit(___);}
#if 0
#line 8239
{ 
#line 8240
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8242
return make_char4(v.x, v.y, v.z, v.w); 
#line 8243
} 
#endif
#line 8245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8246
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8250
::exit(___);}
#if 0
#line 8246
{ 
#line 8247
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8249
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 8250
} 
#endif
#line 8258 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex1DLayeredGrad(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8259
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8263
::exit(___);}
#if 0
#line 8259
{ 
#line 8260
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8262
return (short)(v.x); 
#line 8263
} 
#endif
#line 8265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8266
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8270
::exit(___);}
#if 0
#line 8266
{ 
#line 8267
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8269
return (unsigned short)(v.x); 
#line 8270
} 
#endif
#line 8272 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8273
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8277
::exit(___);}
#if 0
#line 8273
{ 
#line 8274
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8276
return make_short1(v.x); 
#line 8277
} 
#endif
#line 8279 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8280
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8284
::exit(___);}
#if 0
#line 8280
{ 
#line 8281
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8283
return make_ushort1(v.x); 
#line 8284
} 
#endif
#line 8286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8287
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8291
::exit(___);}
#if 0
#line 8287
{ 
#line 8288
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8290
return make_short2(v.x, v.y); 
#line 8291
} 
#endif
#line 8293 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8294
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8298
::exit(___);}
#if 0
#line 8294
{ 
#line 8295
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8297
return make_ushort2(v.x, v.y); 
#line 8298
} 
#endif
#line 8300 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8301
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8305
::exit(___);}
#if 0
#line 8301
{ 
#line 8302
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8304
return make_short4(v.x, v.y, v.z, v.w); 
#line 8305
} 
#endif
#line 8307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8308
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8312
::exit(___);}
#if 0
#line 8308
{ 
#line 8309
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8311
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 8312
} 
#endif
#line 8320 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex1DLayeredGrad(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8321
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8325
::exit(___);}
#if 0
#line 8321
{ 
#line 8322
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8324
return v.x; 
#line 8325
} 
#endif
#line 8327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1DLayeredGrad(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8328
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8332
::exit(___);}
#if 0
#line 8328
{ 
#line 8329
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8331
return v.x; 
#line 8332
} 
#endif
#line 8334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1DLayeredGrad(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8335
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8339
::exit(___);}
#if 0
#line 8335
{ 
#line 8336
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8338
return make_int1(v.x); 
#line 8339
} 
#endif
#line 8341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1DLayeredGrad(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8342
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8346
::exit(___);}
#if 0
#line 8342
{ 
#line 8343
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8345
return make_uint1(v.x); 
#line 8346
} 
#endif
#line 8348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1DLayeredGrad(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8349
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8353
::exit(___);}
#if 0
#line 8349
{ 
#line 8350
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8352
return make_int2(v.x, v.y); 
#line 8353
} 
#endif
#line 8355 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1DLayeredGrad(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8356
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8360
::exit(___);}
#if 0
#line 8356
{ 
#line 8357
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8359
return make_uint2(v.x, v.y); 
#line 8360
} 
#endif
#line 8362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1DLayeredGrad(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8363
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8367
::exit(___);}
#if 0
#line 8363
{ 
#line 8364
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8366
return make_int4(v.x, v.y, v.z, v.w); 
#line 8367
} 
#endif
#line 8369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1DLayeredGrad(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8370
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8374
::exit(___);}
#if 0
#line 8370
{ 
#line 8371
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8373
return make_uint4(v.x, v.y, v.z, v.w); 
#line 8374
} 
#endif
#line 8384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex1DLayeredGrad(texture< long, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8385
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8389
::exit(___);}
#if 0
#line 8385
{ 
#line 8386
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8388
return (long)(v.x); 
#line 8389
} 
#endif
#line 8391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1DLayeredGrad(texture< unsigned long, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8392
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8396
::exit(___);}
#if 0
#line 8392
{ 
#line 8393
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8395
return (unsigned long)(v.x); 
#line 8396
} 
#endif
#line 8398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1DLayeredGrad(texture< long1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8399
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8403
::exit(___);}
#if 0
#line 8399
{ 
#line 8400
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8402
return make_long1(v.x); 
#line 8403
} 
#endif
#line 8405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1DLayeredGrad(texture< ulong1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8406
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8410
::exit(___);}
#if 0
#line 8406
{ 
#line 8407
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8409
return make_ulong1(v.x); 
#line 8410
} 
#endif
#line 8412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1DLayeredGrad(texture< long2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8413
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8417
::exit(___);}
#if 0
#line 8413
{ 
#line 8414
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8416
return make_long2(v.x, v.y); 
#line 8417
} 
#endif
#line 8419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1DLayeredGrad(texture< ulong2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8420
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8424
::exit(___);}
#if 0
#line 8420
{ 
#line 8421
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8423
return make_ulong2(v.x, v.y); 
#line 8424
} 
#endif
#line 8426 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1DLayeredGrad(texture< long4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8427
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8431
::exit(___);}
#if 0
#line 8427
{ 
#line 8428
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8430
return make_long4(v.x, v.y, v.z, v.w); 
#line 8431
} 
#endif
#line 8433 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1DLayeredGrad(texture< ulong4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8434
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8438
::exit(___);}
#if 0
#line 8434
{ 
#line 8435
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8437
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 8438
} 
#endif
#line 8448 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8449
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8453
::exit(___);}
#if 0
#line 8449
{ 
#line 8450
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8452
return v.x; 
#line 8453
} 
#endif
#line 8455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredGrad(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8456
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8460
::exit(___);}
#if 0
#line 8456
{ 
#line 8457
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8459
return make_float1(v.x); 
#line 8460
} 
#endif
#line 8462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredGrad(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8463
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8467
::exit(___);}
#if 0
#line 8463
{ 
#line 8464
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8466
return make_float2(v.x, v.y); 
#line 8467
} 
#endif
#line 8469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredGrad(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8470
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8474
::exit(___);}
#if 0
#line 8470
{ 
#line 8471
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8473
return make_float4(v.x, v.y, v.z, v.w); 
#line 8474
} 
#endif
#line 8482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8483
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8492 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 8483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 8487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8489 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8491
return w.x; 
#line 8492
} 
#endif
#line 8494 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8495
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8500
::exit(___);}
#if 0
#line 8495
{ 
#line 8496
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8497
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8499
return w.x; 
#line 8500
} 
#endif
#line 8502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8503
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8508
::exit(___);}
#if 0
#line 8503
{ 
#line 8504
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8505
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8507
return w.x; 
#line 8508
} 
#endif
#line 8510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8511
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8516
::exit(___);}
#if 0
#line 8511
{ 
#line 8512
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8513
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8515
return make_float1(w.x); 
#line 8516
} 
#endif
#line 8518 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8519
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8524
::exit(___);}
#if 0
#line 8519
{ 
#line 8520
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8521
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8523
return make_float1(w.x); 
#line 8524
} 
#endif
#line 8526 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8527
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8532
::exit(___);}
#if 0
#line 8527
{ 
#line 8528
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8529
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8531
return make_float2(w.x, w.y); 
#line 8532
} 
#endif
#line 8534 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8535
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8540
::exit(___);}
#if 0
#line 8535
{ 
#line 8536
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8537
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8539
return make_float2(w.x, w.y); 
#line 8540
} 
#endif
#line 8542 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8543
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8548
::exit(___);}
#if 0
#line 8543
{ 
#line 8544
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8545
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8547
return make_float4(w.x, w.y, w.z, w.w); 
#line 8548
} 
#endif
#line 8550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8551
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8556
::exit(___);}
#if 0
#line 8551
{ 
#line 8552
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8553
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8555
return make_float4(w.x, w.y, w.z, w.w); 
#line 8556
} 
#endif
#line 8564 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8565
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8570
::exit(___);}
#if 0
#line 8565
{ 
#line 8566
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8567
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8569
return w.x; 
#line 8570
} 
#endif
#line 8572 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8573
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8578
::exit(___);}
#if 0
#line 8573
{ 
#line 8574
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8575
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8577
return w.x; 
#line 8578
} 
#endif
#line 8580 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8581
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8586
::exit(___);}
#if 0
#line 8581
{ 
#line 8582
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8583
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8585
return make_float1(w.x); 
#line 8586
} 
#endif
#line 8588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8589
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8594
::exit(___);}
#if 0
#line 8589
{ 
#line 8590
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8591
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8593
return make_float1(w.x); 
#line 8594
} 
#endif
#line 8596 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8597
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8602
::exit(___);}
#if 0
#line 8597
{ 
#line 8598
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8599
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8601
return make_float2(w.x, w.y); 
#line 8602
} 
#endif
#line 8604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8605
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8610
::exit(___);}
#if 0
#line 8605
{ 
#line 8606
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8607
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8609
return make_float2(w.x, w.y); 
#line 8610
} 
#endif
#line 8612 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8613
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8618
::exit(___);}
#if 0
#line 8613
{ 
#line 8614
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8615
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8617
return make_float4(w.x, w.y, w.z, w.w); 
#line 8618
} 
#endif
#line 8620 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8621
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8626
::exit(___);}
#if 0
#line 8621
{ 
#line 8622
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8623
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8625
return make_float4(w.x, w.y, w.z, w.w); 
#line 8626
} 
#endif
#line 8634 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex2DLayeredGrad(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8635
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8643 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 8635 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 8639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8642 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 8643
} 
#endif
#line 8645 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex2DLayeredGrad(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8646
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8650
::exit(___);}
#if 0
#line 8646
{ 
#line 8647
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8649
return (signed char)(v.x); 
#line 8650
} 
#endif
#line 8652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8653
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8657
::exit(___);}
#if 0
#line 8653
{ 
#line 8654
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8656
return (unsigned char)(v.x); 
#line 8657
} 
#endif
#line 8659 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8660
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8664
::exit(___);}
#if 0
#line 8660
{ 
#line 8661
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8663
return make_char1(v.x); 
#line 8664
} 
#endif
#line 8666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8667
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8671
::exit(___);}
#if 0
#line 8667
{ 
#line 8668
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8670
return make_uchar1(v.x); 
#line 8671
} 
#endif
#line 8673 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8674
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8678
::exit(___);}
#if 0
#line 8674
{ 
#line 8675
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8677
return make_char2(v.x, v.y); 
#line 8678
} 
#endif
#line 8680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8685
::exit(___);}
#if 0
#line 8681
{ 
#line 8682
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8684
return make_uchar2(v.x, v.y); 
#line 8685
} 
#endif
#line 8687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8688
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8692
::exit(___);}
#if 0
#line 8688
{ 
#line 8689
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8691
return make_char4(v.x, v.y, v.z, v.w); 
#line 8692
} 
#endif
#line 8694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8695
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8699
::exit(___);}
#if 0
#line 8695
{ 
#line 8696
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8698
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 8699
} 
#endif
#line 8707 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex2DLayeredGrad(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8708
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8712
::exit(___);}
#if 0
#line 8708
{ 
#line 8709
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8711
return (short)(v.x); 
#line 8712
} 
#endif
#line 8714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8715
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8719
::exit(___);}
#if 0
#line 8715
{ 
#line 8716
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8718
return (unsigned short)(v.x); 
#line 8719
} 
#endif
#line 8721 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8722
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8726
::exit(___);}
#if 0
#line 8722
{ 
#line 8723
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8725
return make_short1(v.x); 
#line 8726
} 
#endif
#line 8728 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8729
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8733
::exit(___);}
#if 0
#line 8729
{ 
#line 8730
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8732
return make_ushort1(v.x); 
#line 8733
} 
#endif
#line 8735 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8736
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8740
::exit(___);}
#if 0
#line 8736
{ 
#line 8737
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8739
return make_short2(v.x, v.y); 
#line 8740
} 
#endif
#line 8742 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8743
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8747
::exit(___);}
#if 0
#line 8743
{ 
#line 8744
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8746
return make_ushort2(v.x, v.y); 
#line 8747
} 
#endif
#line 8749 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8750
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8754
::exit(___);}
#if 0
#line 8750
{ 
#line 8751
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8753
return make_short4(v.x, v.y, v.z, v.w); 
#line 8754
} 
#endif
#line 8756 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8757
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8761
::exit(___);}
#if 0
#line 8757
{ 
#line 8758
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8760
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 8761
} 
#endif
#line 8769 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex2DLayeredGrad(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8770
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8774
::exit(___);}
#if 0
#line 8770
{ 
#line 8771
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8773
return v.x; 
#line 8774
} 
#endif
#line 8776 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex2DLayeredGrad(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8777
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8781
::exit(___);}
#if 0
#line 8777
{ 
#line 8778
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8780
return v.x; 
#line 8781
} 
#endif
#line 8783 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex2DLayeredGrad(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8784
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8788
::exit(___);}
#if 0
#line 8784
{ 
#line 8785
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8787
return make_int1(v.x); 
#line 8788
} 
#endif
#line 8790 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex2DLayeredGrad(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8791
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8795
::exit(___);}
#if 0
#line 8791
{ 
#line 8792
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8794
return make_uint1(v.x); 
#line 8795
} 
#endif
#line 8797 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex2DLayeredGrad(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8798
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8802
::exit(___);}
#if 0
#line 8798
{ 
#line 8799
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8801
return make_int2(v.x, v.y); 
#line 8802
} 
#endif
#line 8804 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex2DLayeredGrad(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8805
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8809
::exit(___);}
#if 0
#line 8805
{ 
#line 8806
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8808
return make_uint2(v.x, v.y); 
#line 8809
} 
#endif
#line 8811 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2DLayeredGrad(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8812
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8816
::exit(___);}
#if 0
#line 8812
{ 
#line 8813
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8815
return make_int4(v.x, v.y, v.z, v.w); 
#line 8816
} 
#endif
#line 8818 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2DLayeredGrad(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8819
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8823
::exit(___);}
#if 0
#line 8819
{ 
#line 8820
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8822
return make_uint4(v.x, v.y, v.z, v.w); 
#line 8823
} 
#endif
#line 8833 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex2DLayeredGrad(texture< long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8834
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8838
::exit(___);}
#if 0
#line 8834
{ 
#line 8835
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8837
return (long)(v.x); 
#line 8838
} 
#endif
#line 8840 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex2DLayeredGrad(texture< unsigned long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8841
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8845
::exit(___);}
#if 0
#line 8841
{ 
#line 8842
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8844
return (unsigned long)(v.x); 
#line 8845
} 
#endif
#line 8847 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex2DLayeredGrad(texture< long1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8848
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8852
::exit(___);}
#if 0
#line 8848
{ 
#line 8849
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8851
return make_long1(v.x); 
#line 8852
} 
#endif
#line 8854 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex2DLayeredGrad(texture< ulong1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8855
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8859
::exit(___);}
#if 0
#line 8855
{ 
#line 8856
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8858
return make_ulong1(v.x); 
#line 8859
} 
#endif
#line 8861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex2DLayeredGrad(texture< long2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8862
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8866
::exit(___);}
#if 0
#line 8862
{ 
#line 8863
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8865
return make_long2(v.x, v.y); 
#line 8866
} 
#endif
#line 8868 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex2DLayeredGrad(texture< ulong2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8869
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8873
::exit(___);}
#if 0
#line 8869
{ 
#line 8870
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8872
return make_ulong2(v.x, v.y); 
#line 8873
} 
#endif
#line 8875 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex2DLayeredGrad(texture< long4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8876
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8880
::exit(___);}
#if 0
#line 8876
{ 
#line 8877
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8879
return make_long4(v.x, v.y, v.z, v.w); 
#line 8880
} 
#endif
#line 8882 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex2DLayeredGrad(texture< ulong4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8883
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8887
::exit(___);}
#if 0
#line 8883
{ 
#line 8884
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8886
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 8887
} 
#endif
#line 8897 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8902
::exit(___);}
#if 0
#line 8898
{ 
#line 8899
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8901
return v.x; 
#line 8902
} 
#endif
#line 8904 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredGrad(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8909
::exit(___);}
#if 0
#line 8905
{ 
#line 8906
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8908
return make_float1(v.x); 
#line 8909
} 
#endif
#line 8911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredGrad(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8912
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8916
::exit(___);}
#if 0
#line 8912
{ 
#line 8913
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8915
return make_float2(v.x, v.y); 
#line 8916
} 
#endif
#line 8918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredGrad(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8919
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8923
::exit(___);}
#if 0
#line 8919
{ 
#line 8920
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8922
return make_float4(v.x, v.y, v.z, v.w); 
#line 8923
} 
#endif
#line 8931 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8932
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8941 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 8932 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 8936 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8938 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8940
return w.x; 
#line 8941
} 
#endif
#line 8943 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8944
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8949
::exit(___);}
#if 0
#line 8944
{ 
#line 8945
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8946
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8948
return w.x; 
#line 8949
} 
#endif
#line 8951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8952
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8957
::exit(___);}
#if 0
#line 8952
{ 
#line 8953
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8954
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8956
return w.x; 
#line 8957
} 
#endif
#line 8959 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8960
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8965
::exit(___);}
#if 0
#line 8960
{ 
#line 8961
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8962
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8964
return make_float1(w.x); 
#line 8965
} 
#endif
#line 8967 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8968
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8973
::exit(___);}
#if 0
#line 8968
{ 
#line 8969
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8970
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8972
return make_float1(w.x); 
#line 8973
} 
#endif
#line 8975 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8976
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8981
::exit(___);}
#if 0
#line 8976
{ 
#line 8977
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8978
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8980
return make_float2(w.x, w.y); 
#line 8981
} 
#endif
#line 8983 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8984
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8989
::exit(___);}
#if 0
#line 8984
{ 
#line 8985
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8986
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8988
return make_float2(w.x, w.y); 
#line 8989
} 
#endif
#line 8991 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8992
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8997
::exit(___);}
#if 0
#line 8992
{ 
#line 8993
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8994
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8996
return make_float4(w.x, w.y, w.z, w.w); 
#line 8997
} 
#endif
#line 8999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9005
::exit(___);}
#if 0
#line 9000
{ 
#line 9001
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9002
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9004
return make_float4(w.x, w.y, w.z, w.w); 
#line 9005
} 
#endif
#line 9013 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9014
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9019
::exit(___);}
#if 0
#line 9014
{ 
#line 9015
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9016
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9018
return w.x; 
#line 9019
} 
#endif
#line 9021 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9022
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9027
::exit(___);}
#if 0
#line 9022
{ 
#line 9023
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9024
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9026
return w.x; 
#line 9027
} 
#endif
#line 9029 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9030
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9035
::exit(___);}
#if 0
#line 9030
{ 
#line 9031
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9032
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9034
return make_float1(w.x); 
#line 9035
} 
#endif
#line 9037 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9038
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9043
::exit(___);}
#if 0
#line 9038
{ 
#line 9039
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9040
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9042
return make_float1(w.x); 
#line 9043
} 
#endif
#line 9045 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9046
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9051
::exit(___);}
#if 0
#line 9046
{ 
#line 9047
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9048
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9050
return make_float2(w.x, w.y); 
#line 9051
} 
#endif
#line 9053 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9054
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9059
::exit(___);}
#if 0
#line 9054
{ 
#line 9055
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9056
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9058
return make_float2(w.x, w.y); 
#line 9059
} 
#endif
#line 9061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9062
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9067
::exit(___);}
#if 0
#line 9062
{ 
#line 9063
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9064
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9066
return make_float4(w.x, w.y, w.z, w.w); 
#line 9067
} 
#endif
#line 9069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9070
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9075
::exit(___);}
#if 0
#line 9070
{ 
#line 9071
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9072
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9074
return make_float4(w.x, w.y, w.z, w.w); 
#line 9075
} 
#endif
#line 9083 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char tex3DGrad(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9084
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9092 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 9084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 9088 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9091 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 9092
} 
#endif
#line 9094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline signed char tex3DGrad(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9099
::exit(___);}
#if 0
#line 9095
{ 
#line 9096
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9098
return (signed char)(v.x); 
#line 9099
} 
#endif
#line 9101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex3DGrad(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9102
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9106
::exit(___);}
#if 0
#line 9102
{ 
#line 9103
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9105
return (unsigned char)(v.x); 
#line 9106
} 
#endif
#line 9108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char1 tex3DGrad(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9109
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9113
::exit(___);}
#if 0
#line 9109
{ 
#line 9110
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9112
return make_char1(v.x); 
#line 9113
} 
#endif
#line 9115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex3DGrad(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9116
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9120
::exit(___);}
#if 0
#line 9116
{ 
#line 9117
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9119
return make_uchar1(v.x); 
#line 9120
} 
#endif
#line 9122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char2 tex3DGrad(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9123
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9127
::exit(___);}
#if 0
#line 9123
{ 
#line 9124
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9126
return make_char2(v.x, v.y); 
#line 9127
} 
#endif
#line 9129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex3DGrad(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9130
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9134
::exit(___);}
#if 0
#line 9130
{ 
#line 9131
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9133
return make_uchar2(v.x, v.y); 
#line 9134
} 
#endif
#line 9136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline char4 tex3DGrad(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9137
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9141
::exit(___);}
#if 0
#line 9137
{ 
#line 9138
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9140
return make_char4(v.x, v.y, v.z, v.w); 
#line 9141
} 
#endif
#line 9143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex3DGrad(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9144
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9148
::exit(___);}
#if 0
#line 9144
{ 
#line 9145
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9147
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 9148
} 
#endif
#line 9156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short tex3DGrad(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9157
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9161
::exit(___);}
#if 0
#line 9157
{ 
#line 9158
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9160
return (short)(v.x); 
#line 9161
} 
#endif
#line 9163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex3DGrad(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9164
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9168
::exit(___);}
#if 0
#line 9164
{ 
#line 9165
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9167
return (unsigned short)(v.x); 
#line 9168
} 
#endif
#line 9170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short1 tex3DGrad(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9171
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9175
::exit(___);}
#if 0
#line 9171
{ 
#line 9172
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9174
return make_short1(v.x); 
#line 9175
} 
#endif
#line 9177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex3DGrad(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9178
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9182
::exit(___);}
#if 0
#line 9178
{ 
#line 9179
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9181
return make_ushort1(v.x); 
#line 9182
} 
#endif
#line 9184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short2 tex3DGrad(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9185
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9189
::exit(___);}
#if 0
#line 9185
{ 
#line 9186
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9188
return make_short2(v.x, v.y); 
#line 9189
} 
#endif
#line 9191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex3DGrad(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9192
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9196
::exit(___);}
#if 0
#line 9192
{ 
#line 9193
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9195
return make_ushort2(v.x, v.y); 
#line 9196
} 
#endif
#line 9198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline short4 tex3DGrad(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9199
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9203
::exit(___);}
#if 0
#line 9199
{ 
#line 9200
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9202
return make_short4(v.x, v.y, v.z, v.w); 
#line 9203
} 
#endif
#line 9205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex3DGrad(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9206
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9210
::exit(___);}
#if 0
#line 9206
{ 
#line 9207
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9209
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 9210
} 
#endif
#line 9218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int tex3DGrad(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9219
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9223
::exit(___);}
#if 0
#line 9219
{ 
#line 9220
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9222
return v.x; 
#line 9223
} 
#endif
#line 9225 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex3DGrad(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9226
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9230
::exit(___);}
#if 0
#line 9226
{ 
#line 9227
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9229
return v.x; 
#line 9230
} 
#endif
#line 9232 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int1 tex3DGrad(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9233
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9237
::exit(___);}
#if 0
#line 9233
{ 
#line 9234
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9236
return make_int1(v.x); 
#line 9237
} 
#endif
#line 9239 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex3DGrad(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9240
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9244
::exit(___);}
#if 0
#line 9240
{ 
#line 9241
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9243
return make_uint1(v.x); 
#line 9244
} 
#endif
#line 9246 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int2 tex3DGrad(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9247
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9251
::exit(___);}
#if 0
#line 9247
{ 
#line 9248
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9250
return make_int2(v.x, v.y); 
#line 9251
} 
#endif
#line 9253 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex3DGrad(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9254
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9258
::exit(___);}
#if 0
#line 9254
{ 
#line 9255
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9257
return make_uint2(v.x, v.y); 
#line 9258
} 
#endif
#line 9260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline int4 tex3DGrad(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9261
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9265
::exit(___);}
#if 0
#line 9261
{ 
#line 9262
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9264
return make_int4(v.x, v.y, v.z, v.w); 
#line 9265
} 
#endif
#line 9267 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex3DGrad(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9268
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9272
::exit(___);}
#if 0
#line 9268
{ 
#line 9269
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9271
return make_uint4(v.x, v.y, v.z, v.w); 
#line 9272
} 
#endif
#line 9282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long tex3DGrad(texture< long, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9283
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9287
::exit(___);}
#if 0
#line 9283
{ 
#line 9284
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9286
return (long)(v.x); 
#line 9287
} 
#endif
#line 9289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex3DGrad(texture< unsigned long, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9290
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9294
::exit(___);}
#if 0
#line 9290
{ 
#line 9291
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9293
return (unsigned long)(v.x); 
#line 9294
} 
#endif
#line 9296 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long1 tex3DGrad(texture< long1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9297
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9301
::exit(___);}
#if 0
#line 9297
{ 
#line 9298
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9300
return make_long1(v.x); 
#line 9301
} 
#endif
#line 9303 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex3DGrad(texture< ulong1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9304
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9308
::exit(___);}
#if 0
#line 9304
{ 
#line 9305
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9307
return make_ulong1(v.x); 
#line 9308
} 
#endif
#line 9310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long2 tex3DGrad(texture< long2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9311
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9315
::exit(___);}
#if 0
#line 9311
{ 
#line 9312
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9314
return make_long2(v.x, v.y); 
#line 9315
} 
#endif
#line 9317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex3DGrad(texture< ulong2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9318
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9322
::exit(___);}
#if 0
#line 9318
{ 
#line 9319
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9321
return make_ulong2(v.x, v.y); 
#line 9322
} 
#endif
#line 9324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline long4 tex3DGrad(texture< long4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9325
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9329
::exit(___);}
#if 0
#line 9325
{ 
#line 9326
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9328
return make_long4(v.x, v.y, v.z, v.w); 
#line 9329
} 
#endif
#line 9331 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex3DGrad(texture< ulong4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9332
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9336
::exit(___);}
#if 0
#line 9332
{ 
#line 9333
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9335
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 9336
} 
#endif
#line 9346 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9347
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9351
::exit(___);}
#if 0
#line 9347
{ 
#line 9348
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9350
return v.x; 
#line 9351
} 
#endif
#line 9353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DGrad(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9354
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9358
::exit(___);}
#if 0
#line 9354
{ 
#line 9355
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9357
return make_float1(v.x); 
#line 9358
} 
#endif
#line 9360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DGrad(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9361
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9365
::exit(___);}
#if 0
#line 9361
{ 
#line 9362
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9364
return make_float2(v.x, v.y); 
#line 9365
} 
#endif
#line 9367 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DGrad(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9368
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9372
::exit(___);}
#if 0
#line 9368
{ 
#line 9369
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9371
return make_float4(v.x, v.y, v.z, v.w); 
#line 9372
} 
#endif
#line 9380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9381
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9390 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 9381 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
{ 
#line 9385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9389
return w.x; 
#line 9390
} 
#endif
#line 9392 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9393
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9398
::exit(___);}
#if 0
#line 9393
{ 
#line 9394
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9395
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9397
return w.x; 
#line 9398
} 
#endif
#line 9400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9401
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9406
::exit(___);}
#if 0
#line 9401
{ 
#line 9402
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9403
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9405
return w.x; 
#line 9406
} 
#endif
#line 9408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DGrad(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9409
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9414
::exit(___);}
#if 0
#line 9409
{ 
#line 9410
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9411
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9413
return make_float1(w.x); 
#line 9414
} 
#endif
#line 9416 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DGrad(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9417
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9422
::exit(___);}
#if 0
#line 9417
{ 
#line 9418
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9419
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9421
return make_float1(w.x); 
#line 9422
} 
#endif
#line 9424 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DGrad(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9425
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9430
::exit(___);}
#if 0
#line 9425
{ 
#line 9426
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9427
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9429
return make_float2(w.x, w.y); 
#line 9430
} 
#endif
#line 9432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DGrad(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9433
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9438
::exit(___);}
#if 0
#line 9433
{ 
#line 9434
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9435
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9437
return make_float2(w.x, w.y); 
#line 9438
} 
#endif
#line 9440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DGrad(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9441
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9446
::exit(___);}
#if 0
#line 9441
{ 
#line 9442
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9443
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9445
return make_float4(w.x, w.y, w.z, w.w); 
#line 9446
} 
#endif
#line 9448 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DGrad(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9449
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9454
::exit(___);}
#if 0
#line 9449
{ 
#line 9450
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9451
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9453
return make_float4(w.x, w.y, w.z, w.w); 
#line 9454
} 
#endif
#line 9462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9463
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9468
::exit(___);}
#if 0
#line 9463
{ 
#line 9464
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9465
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9467
return w.x; 
#line 9468
} 
#endif
#line 9470 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9471
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9476
::exit(___);}
#if 0
#line 9471
{ 
#line 9472
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9473
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9475
return w.x; 
#line 9476
} 
#endif
#line 9478 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DGrad(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9479
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9484
::exit(___);}
#if 0
#line 9479
{ 
#line 9480
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9481
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9483
return make_float1(w.x); 
#line 9484
} 
#endif
#line 9486 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DGrad(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9487
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9492
::exit(___);}
#if 0
#line 9487
{ 
#line 9488
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9489
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9491
return make_float1(w.x); 
#line 9492
} 
#endif
#line 9494 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DGrad(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9495
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9500
::exit(___);}
#if 0
#line 9495
{ 
#line 9496
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9497
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9499
return make_float2(w.x, w.y); 
#line 9500
} 
#endif
#line 9502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DGrad(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9503
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9508
::exit(___);}
#if 0
#line 9503
{ 
#line 9504
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9505
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9507
return make_float2(w.x, w.y); 
#line 9508
} 
#endif
#line 9510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DGrad(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9511
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9516
::exit(___);}
#if 0
#line 9511
{ 
#line 9512
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9513
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9515
return make_float4(w.x, w.y, w.z, w.w); 
#line 9516
} 
#endif
#line 9518 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DGrad(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9519
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9524
::exit(___);}
#if 0
#line 9519
{ 
#line 9520
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9521
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9523
return make_float4(w.x, w.y, w.z, w.w); 
#line 9524
} 
#endif
#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(char *retVal, cudaTextureObject_t texObject, int x) 
#line 71
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 80 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 71 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 76 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 77
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
#line 79 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 80
} 
#endif
#line 81 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(signed char *retVal, cudaTextureObject_t texObject, int x) 
#line 82
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 86
::exit(___);}
#if 0
#line 82
{ 
#line 83
int4 tmp; 
#line 84
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((signed char)(tmp.x)); 
#line 86
} 
#endif
#line 88 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(char1 *retVal, cudaTextureObject_t texObject, int x) 
#line 89
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 93
::exit(___);}
#if 0
#line 89
{ 
#line 90
int4 tmp; 
#line 91
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_char1(tmp.x); 
#line 93
} 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(char2 *retVal, cudaTextureObject_t texObject, int x) 
#line 96
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 100
::exit(___);}
#if 0
#line 96
{ 
#line 97
int4 tmp; 
#line 98
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 100
} 
#endif
#line 102 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(char4 *retVal, cudaTextureObject_t texObject, int x) 
#line 103
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 107
::exit(___);}
#if 0
#line 103
{ 
#line 104
int4 tmp; 
#line 105
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 107
} 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(unsigned char *retVal, cudaTextureObject_t texObject, int x) 
#line 110
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 114
::exit(___);}
#if 0
#line 110
{ 
#line 111
uint4 tmp; 
#line 112
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 114
} 
#endif
#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(uchar1 *retVal, cudaTextureObject_t texObject, int x) 
#line 117
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 121
::exit(___);}
#if 0
#line 117
{ 
#line 118
uint4 tmp; 
#line 119
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uchar1(tmp.x); 
#line 121
} 
#endif
#line 123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(uchar2 *retVal, cudaTextureObject_t texObject, int x) 
#line 124
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 128
::exit(___);}
#if 0
#line 124
{ 
#line 125
uint4 tmp; 
#line 126
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 128
} 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(uchar4 *retVal, cudaTextureObject_t texObject, int x) 
#line 131
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 135
::exit(___);}
#if 0
#line 131
{ 
#line 132
uint4 tmp; 
#line 133
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 135
} 
#endif
#line 143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(short *retVal, cudaTextureObject_t texObject, int x) 
#line 144
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 148
::exit(___);}
#if 0
#line 144
{ 
#line 145
int4 tmp; 
#line 146
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((short)(tmp.x)); 
#line 148
} 
#endif
#line 150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(short1 *retVal, cudaTextureObject_t texObject, int x) 
#line 151
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 155
::exit(___);}
#if 0
#line 151
{ 
#line 152
int4 tmp; 
#line 153
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_short1(tmp.x); 
#line 155
} 
#endif
#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(short2 *retVal, cudaTextureObject_t texObject, int x) 
#line 158
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 162
::exit(___);}
#if 0
#line 158
{ 
#line 159
int4 tmp; 
#line 160
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 162
} 
#endif
#line 164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(short4 *retVal, cudaTextureObject_t texObject, int x) 
#line 165
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 169
::exit(___);}
#if 0
#line 165
{ 
#line 166
int4 tmp; 
#line 167
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 169
} 
#endif
#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(unsigned short *retVal, cudaTextureObject_t texObject, int x) 
#line 172
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 176
::exit(___);}
#if 0
#line 172
{ 
#line 173
uint4 tmp; 
#line 174
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 176
} 
#endif
#line 178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(ushort1 *retVal, cudaTextureObject_t texObject, int x) 
#line 179
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 183
::exit(___);}
#if 0
#line 179
{ 
#line 180
uint4 tmp; 
#line 181
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ushort1(tmp.x); 
#line 183
} 
#endif
#line 185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(ushort2 *retVal, cudaTextureObject_t texObject, int x) 
#line 186
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 190
::exit(___);}
#if 0
#line 186
{ 
#line 187
uint4 tmp; 
#line 188
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 190
} 
#endif
#line 192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(ushort4 *retVal, cudaTextureObject_t texObject, int x) 
#line 193
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 197
::exit(___);}
#if 0
#line 193
{ 
#line 194
uint4 tmp; 
#line 195
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 197
} 
#endif
#line 205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(int *retVal, cudaTextureObject_t texObject, int x) 
#line 206
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 210
::exit(___);}
#if 0
#line 206
{ 
#line 207
int4 tmp; 
#line 208
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = (tmp.x); 
#line 210
} 
#endif
#line 212 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(int1 *retVal, cudaTextureObject_t texObject, int x) 
#line 213
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 217
::exit(___);}
#if 0
#line 213
{ 
#line 214
int4 tmp; 
#line 215
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_int1(tmp.x); 
#line 217
} 
#endif
#line 219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(int2 *retVal, cudaTextureObject_t texObject, int x) 
#line 220
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 224
::exit(___);}
#if 0
#line 220
{ 
#line 221
int4 tmp; 
#line 222
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 224
} 
#endif
#line 226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(int4 *retVal, cudaTextureObject_t texObject, int x) 
#line 227
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 231
::exit(___);}
#if 0
#line 227
{ 
#line 228
int4 tmp; 
#line 229
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 231
} 
#endif
#line 233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(unsigned *retVal, cudaTextureObject_t texObject, int x) 
#line 234
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 238
::exit(___);}
#if 0
#line 234
{ 
#line 235
uint4 tmp; 
#line 236
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = (tmp.x); 
#line 238
} 
#endif
#line 240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(uint1 *retVal, cudaTextureObject_t texObject, int x) 
#line 241
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 245
::exit(___);}
#if 0
#line 241
{ 
#line 242
uint4 tmp; 
#line 243
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uint1(tmp.x); 
#line 245
} 
#endif
#line 247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(uint2 *retVal, cudaTextureObject_t texObject, int x) 
#line 248
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 252
::exit(___);}
#if 0
#line 248
{ 
#line 249
uint4 tmp; 
#line 250
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 252
} 
#endif
#line 254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(uint4 *retVal, cudaTextureObject_t texObject, int x) 
#line 255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 259
::exit(___);}
#if 0
#line 255
{ 
#line 256
uint4 tmp; 
#line 257
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 259
} 
#endif
#line 269 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(long *retVal, cudaTextureObject_t texObject, int x) 
#line 270
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 274
::exit(___);}
#if 0
#line 270
{ 
#line 271
int4 tmp; 
#line 272
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((long)(tmp.x)); 
#line 274
} 
#endif
#line 276 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(long1 *retVal, cudaTextureObject_t texObject, int x) 
#line 277
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 281
::exit(___);}
#if 0
#line 277
{ 
#line 278
int4 tmp; 
#line 279
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_long1(tmp.x); 
#line 281
} 
#endif
#line 283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(long2 *retVal, cudaTextureObject_t texObject, int x) 
#line 284
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 288
::exit(___);}
#if 0
#line 284
{ 
#line 285
int4 tmp; 
#line 286
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 288
} 
#endif
#line 290 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(long4 *retVal, cudaTextureObject_t texObject, int x) 
#line 291
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 295
::exit(___);}
#if 0
#line 291
{ 
#line 292
int4 tmp; 
#line 293
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 295
} 
#endif
#line 297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(unsigned long *retVal, cudaTextureObject_t texObject, int x) 
#line 298
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 302
::exit(___);}
#if 0
#line 298
{ 
#line 299
uint4 tmp; 
#line 300
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 302
} 
#endif
#line 304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(ulong1 *retVal, cudaTextureObject_t texObject, int x) 
#line 305
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 309
::exit(___);}
#if 0
#line 305
{ 
#line 306
uint4 tmp; 
#line 307
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ulong1(tmp.x); 
#line 309
} 
#endif
#line 311 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(ulong2 *retVal, cudaTextureObject_t texObject, int x) 
#line 312
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 316
::exit(___);}
#if 0
#line 312
{ 
#line 313
uint4 tmp; 
#line 314
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 316
} 
#endif
#line 318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(ulong4 *retVal, cudaTextureObject_t texObject, int x) 
#line 319
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 323
::exit(___);}
#if 0
#line 319
{ 
#line 320
uint4 tmp; 
#line 321
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 323
} 
#endif
#line 334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(float *retVal, cudaTextureObject_t texObject, int x) 
#line 335
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 339
::exit(___);}
#if 0
#line 335
{ 
#line 336
float4 tmp; 
#line 337
__asm tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = (tmp.x); 
#line 339
} 
#endif
#line 341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(float1 *retVal, cudaTextureObject_t texObject, int x) 
#line 342
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 346
::exit(___);}
#if 0
#line 342
{ 
#line 343
float4 tmp; 
#line 344
__asm tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_float1(tmp.x); 
#line 346
} 
#endif
#line 348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(float2 *retVal, cudaTextureObject_t texObject, int x) 
#line 349
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 353
::exit(___);}
#if 0
#line 349
{ 
#line 350
float4 tmp; 
#line 351
__asm tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 353
} 
#endif
#line 355 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(float4 *retVal, cudaTextureObject_t texObject, int x) 
#line 356
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 360
::exit(___);}
#if 0
#line 356
{ 
#line 357
float4 tmp; 
#line 358
__asm tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 360
} 
#endif
#line 368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 369
tex1Dfetch(::cudaTextureObject_t texObject, int x) 
#line 370
{int volatile ___ = 1;(void)texObject;(void)x;
#line 374
::exit(___);}
#if 0
#line 370
{ 
#line 371
T ret; 
#line 372
tex1Dfetch(&ret, texObject, x); 
#line 373
return ret; 
#line 374
} 
#endif
#line 382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(char *retVal, cudaTextureObject_t texObject, float x) 
#line 383
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 392 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 389
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
#line 391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 392
} 
#endif
#line 393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(signed char *retVal, cudaTextureObject_t texObject, float x) 
#line 394
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 398
::exit(___);}
#if 0
#line 394
{ 
#line 395
int4 tmp; 
#line 396
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((signed char)(tmp.x)); 
#line 398
} 
#endif
#line 400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(char1 *retVal, cudaTextureObject_t texObject, float x) 
#line 401
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 405
::exit(___);}
#if 0
#line 401
{ 
#line 402
int4 tmp; 
#line 403
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_char1(tmp.x); 
#line 405
} 
#endif
#line 407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(char2 *retVal, cudaTextureObject_t texObject, float x) 
#line 408
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 412
::exit(___);}
#if 0
#line 408
{ 
#line 409
int4 tmp; 
#line 410
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 412
} 
#endif
#line 414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(char4 *retVal, cudaTextureObject_t texObject, float x) 
#line 415
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 419
::exit(___);}
#if 0
#line 415
{ 
#line 416
int4 tmp; 
#line 417
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 419
} 
#endif
#line 421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(unsigned char *retVal, cudaTextureObject_t texObject, float x) 
#line 422
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 426
::exit(___);}
#if 0
#line 422
{ 
#line 423
uint4 tmp; 
#line 424
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 426
} 
#endif
#line 428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(uchar1 *retVal, cudaTextureObject_t texObject, float x) 
#line 429
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 433
::exit(___);}
#if 0
#line 429
{ 
#line 430
uint4 tmp; 
#line 431
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uchar1(tmp.x); 
#line 433
} 
#endif
#line 435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(uchar2 *retVal, cudaTextureObject_t texObject, float x) 
#line 436
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 440
::exit(___);}
#if 0
#line 436
{ 
#line 437
uint4 tmp; 
#line 438
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 440
} 
#endif
#line 442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(uchar4 *retVal, cudaTextureObject_t texObject, float x) 
#line 443
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 447
::exit(___);}
#if 0
#line 443
{ 
#line 444
uint4 tmp; 
#line 445
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 447
} 
#endif
#line 455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(short *retVal, cudaTextureObject_t texObject, float x) 
#line 456
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 460
::exit(___);}
#if 0
#line 456
{ 
#line 457
int4 tmp; 
#line 458
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((short)(tmp.x)); 
#line 460
} 
#endif
#line 462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(short1 *retVal, cudaTextureObject_t texObject, float x) 
#line 463
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 467
::exit(___);}
#if 0
#line 463
{ 
#line 464
int4 tmp; 
#line 465
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_short1(tmp.x); 
#line 467
} 
#endif
#line 469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(short2 *retVal, cudaTextureObject_t texObject, float x) 
#line 470
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 474
::exit(___);}
#if 0
#line 470
{ 
#line 471
int4 tmp; 
#line 472
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 474
} 
#endif
#line 476 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(short4 *retVal, cudaTextureObject_t texObject, float x) 
#line 477
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 481
::exit(___);}
#if 0
#line 477
{ 
#line 478
int4 tmp; 
#line 479
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 481
} 
#endif
#line 483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(unsigned short *retVal, cudaTextureObject_t texObject, float x) 
#line 484
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 488
::exit(___);}
#if 0
#line 484
{ 
#line 485
uint4 tmp; 
#line 486
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 488
} 
#endif
#line 490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(ushort1 *retVal, cudaTextureObject_t texObject, float x) 
#line 491
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 495
::exit(___);}
#if 0
#line 491
{ 
#line 492
uint4 tmp; 
#line 493
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ushort1(tmp.x); 
#line 495
} 
#endif
#line 497 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(ushort2 *retVal, cudaTextureObject_t texObject, float x) 
#line 498
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 502
::exit(___);}
#if 0
#line 498
{ 
#line 499
uint4 tmp; 
#line 500
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 502
} 
#endif
#line 504 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(ushort4 *retVal, cudaTextureObject_t texObject, float x) 
#line 505
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 509
::exit(___);}
#if 0
#line 505
{ 
#line 506
uint4 tmp; 
#line 507
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 509
} 
#endif
#line 517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(int *retVal, cudaTextureObject_t texObject, float x) 
#line 518
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 522
::exit(___);}
#if 0
#line 518
{ 
#line 519
int4 tmp; 
#line 520
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = (tmp.x); 
#line 522
} 
#endif
#line 524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(int1 *retVal, cudaTextureObject_t texObject, float x) 
#line 525
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 529
::exit(___);}
#if 0
#line 525
{ 
#line 526
int4 tmp; 
#line 527
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_int1(tmp.x); 
#line 529
} 
#endif
#line 531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(int2 *retVal, cudaTextureObject_t texObject, float x) 
#line 532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 536
::exit(___);}
#if 0
#line 532
{ 
#line 533
int4 tmp; 
#line 534
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 536
} 
#endif
#line 538 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(int4 *retVal, cudaTextureObject_t texObject, float x) 
#line 539
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 543
::exit(___);}
#if 0
#line 539
{ 
#line 540
int4 tmp; 
#line 541
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 543
} 
#endif
#line 545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(unsigned *retVal, cudaTextureObject_t texObject, float x) 
#line 546
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 550
::exit(___);}
#if 0
#line 546
{ 
#line 547
uint4 tmp; 
#line 548
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = (tmp.x); 
#line 550
} 
#endif
#line 552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(uint1 *retVal, cudaTextureObject_t texObject, float x) 
#line 553
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 557
::exit(___);}
#if 0
#line 553
{ 
#line 554
uint4 tmp; 
#line 555
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uint1(tmp.x); 
#line 557
} 
#endif
#line 559 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(uint2 *retVal, cudaTextureObject_t texObject, float x) 
#line 560
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 564
::exit(___);}
#if 0
#line 560
{ 
#line 561
uint4 tmp; 
#line 562
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 564
} 
#endif
#line 566 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(uint4 *retVal, cudaTextureObject_t texObject, float x) 
#line 567
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 571
::exit(___);}
#if 0
#line 567
{ 
#line 568
uint4 tmp; 
#line 569
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 571
} 
#endif
#line 581 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(long *retVal, cudaTextureObject_t texObject, float x) 
#line 582
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 586
::exit(___);}
#if 0
#line 582
{ 
#line 583
int4 tmp; 
#line 584
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((long)(tmp.x)); 
#line 586
} 
#endif
#line 588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(long1 *retVal, cudaTextureObject_t texObject, float x) 
#line 589
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 593
::exit(___);}
#if 0
#line 589
{ 
#line 590
int4 tmp; 
#line 591
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_long1(tmp.x); 
#line 593
} 
#endif
#line 595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(long2 *retVal, cudaTextureObject_t texObject, float x) 
#line 596
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 600
::exit(___);}
#if 0
#line 596
{ 
#line 597
int4 tmp; 
#line 598
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 600
} 
#endif
#line 602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(long4 *retVal, cudaTextureObject_t texObject, float x) 
#line 603
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 607
::exit(___);}
#if 0
#line 603
{ 
#line 604
int4 tmp; 
#line 605
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 607
} 
#endif
#line 609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(unsigned long *retVal, cudaTextureObject_t texObject, float x) 
#line 610
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 614
::exit(___);}
#if 0
#line 610
{ 
#line 611
uint4 tmp; 
#line 612
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 614
} 
#endif
#line 616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(ulong1 *retVal, cudaTextureObject_t texObject, float x) 
#line 617
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 621
::exit(___);}
#if 0
#line 617
{ 
#line 618
uint4 tmp; 
#line 619
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ulong1(tmp.x); 
#line 621
} 
#endif
#line 623 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(ulong2 *retVal, cudaTextureObject_t texObject, float x) 
#line 624
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 628
::exit(___);}
#if 0
#line 624
{ 
#line 625
uint4 tmp; 
#line 626
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 628
} 
#endif
#line 630 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(ulong4 *retVal, cudaTextureObject_t texObject, float x) 
#line 631
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 635
::exit(___);}
#if 0
#line 631
{ 
#line 632
uint4 tmp; 
#line 633
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 635
} 
#endif
#line 646 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(float *retVal, cudaTextureObject_t texObject, float x) 
#line 647
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 651
::exit(___);}
#if 0
#line 647
{ 
#line 648
float4 tmp; 
#line 649
__asm tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = (tmp.x); 
#line 651
} 
#endif
#line 653 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(float1 *retVal, cudaTextureObject_t texObject, float x) 
#line 654
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 658
::exit(___);}
#if 0
#line 654
{ 
#line 655
float4 tmp; 
#line 656
__asm tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_float1(tmp.x); 
#line 658
} 
#endif
#line 660 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(float2 *retVal, cudaTextureObject_t texObject, float x) 
#line 661
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 665
::exit(___);}
#if 0
#line 661
{ 
#line 662
float4 tmp; 
#line 663
__asm tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 665
} 
#endif
#line 667 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(float4 *retVal, cudaTextureObject_t texObject, float x) 
#line 668
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 672
::exit(___);}
#if 0
#line 668
{ 
#line 669
float4 tmp; 
#line 670
__asm tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 672
} 
#endif
#line 680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 681
tex1D(::cudaTextureObject_t texObject, float x) 
#line 682
{int volatile ___ = 1;(void)texObject;(void)x;
#line 686
::exit(___);}
#if 0
#line 682
{ 
#line 683
T ret; 
#line 684
tex1D(&ret, texObject, x); 
#line 685
return ret; 
#line 686
} 
#endif
#line 694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(char *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 695
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 704 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 695 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 700 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 701
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
#line 703 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 704
} 
#endif
#line 705 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(signed char *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 706
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 710
::exit(___);}
#if 0
#line 706
{ 
#line 707
int4 tmp; 
#line 708
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((signed char)(tmp.x)); 
#line 710
} 
#endif
#line 712 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(char1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 713
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 717
::exit(___);}
#if 0
#line 713
{ 
#line 714
int4 tmp; 
#line 715
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_char1(tmp.x); 
#line 717
} 
#endif
#line 719 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(char2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 720
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 724
::exit(___);}
#if 0
#line 720
{ 
#line 721
int4 tmp; 
#line 722
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 724
} 
#endif
#line 726 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(char4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 727
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 731
::exit(___);}
#if 0
#line 727
{ 
#line 728
int4 tmp; 
#line 729
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 731
} 
#endif
#line 733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 734
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 738
::exit(___);}
#if 0
#line 734
{ 
#line 735
uint4 tmp; 
#line 736
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 738
} 
#endif
#line 740 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 741
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 745
::exit(___);}
#if 0
#line 741
{ 
#line 742
uint4 tmp; 
#line 743
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uchar1(tmp.x); 
#line 745
} 
#endif
#line 747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 748
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 752
::exit(___);}
#if 0
#line 748
{ 
#line 749
uint4 tmp; 
#line 750
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 752
} 
#endif
#line 754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 755
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 759
::exit(___);}
#if 0
#line 755
{ 
#line 756
uint4 tmp; 
#line 757
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 759
} 
#endif
#line 767 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(short *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 768
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 772
::exit(___);}
#if 0
#line 768
{ 
#line 769
int4 tmp; 
#line 770
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((short)(tmp.x)); 
#line 772
} 
#endif
#line 774 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(short1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 775
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 779
::exit(___);}
#if 0
#line 775
{ 
#line 776
int4 tmp; 
#line 777
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_short1(tmp.x); 
#line 779
} 
#endif
#line 781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(short2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 782
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 786
::exit(___);}
#if 0
#line 782
{ 
#line 783
int4 tmp; 
#line 784
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 786
} 
#endif
#line 788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(short4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 789
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 793
::exit(___);}
#if 0
#line 789
{ 
#line 790
int4 tmp; 
#line 791
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 793
} 
#endif
#line 795 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 796
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 800
::exit(___);}
#if 0
#line 796
{ 
#line 797
uint4 tmp; 
#line 798
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 800
} 
#endif
#line 802 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 803
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 807
::exit(___);}
#if 0
#line 803
{ 
#line 804
uint4 tmp; 
#line 805
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ushort1(tmp.x); 
#line 807
} 
#endif
#line 809 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 810
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 814
::exit(___);}
#if 0
#line 810
{ 
#line 811
uint4 tmp; 
#line 812
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 814
} 
#endif
#line 816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 817
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 821
::exit(___);}
#if 0
#line 817
{ 
#line 818
uint4 tmp; 
#line 819
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 821
} 
#endif
#line 829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(int *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 830
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 834
::exit(___);}
#if 0
#line 830
{ 
#line 831
int4 tmp; 
#line 832
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = (tmp.x); 
#line 834
} 
#endif
#line 836 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(int1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 837
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 841
::exit(___);}
#if 0
#line 837
{ 
#line 838
int4 tmp; 
#line 839
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_int1(tmp.x); 
#line 841
} 
#endif
#line 843 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(int2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 844
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 848
::exit(___);}
#if 0
#line 844
{ 
#line 845
int4 tmp; 
#line 846
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 848
} 
#endif
#line 850 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(int4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 851
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 855
::exit(___);}
#if 0
#line 851
{ 
#line 852
int4 tmp; 
#line 853
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 855
} 
#endif
#line 857 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(unsigned *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 858
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 862
::exit(___);}
#if 0
#line 858
{ 
#line 859
uint4 tmp; 
#line 860
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = (tmp.x); 
#line 862
} 
#endif
#line 864 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 865
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 869
::exit(___);}
#if 0
#line 865
{ 
#line 866
uint4 tmp; 
#line 867
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uint1(tmp.x); 
#line 869
} 
#endif
#line 871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 872
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 876
::exit(___);}
#if 0
#line 872
{ 
#line 873
uint4 tmp; 
#line 874
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 876
} 
#endif
#line 878 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 879
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 883
::exit(___);}
#if 0
#line 879
{ 
#line 880
uint4 tmp; 
#line 881
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 883
} 
#endif
#line 893 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(long *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 894
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 898
::exit(___);}
#if 0
#line 894
{ 
#line 895
int4 tmp; 
#line 896
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((long)(tmp.x)); 
#line 898
} 
#endif
#line 900 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(long1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 901
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 905
::exit(___);}
#if 0
#line 901
{ 
#line 902
int4 tmp; 
#line 903
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_long1(tmp.x); 
#line 905
} 
#endif
#line 907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(long2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 908
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 912
::exit(___);}
#if 0
#line 908
{ 
#line 909
int4 tmp; 
#line 910
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 912
} 
#endif
#line 914 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(long4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 915
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 919
::exit(___);}
#if 0
#line 915
{ 
#line 916
int4 tmp; 
#line 917
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 919
} 
#endif
#line 921 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 922
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 926
::exit(___);}
#if 0
#line 922
{ 
#line 923
uint4 tmp; 
#line 924
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 926
} 
#endif
#line 928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 929
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 933
::exit(___);}
#if 0
#line 929
{ 
#line 930
uint4 tmp; 
#line 931
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ulong1(tmp.x); 
#line 933
} 
#endif
#line 935 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 936
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 940
::exit(___);}
#if 0
#line 936
{ 
#line 937
uint4 tmp; 
#line 938
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 940
} 
#endif
#line 942 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 943
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 947
::exit(___);}
#if 0
#line 943
{ 
#line 944
uint4 tmp; 
#line 945
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 947
} 
#endif
#line 958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(float *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 959
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 963
::exit(___);}
#if 0
#line 959
{ 
#line 960
float4 tmp; 
#line 961
__asm tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = (tmp.x); 
#line 963
} 
#endif
#line 965 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(float1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 966
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 970
::exit(___);}
#if 0
#line 966
{ 
#line 967
float4 tmp; 
#line 968
__asm tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_float1(tmp.x); 
#line 970
} 
#endif
#line 972 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(float2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 973
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 977
::exit(___);}
#if 0
#line 973
{ 
#line 974
float4 tmp; 
#line 975
__asm tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 977
} 
#endif
#line 979 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(float4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 980
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 984
::exit(___);}
#if 0
#line 980
{ 
#line 981
float4 tmp; 
#line 982
__asm tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 984
} 
#endif
#line 992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 993
tex2D(::cudaTextureObject_t texObject, float x, float y) 
#line 994
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;
#line 998
::exit(___);}
#if 0
#line 994
{ 
#line 995
T ret; 
#line 996
tex2D(&ret, texObject, x, y); 
#line 997
return ret; 
#line 998
} 
#endif
#line 1006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1007
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1016 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 1007 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 1012 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 1013
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
#line 1015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 1016
} 
#endif
#line 1017 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1018
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1022
::exit(___);}
#if 0
#line 1018
{ 
#line 1019
int4 tmp; 
#line 1020
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((signed char)(tmp.x)); 
#line 1022
} 
#endif
#line 1024 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1025
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1029
::exit(___);}
#if 0
#line 1025
{ 
#line 1026
int4 tmp; 
#line 1027
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char1(tmp.x); 
#line 1029
} 
#endif
#line 1031 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1032
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1036
::exit(___);}
#if 0
#line 1032
{ 
#line 1033
int4 tmp; 
#line 1034
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1036
} 
#endif
#line 1038 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1039
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1043
::exit(___);}
#if 0
#line 1039
{ 
#line 1040
int4 tmp; 
#line 1041
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1043
} 
#endif
#line 1045 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1046
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1050
::exit(___);}
#if 0
#line 1046
{ 
#line 1047
uint4 tmp; 
#line 1048
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 1050
} 
#endif
#line 1052 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1053
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1057
::exit(___);}
#if 0
#line 1053
{ 
#line 1054
uint4 tmp; 
#line 1055
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar1(tmp.x); 
#line 1057
} 
#endif
#line 1059 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1060
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1064
::exit(___);}
#if 0
#line 1060
{ 
#line 1061
uint4 tmp; 
#line 1062
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 1064
} 
#endif
#line 1066 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1067
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1071
::exit(___);}
#if 0
#line 1067
{ 
#line 1068
uint4 tmp; 
#line 1069
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1071
} 
#endif
#line 1079 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1080
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1084
::exit(___);}
#if 0
#line 1080
{ 
#line 1081
int4 tmp; 
#line 1082
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((short)(tmp.x)); 
#line 1084
} 
#endif
#line 1086 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1087
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1091
::exit(___);}
#if 0
#line 1087
{ 
#line 1088
int4 tmp; 
#line 1089
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short1(tmp.x); 
#line 1091
} 
#endif
#line 1093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1094
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1098
::exit(___);}
#if 0
#line 1094
{ 
#line 1095
int4 tmp; 
#line 1096
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 1098
} 
#endif
#line 1100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1101
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1105
::exit(___);}
#if 0
#line 1101
{ 
#line 1102
int4 tmp; 
#line 1103
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1105
} 
#endif
#line 1107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1108
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1112
::exit(___);}
#if 0
#line 1108
{ 
#line 1109
uint4 tmp; 
#line 1110
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 1112
} 
#endif
#line 1114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1115
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1119
::exit(___);}
#if 0
#line 1115
{ 
#line 1116
uint4 tmp; 
#line 1117
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort1(tmp.x); 
#line 1119
} 
#endif
#line 1121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1122
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1126
::exit(___);}
#if 0
#line 1122
{ 
#line 1123
uint4 tmp; 
#line 1124
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 1126
} 
#endif
#line 1128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1129
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1133
::exit(___);}
#if 0
#line 1129
{ 
#line 1130
uint4 tmp; 
#line 1131
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1133
} 
#endif
#line 1141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(int *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1142
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1146
::exit(___);}
#if 0
#line 1142
{ 
#line 1143
int4 tmp; 
#line 1144
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 1146
} 
#endif
#line 1148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1153
::exit(___);}
#if 0
#line 1149
{ 
#line 1150
int4 tmp; 
#line 1151
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int1(tmp.x); 
#line 1153
} 
#endif
#line 1155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1156
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1160
::exit(___);}
#if 0
#line 1156
{ 
#line 1157
int4 tmp; 
#line 1158
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 1160
} 
#endif
#line 1162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1163
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1167
::exit(___);}
#if 0
#line 1163
{ 
#line 1164
int4 tmp; 
#line 1165
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1167
} 
#endif
#line 1169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1170
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1174
::exit(___);}
#if 0
#line 1170
{ 
#line 1171
uint4 tmp; 
#line 1172
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 1174
} 
#endif
#line 1176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1177
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1181
::exit(___);}
#if 0
#line 1177
{ 
#line 1178
uint4 tmp; 
#line 1179
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint1(tmp.x); 
#line 1181
} 
#endif
#line 1183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1184
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1188
::exit(___);}
#if 0
#line 1184
{ 
#line 1185
uint4 tmp; 
#line 1186
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1188
} 
#endif
#line 1190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1191
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1195
::exit(___);}
#if 0
#line 1191
{ 
#line 1192
uint4 tmp; 
#line 1193
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1195
} 
#endif
#line 1205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(long *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1206
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1210
::exit(___);}
#if 0
#line 1206
{ 
#line 1207
int4 tmp; 
#line 1208
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((long)(tmp.x)); 
#line 1210
} 
#endif
#line 1212 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1213
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1217
::exit(___);}
#if 0
#line 1213
{ 
#line 1214
int4 tmp; 
#line 1215
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long1(tmp.x); 
#line 1217
} 
#endif
#line 1219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1220
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1224
::exit(___);}
#if 0
#line 1220
{ 
#line 1221
int4 tmp; 
#line 1222
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 1224
} 
#endif
#line 1226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1227
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1231
::exit(___);}
#if 0
#line 1227
{ 
#line 1228
int4 tmp; 
#line 1229
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1231
} 
#endif
#line 1233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1234
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1238
::exit(___);}
#if 0
#line 1234
{ 
#line 1235
uint4 tmp; 
#line 1236
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 1238
} 
#endif
#line 1240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1241
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1245
::exit(___);}
#if 0
#line 1241
{ 
#line 1242
uint4 tmp; 
#line 1243
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong1(tmp.x); 
#line 1245
} 
#endif
#line 1247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1248
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1252
::exit(___);}
#if 0
#line 1248
{ 
#line 1249
uint4 tmp; 
#line 1250
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 1252
} 
#endif
#line 1254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1259
::exit(___);}
#if 0
#line 1255
{ 
#line 1256
uint4 tmp; 
#line 1257
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1259
} 
#endif
#line 1270 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(float *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1271
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1275
::exit(___);}
#if 0
#line 1271
{ 
#line 1272
float4 tmp; 
#line 1273
__asm tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 1275
} 
#endif
#line 1277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1278
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1282
::exit(___);}
#if 0
#line 1278
{ 
#line 1279
float4 tmp; 
#line 1280
__asm tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float1(tmp.x); 
#line 1282
} 
#endif
#line 1284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1285
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1289
::exit(___);}
#if 0
#line 1285
{ 
#line 1286
float4 tmp; 
#line 1287
__asm tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1289
} 
#endif
#line 1291 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1292
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1296
::exit(___);}
#if 0
#line 1292
{ 
#line 1293
float4 tmp; 
#line 1294
__asm tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1296
} 
#endif
#line 1304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 1305
tex3D(::cudaTextureObject_t texObject, float x, float y, float z) 
#line 1306
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
#line 1310
::exit(___);}
#if 0
#line 1306
{ 
#line 1307
T ret; 
#line 1308
tex3D(&ret, texObject, x, y, z); 
#line 1309
return ret; 
#line 1310
} 
#endif
#line 1318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(char *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1319
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1328 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 1319 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 1325
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
#line 1327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 1328
} 
#endif
#line 1329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1330
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1334
::exit(___);}
#if 0
#line 1330
{ 
#line 1331
int4 tmp; 
#line 1332
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((signed char)(tmp.x)); 
#line 1334
} 
#endif
#line 1336 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1337
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1341
::exit(___);}
#if 0
#line 1337
{ 
#line 1338
int4 tmp; 
#line 1339
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_char1(tmp.x); 
#line 1341
} 
#endif
#line 1343 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1344
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1348
::exit(___);}
#if 0
#line 1344
{ 
#line 1345
int4 tmp; 
#line 1346
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1348
} 
#endif
#line 1350 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1351
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1355
::exit(___);}
#if 0
#line 1351
{ 
#line 1352
int4 tmp; 
#line 1353
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1355
} 
#endif
#line 1357 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1358
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1362
::exit(___);}
#if 0
#line 1358
{ 
#line 1359
uint4 tmp; 
#line 1360
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 1362
} 
#endif
#line 1364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1365
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1369
::exit(___);}
#if 0
#line 1365
{ 
#line 1366
uint4 tmp; 
#line 1367
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uchar1(tmp.x); 
#line 1369
} 
#endif
#line 1371 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1372
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1376
::exit(___);}
#if 0
#line 1372
{ 
#line 1373
uint4 tmp; 
#line 1374
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 1376
} 
#endif
#line 1378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1379
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1383
::exit(___);}
#if 0
#line 1379
{ 
#line 1380
uint4 tmp; 
#line 1381
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1383
} 
#endif
#line 1391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(short *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1392
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1396
::exit(___);}
#if 0
#line 1392
{ 
#line 1393
int4 tmp; 
#line 1394
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((short)(tmp.x)); 
#line 1396
} 
#endif
#line 1398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1399
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1403
::exit(___);}
#if 0
#line 1399
{ 
#line 1400
int4 tmp; 
#line 1401
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_short1(tmp.x); 
#line 1403
} 
#endif
#line 1405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1406
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1410
::exit(___);}
#if 0
#line 1406
{ 
#line 1407
int4 tmp; 
#line 1408
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 1410
} 
#endif
#line 1412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1413
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1417
::exit(___);}
#if 0
#line 1413
{ 
#line 1414
int4 tmp; 
#line 1415
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1417
} 
#endif
#line 1419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1420
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1424
::exit(___);}
#if 0
#line 1420
{ 
#line 1421
uint4 tmp; 
#line 1422
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 1424
} 
#endif
#line 1426 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1427
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1431
::exit(___);}
#if 0
#line 1427
{ 
#line 1428
uint4 tmp; 
#line 1429
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ushort1(tmp.x); 
#line 1431
} 
#endif
#line 1433 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1434
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1438
::exit(___);}
#if 0
#line 1434
{ 
#line 1435
uint4 tmp; 
#line 1436
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 1438
} 
#endif
#line 1440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1441
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1445
::exit(___);}
#if 0
#line 1441
{ 
#line 1442
uint4 tmp; 
#line 1443
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1445
} 
#endif
#line 1453 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(int *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1458
::exit(___);}
#if 0
#line 1454
{ 
#line 1455
int4 tmp; 
#line 1456
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = (tmp.x); 
#line 1458
} 
#endif
#line 1460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1465
::exit(___);}
#if 0
#line 1461
{ 
#line 1462
int4 tmp; 
#line 1463
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_int1(tmp.x); 
#line 1465
} 
#endif
#line 1467 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1468
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1472
::exit(___);}
#if 0
#line 1468
{ 
#line 1469
int4 tmp; 
#line 1470
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 1472
} 
#endif
#line 1474 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1475
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1479
::exit(___);}
#if 0
#line 1475
{ 
#line 1476
int4 tmp; 
#line 1477
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1479
} 
#endif
#line 1481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1482
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1486
::exit(___);}
#if 0
#line 1482
{ 
#line 1483
uint4 tmp; 
#line 1484
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = (tmp.x); 
#line 1486
} 
#endif
#line 1488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1489
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1493
::exit(___);}
#if 0
#line 1489
{ 
#line 1490
uint4 tmp; 
#line 1491
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uint1(tmp.x); 
#line 1493
} 
#endif
#line 1495 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1496
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1500
::exit(___);}
#if 0
#line 1496
{ 
#line 1497
uint4 tmp; 
#line 1498
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1500
} 
#endif
#line 1502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1503
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1507
::exit(___);}
#if 0
#line 1503
{ 
#line 1504
uint4 tmp; 
#line 1505
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1507
} 
#endif
#line 1517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(long *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1518
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1522
::exit(___);}
#if 0
#line 1518
{ 
#line 1519
int4 tmp; 
#line 1520
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((long)(tmp.x)); 
#line 1522
} 
#endif
#line 1524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(long1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1525
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1529
::exit(___);}
#if 0
#line 1525
{ 
#line 1526
int4 tmp; 
#line 1527
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_long1(tmp.x); 
#line 1529
} 
#endif
#line 1531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(long2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1536
::exit(___);}
#if 0
#line 1532
{ 
#line 1533
int4 tmp; 
#line 1534
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 1536
} 
#endif
#line 1538 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(long4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1539
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1543
::exit(___);}
#if 0
#line 1539
{ 
#line 1540
int4 tmp; 
#line 1541
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1543
} 
#endif
#line 1545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1546
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1550
::exit(___);}
#if 0
#line 1546
{ 
#line 1547
uint4 tmp; 
#line 1548
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 1550
} 
#endif
#line 1552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1553
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1557
::exit(___);}
#if 0
#line 1553
{ 
#line 1554
uint4 tmp; 
#line 1555
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ulong1(tmp.x); 
#line 1557
} 
#endif
#line 1559 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1560
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1564
::exit(___);}
#if 0
#line 1560
{ 
#line 1561
uint4 tmp; 
#line 1562
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 1564
} 
#endif
#line 1566 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1567
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1571
::exit(___);}
#if 0
#line 1567
{ 
#line 1568
uint4 tmp; 
#line 1569
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1571
} 
#endif
#line 1582 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(float *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1583
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1587
::exit(___);}
#if 0
#line 1583
{ 
#line 1584
float4 tmp; 
#line 1585
__asm tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = (tmp.x); 
#line 1587
} 
#endif
#line 1589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1590
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1594
::exit(___);}
#if 0
#line 1590
{ 
#line 1591
float4 tmp; 
#line 1592
__asm tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_float1(tmp.x); 
#line 1594
} 
#endif
#line 1596 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1597
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1601
::exit(___);}
#if 0
#line 1597
{ 
#line 1598
float4 tmp; 
#line 1599
__asm tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1601
} 
#endif
#line 1603 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1604
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1608
::exit(___);}
#if 0
#line 1604
{ 
#line 1605
float4 tmp; 
#line 1606
__asm tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1608
} 
#endif
#line 1616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 1617
tex1DLayered(::cudaTextureObject_t texObject, float x, int layer) 
#line 1618
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;
#line 1622
::exit(___);}
#if 0
#line 1618
{ 
#line 1619
T ret; 
#line 1620
tex1DLayered(&ret, texObject, x, layer); 
#line 1621
return ret; 
#line 1622
} 
#endif
#line 1630 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1631
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1640 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 1631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 1636 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 1637
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
#line 1639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 1640
} 
#endif
#line 1641 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1642
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1646
::exit(___);}
#if 0
#line 1642
{ 
#line 1643
int4 tmp; 
#line 1644
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((signed char)(tmp.x)); 
#line 1646
} 
#endif
#line 1648 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1649
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1653
::exit(___);}
#if 0
#line 1649
{ 
#line 1650
int4 tmp; 
#line 1651
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char1(tmp.x); 
#line 1653
} 
#endif
#line 1655 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1656
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1660
::exit(___);}
#if 0
#line 1656
{ 
#line 1657
int4 tmp; 
#line 1658
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1660
} 
#endif
#line 1662 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1663
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1667
::exit(___);}
#if 0
#line 1663
{ 
#line 1664
int4 tmp; 
#line 1665
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1667
} 
#endif
#line 1669 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1670
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1674
::exit(___);}
#if 0
#line 1670
{ 
#line 1671
uint4 tmp; 
#line 1672
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 1674
} 
#endif
#line 1676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1677
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1681
::exit(___);}
#if 0
#line 1677
{ 
#line 1678
uint4 tmp; 
#line 1679
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar1(tmp.x); 
#line 1681
} 
#endif
#line 1683 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1684
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1688
::exit(___);}
#if 0
#line 1684
{ 
#line 1685
uint4 tmp; 
#line 1686
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 1688
} 
#endif
#line 1690 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1691
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1695
::exit(___);}
#if 0
#line 1691
{ 
#line 1692
uint4 tmp; 
#line 1693
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1695
} 
#endif
#line 1703 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1704
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1708
::exit(___);}
#if 0
#line 1704
{ 
#line 1705
int4 tmp; 
#line 1706
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((short)(tmp.x)); 
#line 1708
} 
#endif
#line 1710 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1711
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1715
::exit(___);}
#if 0
#line 1711
{ 
#line 1712
int4 tmp; 
#line 1713
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short1(tmp.x); 
#line 1715
} 
#endif
#line 1717 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1718
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1722
::exit(___);}
#if 0
#line 1718
{ 
#line 1719
int4 tmp; 
#line 1720
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 1722
} 
#endif
#line 1724 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1725
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1729
::exit(___);}
#if 0
#line 1725
{ 
#line 1726
int4 tmp; 
#line 1727
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1729
} 
#endif
#line 1731 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1732
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1736
::exit(___);}
#if 0
#line 1732
{ 
#line 1733
uint4 tmp; 
#line 1734
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 1736
} 
#endif
#line 1738 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1739
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1743
::exit(___);}
#if 0
#line 1739
{ 
#line 1740
uint4 tmp; 
#line 1741
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort1(tmp.x); 
#line 1743
} 
#endif
#line 1745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1746
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1750
::exit(___);}
#if 0
#line 1746
{ 
#line 1747
uint4 tmp; 
#line 1748
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 1750
} 
#endif
#line 1752 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1753
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1757
::exit(___);}
#if 0
#line 1753
{ 
#line 1754
uint4 tmp; 
#line 1755
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1757
} 
#endif
#line 1765 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1766
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1770
::exit(___);}
#if 0
#line 1766
{ 
#line 1767
int4 tmp; 
#line 1768
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 1770
} 
#endif
#line 1772 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1777
::exit(___);}
#if 0
#line 1773
{ 
#line 1774
int4 tmp; 
#line 1775
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int1(tmp.x); 
#line 1777
} 
#endif
#line 1779 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1780
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1784
::exit(___);}
#if 0
#line 1780
{ 
#line 1781
int4 tmp; 
#line 1782
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 1784
} 
#endif
#line 1786 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1787
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1791
::exit(___);}
#if 0
#line 1787
{ 
#line 1788
int4 tmp; 
#line 1789
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1791
} 
#endif
#line 1793 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1794
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1798
::exit(___);}
#if 0
#line 1794
{ 
#line 1795
uint4 tmp; 
#line 1796
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 1798
} 
#endif
#line 1800 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1801
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1805
::exit(___);}
#if 0
#line 1801
{ 
#line 1802
uint4 tmp; 
#line 1803
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint1(tmp.x); 
#line 1805
} 
#endif
#line 1807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1808
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1812
::exit(___);}
#if 0
#line 1808
{ 
#line 1809
uint4 tmp; 
#line 1810
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1812
} 
#endif
#line 1814 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1815
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1819
::exit(___);}
#if 0
#line 1815
{ 
#line 1816
uint4 tmp; 
#line 1817
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1819
} 
#endif
#line 1829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1830
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1834
::exit(___);}
#if 0
#line 1830
{ 
#line 1831
int4 tmp; 
#line 1832
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((long)(tmp.x)); 
#line 1834
} 
#endif
#line 1836 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1837
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1841
::exit(___);}
#if 0
#line 1837
{ 
#line 1838
int4 tmp; 
#line 1839
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long1(tmp.x); 
#line 1841
} 
#endif
#line 1843 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1844
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1848
::exit(___);}
#if 0
#line 1844
{ 
#line 1845
int4 tmp; 
#line 1846
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 1848
} 
#endif
#line 1850 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1851
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1855
::exit(___);}
#if 0
#line 1851
{ 
#line 1852
int4 tmp; 
#line 1853
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1855
} 
#endif
#line 1857 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1858
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1862
::exit(___);}
#if 0
#line 1858
{ 
#line 1859
uint4 tmp; 
#line 1860
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 1862
} 
#endif
#line 1864 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1865
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1869
::exit(___);}
#if 0
#line 1865
{ 
#line 1866
uint4 tmp; 
#line 1867
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong1(tmp.x); 
#line 1869
} 
#endif
#line 1871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1872
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1876
::exit(___);}
#if 0
#line 1872
{ 
#line 1873
uint4 tmp; 
#line 1874
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 1876
} 
#endif
#line 1878 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1879
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1883
::exit(___);}
#if 0
#line 1879
{ 
#line 1880
uint4 tmp; 
#line 1881
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1883
} 
#endif
#line 1894 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1895
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1899
::exit(___);}
#if 0
#line 1895
{ 
#line 1896
float4 tmp; 
#line 1897
__asm tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 1899
} 
#endif
#line 1901 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1902
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1906
::exit(___);}
#if 0
#line 1902
{ 
#line 1903
float4 tmp; 
#line 1904
__asm tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float1(tmp.x); 
#line 1906
} 
#endif
#line 1908 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1909
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1913
::exit(___);}
#if 0
#line 1909
{ 
#line 1910
float4 tmp; 
#line 1911
__asm tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1913
} 
#endif
#line 1915 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1916
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1920
::exit(___);}
#if 0
#line 1916
{ 
#line 1917
float4 tmp; 
#line 1918
__asm tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1920
} 
#endif
#line 1928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 1929
tex2DLayered(::cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1930
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;
#line 1934
::exit(___);}
#if 0
#line 1930
{ 
#line 1931
T ret; 
#line 1932
tex2DLayered(&ret, texObject, x, y, layer); 
#line 1933
return ret; 
#line 1934
} 
#endif
#line 1942 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1943
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1952 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 1943 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 1948 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 1949
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
#line 1951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 1952
} 
#endif
#line 1953 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1954
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1958
::exit(___);}
#if 0
#line 1954
{ 
#line 1955
int4 tmp; 
#line 1956
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((signed char)(tmp.x)); 
#line 1958
} 
#endif
#line 1960 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1961
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1965
::exit(___);}
#if 0
#line 1961
{ 
#line 1962
int4 tmp; 
#line 1963
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char1(tmp.x); 
#line 1965
} 
#endif
#line 1967 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1968
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1972
::exit(___);}
#if 0
#line 1968
{ 
#line 1969
int4 tmp; 
#line 1970
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1972
} 
#endif
#line 1974 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1975
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1979
::exit(___);}
#if 0
#line 1975
{ 
#line 1976
int4 tmp; 
#line 1977
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1979
} 
#endif
#line 1981 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1982
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1986
::exit(___);}
#if 0
#line 1982
{ 
#line 1983
uint4 tmp; 
#line 1984
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 1986
} 
#endif
#line 1988 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1989
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1993
::exit(___);}
#if 0
#line 1989
{ 
#line 1990
uint4 tmp; 
#line 1991
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar1(tmp.x); 
#line 1993
} 
#endif
#line 1995 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1996
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2000
::exit(___);}
#if 0
#line 1996
{ 
#line 1997
uint4 tmp; 
#line 1998
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 2000
} 
#endif
#line 2002 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2003
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2007
::exit(___);}
#if 0
#line 2003
{ 
#line 2004
uint4 tmp; 
#line 2005
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2007
} 
#endif
#line 2015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2016
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2020
::exit(___);}
#if 0
#line 2016
{ 
#line 2017
int4 tmp; 
#line 2018
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((short)(tmp.x)); 
#line 2020
} 
#endif
#line 2022 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2023
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2027
::exit(___);}
#if 0
#line 2023
{ 
#line 2024
int4 tmp; 
#line 2025
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short1(tmp.x); 
#line 2027
} 
#endif
#line 2029 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2030
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2034
::exit(___);}
#if 0
#line 2030
{ 
#line 2031
int4 tmp; 
#line 2032
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 2034
} 
#endif
#line 2036 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2037
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2041
::exit(___);}
#if 0
#line 2037
{ 
#line 2038
int4 tmp; 
#line 2039
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2041
} 
#endif
#line 2043 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2044
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2048
::exit(___);}
#if 0
#line 2044
{ 
#line 2045
uint4 tmp; 
#line 2046
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 2048
} 
#endif
#line 2050 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2051
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2055
::exit(___);}
#if 0
#line 2051
{ 
#line 2052
uint4 tmp; 
#line 2053
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort1(tmp.x); 
#line 2055
} 
#endif
#line 2057 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2058
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2062
::exit(___);}
#if 0
#line 2058
{ 
#line 2059
uint4 tmp; 
#line 2060
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 2062
} 
#endif
#line 2064 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2065
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2069
::exit(___);}
#if 0
#line 2065
{ 
#line 2066
uint4 tmp; 
#line 2067
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2069
} 
#endif
#line 2077 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(int *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2078
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2082
::exit(___);}
#if 0
#line 2078
{ 
#line 2079
int4 tmp; 
#line 2080
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 2082
} 
#endif
#line 2084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2089
::exit(___);}
#if 0
#line 2085
{ 
#line 2086
int4 tmp; 
#line 2087
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int1(tmp.x); 
#line 2089
} 
#endif
#line 2091 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2092
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2096
::exit(___);}
#if 0
#line 2092
{ 
#line 2093
int4 tmp; 
#line 2094
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2096
} 
#endif
#line 2098 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2099
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2103
::exit(___);}
#if 0
#line 2099
{ 
#line 2100
int4 tmp; 
#line 2101
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2103
} 
#endif
#line 2105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2106
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2110
::exit(___);}
#if 0
#line 2106
{ 
#line 2107
uint4 tmp; 
#line 2108
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 2110
} 
#endif
#line 2112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2113
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2117
::exit(___);}
#if 0
#line 2113
{ 
#line 2114
uint4 tmp; 
#line 2115
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint1(tmp.x); 
#line 2117
} 
#endif
#line 2119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2120
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2124
::exit(___);}
#if 0
#line 2120
{ 
#line 2121
uint4 tmp; 
#line 2122
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 2124
} 
#endif
#line 2126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2127
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2131
::exit(___);}
#if 0
#line 2127
{ 
#line 2128
uint4 tmp; 
#line 2129
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2131
} 
#endif
#line 2141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(long *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2142
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2146
::exit(___);}
#if 0
#line 2142
{ 
#line 2143
int4 tmp; 
#line 2144
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((long)(tmp.x)); 
#line 2146
} 
#endif
#line 2148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2153
::exit(___);}
#if 0
#line 2149
{ 
#line 2150
int4 tmp; 
#line 2151
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long1(tmp.x); 
#line 2153
} 
#endif
#line 2155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2156
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2160
::exit(___);}
#if 0
#line 2156
{ 
#line 2157
int4 tmp; 
#line 2158
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 2160
} 
#endif
#line 2162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2163
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2167
::exit(___);}
#if 0
#line 2163
{ 
#line 2164
int4 tmp; 
#line 2165
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2167
} 
#endif
#line 2169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2170
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2174
::exit(___);}
#if 0
#line 2170
{ 
#line 2171
uint4 tmp; 
#line 2172
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 2174
} 
#endif
#line 2176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2177
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2181
::exit(___);}
#if 0
#line 2177
{ 
#line 2178
uint4 tmp; 
#line 2179
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong1(tmp.x); 
#line 2181
} 
#endif
#line 2183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2184
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2188
::exit(___);}
#if 0
#line 2184
{ 
#line 2185
uint4 tmp; 
#line 2186
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 2188
} 
#endif
#line 2190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2191
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2195
::exit(___);}
#if 0
#line 2191
{ 
#line 2192
uint4 tmp; 
#line 2193
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2195
} 
#endif
#line 2206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(float *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2207
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2211
::exit(___);}
#if 0
#line 2207
{ 
#line 2208
float4 tmp; 
#line 2209
__asm tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 2211
} 
#endif
#line 2213 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2214
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2218
::exit(___);}
#if 0
#line 2214
{ 
#line 2215
float4 tmp; 
#line 2216
__asm tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float1(tmp.x); 
#line 2218
} 
#endif
#line 2220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2221
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2225
::exit(___);}
#if 0
#line 2221
{ 
#line 2222
float4 tmp; 
#line 2223
__asm tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 2225
} 
#endif
#line 2227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2228
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2232
::exit(___);}
#if 0
#line 2228
{ 
#line 2229
float4 tmp; 
#line 2230
__asm tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2232
} 
#endif
#line 2240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 2241
texCubemap(::cudaTextureObject_t texObject, float x, float y, float z) 
#line 2242
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
#line 2246
::exit(___);}
#if 0
#line 2242
{ 
#line 2243
T ret; 
#line 2244
texCubemap(&ret, texObject, x, y, z); 
#line 2245
return ret; 
#line 2246
} 
#endif
#line 2254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2264 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 2255 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 2260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 2261
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
#line 2263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 2264
} 
#endif
#line 2265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2266
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2270
::exit(___);}
#if 0
#line 2266
{ 
#line 2267
int4 tmp; 
#line 2268
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = ((signed char)(tmp.x)); 
#line 2270
} 
#endif
#line 2272 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2273
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2277
::exit(___);}
#if 0
#line 2273
{ 
#line 2274
int4 tmp; 
#line 2275
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_char1(tmp.x); 
#line 2277
} 
#endif
#line 2279 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2280
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2284
::exit(___);}
#if 0
#line 2280
{ 
#line 2281
int4 tmp; 
#line 2282
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 2284
} 
#endif
#line 2286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2287
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2291
::exit(___);}
#if 0
#line 2287
{ 
#line 2288
int4 tmp; 
#line 2289
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2291
} 
#endif
#line 2293 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2294
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2298
::exit(___);}
#if 0
#line 2294
{ 
#line 2295
uint4 tmp; 
#line 2296
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 2298
} 
#endif
#line 2300 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2301
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2305
::exit(___);}
#if 0
#line 2301
{ 
#line 2302
uint4 tmp; 
#line 2303
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_uchar1(tmp.x); 
#line 2305
} 
#endif
#line 2307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2308
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2312
::exit(___);}
#if 0
#line 2308
{ 
#line 2309
uint4 tmp; 
#line 2310
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 2312
} 
#endif
#line 2314 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2315
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2319
::exit(___);}
#if 0
#line 2315
{ 
#line 2316
uint4 tmp; 
#line 2317
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2319
} 
#endif
#line 2327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2328
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2332
::exit(___);}
#if 0
#line 2328
{ 
#line 2329
int4 tmp; 
#line 2330
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = ((short)(tmp.x)); 
#line 2332
} 
#endif
#line 2334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2335
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2339
::exit(___);}
#if 0
#line 2335
{ 
#line 2336
int4 tmp; 
#line 2337
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_short1(tmp.x); 
#line 2339
} 
#endif
#line 2341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2342
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2346
::exit(___);}
#if 0
#line 2342
{ 
#line 2343
int4 tmp; 
#line 2344
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 2346
} 
#endif
#line 2348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2349
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2353
::exit(___);}
#if 0
#line 2349
{ 
#line 2350
int4 tmp; 
#line 2351
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2353
} 
#endif
#line 2355 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2356
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2360
::exit(___);}
#if 0
#line 2356
{ 
#line 2357
uint4 tmp; 
#line 2358
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 2360
} 
#endif
#line 2362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2363
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2367
::exit(___);}
#if 0
#line 2363
{ 
#line 2364
uint4 tmp; 
#line 2365
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_ushort1(tmp.x); 
#line 2367
} 
#endif
#line 2369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2370
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2374
::exit(___);}
#if 0
#line 2370
{ 
#line 2371
uint4 tmp; 
#line 2372
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 2374
} 
#endif
#line 2376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2377
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2381
::exit(___);}
#if 0
#line 2377
{ 
#line 2378
uint4 tmp; 
#line 2379
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2381
} 
#endif
#line 2389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2390
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2394
::exit(___);}
#if 0
#line 2390
{ 
#line 2391
int4 tmp; 
#line 2392
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = (tmp.x); 
#line 2394
} 
#endif
#line 2396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2397
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2401
::exit(___);}
#if 0
#line 2397
{ 
#line 2398
int4 tmp; 
#line 2399
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_int1(tmp.x); 
#line 2401
} 
#endif
#line 2403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2404
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2408
::exit(___);}
#if 0
#line 2404
{ 
#line 2405
int4 tmp; 
#line 2406
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2408
} 
#endif
#line 2410 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2411
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2415
::exit(___);}
#if 0
#line 2411
{ 
#line 2412
int4 tmp; 
#line 2413
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2415
} 
#endif
#line 2417 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2418
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2422
::exit(___);}
#if 0
#line 2418
{ 
#line 2419
uint4 tmp; 
#line 2420
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = (tmp.x); 
#line 2422
} 
#endif
#line 2424 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2425
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2429
::exit(___);}
#if 0
#line 2425
{ 
#line 2426
uint4 tmp; 
#line 2427
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_uint1(tmp.x); 
#line 2429
} 
#endif
#line 2431 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2432
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2436
::exit(___);}
#if 0
#line 2432
{ 
#line 2433
uint4 tmp; 
#line 2434
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 2436
} 
#endif
#line 2438 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2439
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2443
::exit(___);}
#if 0
#line 2439
{ 
#line 2440
uint4 tmp; 
#line 2441
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2443
} 
#endif
#line 2453 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2458
::exit(___);}
#if 0
#line 2454
{ 
#line 2455
int4 tmp; 
#line 2456
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = ((long)(tmp.x)); 
#line 2458
} 
#endif
#line 2460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2465
::exit(___);}
#if 0
#line 2461
{ 
#line 2462
int4 tmp; 
#line 2463
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_long1(tmp.x); 
#line 2465
} 
#endif
#line 2467 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2468
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2472
::exit(___);}
#if 0
#line 2468
{ 
#line 2469
int4 tmp; 
#line 2470
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 2472
} 
#endif
#line 2474 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2475
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2479
::exit(___);}
#if 0
#line 2475
{ 
#line 2476
int4 tmp; 
#line 2477
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2479
} 
#endif
#line 2481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2482
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2486
::exit(___);}
#if 0
#line 2482
{ 
#line 2483
uint4 tmp; 
#line 2484
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 2486
} 
#endif
#line 2488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2489
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2493
::exit(___);}
#if 0
#line 2489
{ 
#line 2490
uint4 tmp; 
#line 2491
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_ulong1(tmp.x); 
#line 2493
} 
#endif
#line 2495 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2496
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2500
::exit(___);}
#if 0
#line 2496
{ 
#line 2497
uint4 tmp; 
#line 2498
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 2500
} 
#endif
#line 2502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2503
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2507
::exit(___);}
#if 0
#line 2503
{ 
#line 2504
uint4 tmp; 
#line 2505
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2507
} 
#endif
#line 2518 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2519
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2523
::exit(___);}
#if 0
#line 2519
{ 
#line 2520
float4 tmp; 
#line 2521
__asm tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = (tmp.x); 
#line 2523
} 
#endif
#line 2525 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2526
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2530
::exit(___);}
#if 0
#line 2526
{ 
#line 2527
float4 tmp; 
#line 2528
__asm tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_float1(tmp.x); 
#line 2530
} 
#endif
#line 2532 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2533
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2537
::exit(___);}
#if 0
#line 2533
{ 
#line 2534
float4 tmp; 
#line 2535
__asm tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 2537
} 
#endif
#line 2539 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2540
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2544
::exit(___);}
#if 0
#line 2540
{ 
#line 2541
float4 tmp; 
#line 2542
__asm tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2544
} 
#endif
#line 2552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 2553
texCubemapLayered(::cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2554
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2558
::exit(___);}
#if 0
#line 2554
{ 
#line 2555
T ret; 
#line 2556
texCubemapLayered(&ret, texObject, x, y, z, layer); 
#line 2557
return ret; 
#line 2558
} 
#endif
#line 2566 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2567
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2582
::exit(___);}
#if 0
#line 2567
{ 
#line 2568
int4 tmp; 
#line 2569
if (comp == 0) { 
#line 2570
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2572
if (comp == 1) { 
#line 2573
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2575
if (comp == 2) { 
#line 2576
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2578
if (comp == 3) { 
#line 2579
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2581
(*retVal) = ((char)(tmp.x)); 
#line 2582
} 
#endif
#line 2584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2585
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2600
::exit(___);}
#if 0
#line 2585
{ 
#line 2586
int4 tmp; 
#line 2587
if (comp == 0) { 
#line 2588
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2590
if (comp == 1) { 
#line 2591
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2593
if (comp == 2) { 
#line 2594
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2596
if (comp == 3) { 
#line 2597
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2599
(*retVal) = ((signed char)(tmp.x)); 
#line 2600
} 
#endif
#line 2602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2603
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2618
::exit(___);}
#if 0
#line 2603
{ 
#line 2604
int4 tmp; 
#line 2605
if (comp == 0) { 
#line 2606
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2608
if (comp == 1) { 
#line 2609
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2611
if (comp == 2) { 
#line 2612
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2614
if (comp == 3) { 
#line 2615
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2617
(*retVal) = make_char1(tmp.x); 
#line 2618
} 
#endif
#line 2620 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2621
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2636
::exit(___);}
#if 0
#line 2621
{ 
#line 2622
int4 tmp; 
#line 2623
if (comp == 0) { 
#line 2624
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2626
if (comp == 1) { 
#line 2627
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2629
if (comp == 2) { 
#line 2630
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2632
if (comp == 3) { 
#line 2633
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2635
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 2636
} 
#endif
#line 2638 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2639
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2654
::exit(___);}
#if 0
#line 2639
{ 
#line 2640
int4 tmp; 
#line 2641
if (comp == 0) { 
#line 2642
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2644
if (comp == 1) { 
#line 2645
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2647
if (comp == 2) { 
#line 2648
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2650
if (comp == 3) { 
#line 2651
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2653
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2654
} 
#endif
#line 2656 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2657
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2672
::exit(___);}
#if 0
#line 2657
{ 
#line 2658
uint4 tmp; 
#line 2659
if (comp == 0) { 
#line 2660
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2662
if (comp == 1) { 
#line 2663
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2665
if (comp == 2) { 
#line 2666
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2668
if (comp == 3) { 
#line 2669
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2671
(*retVal) = ((unsigned char)(tmp.x)); 
#line 2672
} 
#endif
#line 2674 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2675
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2690
::exit(___);}
#if 0
#line 2675
{ 
#line 2676
uint4 tmp; 
#line 2677
if (comp == 0) { 
#line 2678
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2680
if (comp == 1) { 
#line 2681
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2683
if (comp == 2) { 
#line 2684
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2686
if (comp == 3) { 
#line 2687
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2689
(*retVal) = make_uchar1(tmp.x); 
#line 2690
} 
#endif
#line 2692 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2693
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2708
::exit(___);}
#if 0
#line 2693
{ 
#line 2694
uint4 tmp; 
#line 2695
if (comp == 0) { 
#line 2696
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2698
if (comp == 1) { 
#line 2699
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2701
if (comp == 2) { 
#line 2702
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2704
if (comp == 3) { 
#line 2705
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2707
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 2708
} 
#endif
#line 2710 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2711
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2726
::exit(___);}
#if 0
#line 2711
{ 
#line 2712
uint4 tmp; 
#line 2713
if (comp == 0) { 
#line 2714
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2716
if (comp == 1) { 
#line 2717
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2719
if (comp == 2) { 
#line 2720
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2722
if (comp == 3) { 
#line 2723
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2725
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2726
} 
#endif
#line 2734 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(short *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2735
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2750
::exit(___);}
#if 0
#line 2735
{ 
#line 2736
int4 tmp; 
#line 2737
if (comp == 0) { 
#line 2738
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2740
if (comp == 1) { 
#line 2741
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2743
if (comp == 2) { 
#line 2744
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2746
if (comp == 3) { 
#line 2747
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2749
(*retVal) = ((short)(tmp.x)); 
#line 2750
} 
#endif
#line 2752 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2753
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2768
::exit(___);}
#if 0
#line 2753
{ 
#line 2754
int4 tmp; 
#line 2755
if (comp == 0) { 
#line 2756
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2758
if (comp == 1) { 
#line 2759
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2761
if (comp == 2) { 
#line 2762
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2764
if (comp == 3) { 
#line 2765
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2767
(*retVal) = make_short1(tmp.x); 
#line 2768
} 
#endif
#line 2770 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2771
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2786
::exit(___);}
#if 0
#line 2771
{ 
#line 2772
int4 tmp; 
#line 2773
if (comp == 0) { 
#line 2774
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2776
if (comp == 1) { 
#line 2777
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2779
if (comp == 2) { 
#line 2780
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2782
if (comp == 3) { 
#line 2783
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2785
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 2786
} 
#endif
#line 2788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2789
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2804
::exit(___);}
#if 0
#line 2789
{ 
#line 2790
int4 tmp; 
#line 2791
if (comp == 0) { 
#line 2792
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2794
if (comp == 1) { 
#line 2795
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2797
if (comp == 2) { 
#line 2798
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2800
if (comp == 3) { 
#line 2801
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2803
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2804
} 
#endif
#line 2806 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2807
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2822
::exit(___);}
#if 0
#line 2807
{ 
#line 2808
uint4 tmp; 
#line 2809
if (comp == 0) { 
#line 2810
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2812
if (comp == 1) { 
#line 2813
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2815
if (comp == 2) { 
#line 2816
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2818
if (comp == 3) { 
#line 2819
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2821
(*retVal) = ((unsigned short)(tmp.x)); 
#line 2822
} 
#endif
#line 2824 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2825
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2840
::exit(___);}
#if 0
#line 2825
{ 
#line 2826
uint4 tmp; 
#line 2827
if (comp == 0) { 
#line 2828
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2830
if (comp == 1) { 
#line 2831
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2833
if (comp == 2) { 
#line 2834
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2836
if (comp == 3) { 
#line 2837
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2839
(*retVal) = make_ushort1(tmp.x); 
#line 2840
} 
#endif
#line 2842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2843
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2858
::exit(___);}
#if 0
#line 2843
{ 
#line 2844
uint4 tmp; 
#line 2845
if (comp == 0) { 
#line 2846
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2848
if (comp == 1) { 
#line 2849
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2851
if (comp == 2) { 
#line 2852
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2854
if (comp == 3) { 
#line 2855
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2857
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 2858
} 
#endif
#line 2860 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2861
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2876
::exit(___);}
#if 0
#line 2861
{ 
#line 2862
uint4 tmp; 
#line 2863
if (comp == 0) { 
#line 2864
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2866
if (comp == 1) { 
#line 2867
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2869
if (comp == 2) { 
#line 2870
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2872
if (comp == 3) { 
#line 2873
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2875
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2876
} 
#endif
#line 2884 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(int *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2885
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2900
::exit(___);}
#if 0
#line 2885
{ 
#line 2886
int4 tmp; 
#line 2887
if (comp == 0) { 
#line 2888
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2890
if (comp == 1) { 
#line 2891
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2893
if (comp == 2) { 
#line 2894
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2896
if (comp == 3) { 
#line 2897
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2899
(*retVal) = (tmp.x); 
#line 2900
} 
#endif
#line 2902 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2903
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2918
::exit(___);}
#if 0
#line 2903
{ 
#line 2904
int4 tmp; 
#line 2905
if (comp == 0) { 
#line 2906
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2908
if (comp == 1) { 
#line 2909
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2911
if (comp == 2) { 
#line 2912
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2914
if (comp == 3) { 
#line 2915
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2917
(*retVal) = make_int1(tmp.x); 
#line 2918
} 
#endif
#line 2920 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2921
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2936
::exit(___);}
#if 0
#line 2921
{ 
#line 2922
int4 tmp; 
#line 2923
if (comp == 0) { 
#line 2924
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2926
if (comp == 1) { 
#line 2927
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2929
if (comp == 2) { 
#line 2930
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2932
if (comp == 3) { 
#line 2933
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2935
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2936
} 
#endif
#line 2938 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2939
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2954
::exit(___);}
#if 0
#line 2939
{ 
#line 2940
int4 tmp; 
#line 2941
if (comp == 0) { 
#line 2942
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2944
if (comp == 1) { 
#line 2945
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2947
if (comp == 2) { 
#line 2948
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2950
if (comp == 3) { 
#line 2951
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2953
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2954
} 
#endif
#line 2956 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2957
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2972
::exit(___);}
#if 0
#line 2957
{ 
#line 2958
uint4 tmp; 
#line 2959
if (comp == 0) { 
#line 2960
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2962
if (comp == 1) { 
#line 2963
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2965
if (comp == 2) { 
#line 2966
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2968
if (comp == 3) { 
#line 2969
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2971
(*retVal) = (tmp.x); 
#line 2972
} 
#endif
#line 2974 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2975
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2990
::exit(___);}
#if 0
#line 2975
{ 
#line 2976
uint4 tmp; 
#line 2977
if (comp == 0) { 
#line 2978
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2980
if (comp == 1) { 
#line 2981
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2983
if (comp == 2) { 
#line 2984
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2986
if (comp == 3) { 
#line 2987
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2989
(*retVal) = make_uint1(tmp.x); 
#line 2990
} 
#endif
#line 2992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2993
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3008
::exit(___);}
#if 0
#line 2993
{ 
#line 2994
uint4 tmp; 
#line 2995
if (comp == 0) { 
#line 2996
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2998
if (comp == 1) { 
#line 2999
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3001
if (comp == 2) { 
#line 3002
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3004
if (comp == 3) { 
#line 3005
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3007
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3008
} 
#endif
#line 3010 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3011
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3026
::exit(___);}
#if 0
#line 3011
{ 
#line 3012
uint4 tmp; 
#line 3013
if (comp == 0) { 
#line 3014
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3016
if (comp == 1) { 
#line 3017
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3019
if (comp == 2) { 
#line 3020
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3022
if (comp == 3) { 
#line 3023
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3025
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3026
} 
#endif
#line 3034 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(long *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3035
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3050
::exit(___);}
#if 0
#line 3035
{ 
#line 3036
int4 tmp; 
#line 3037
if (comp == 0) { 
#line 3038
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3040
if (comp == 1) { 
#line 3041
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3043
if (comp == 2) { 
#line 3044
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3046
if (comp == 3) { 
#line 3047
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3049
(*retVal) = ((long)(tmp.x)); 
#line 3050
} 
#endif
#line 3052 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3053
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3068
::exit(___);}
#if 0
#line 3053
{ 
#line 3054
int4 tmp; 
#line 3055
if (comp == 0) { 
#line 3056
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3058
if (comp == 1) { 
#line 3059
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3061
if (comp == 2) { 
#line 3062
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3064
if (comp == 3) { 
#line 3065
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3067
(*retVal) = make_long1(tmp.x); 
#line 3068
} 
#endif
#line 3070 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3071
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3086
::exit(___);}
#if 0
#line 3071
{ 
#line 3072
int4 tmp; 
#line 3073
if (comp == 0) { 
#line 3074
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3076
if (comp == 1) { 
#line 3077
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3079
if (comp == 2) { 
#line 3080
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3082
if (comp == 3) { 
#line 3083
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3085
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 3086
} 
#endif
#line 3088 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3089
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3104
::exit(___);}
#if 0
#line 3089
{ 
#line 3090
int4 tmp; 
#line 3091
if (comp == 0) { 
#line 3092
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3094
if (comp == 1) { 
#line 3095
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3097
if (comp == 2) { 
#line 3098
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3100
if (comp == 3) { 
#line 3101
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3103
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3104
} 
#endif
#line 3106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3107
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3122
::exit(___);}
#if 0
#line 3107
{ 
#line 3108
uint4 tmp; 
#line 3109
if (comp == 0) { 
#line 3110
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3112
if (comp == 1) { 
#line 3113
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3115
if (comp == 2) { 
#line 3116
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3118
if (comp == 3) { 
#line 3119
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3121
(*retVal) = ((unsigned long)(tmp.x)); 
#line 3122
} 
#endif
#line 3124 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3125
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3140
::exit(___);}
#if 0
#line 3125
{ 
#line 3126
uint4 tmp; 
#line 3127
if (comp == 0) { 
#line 3128
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3130
if (comp == 1) { 
#line 3131
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3133
if (comp == 2) { 
#line 3134
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3136
if (comp == 3) { 
#line 3137
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3139
(*retVal) = make_ulong1(tmp.x); 
#line 3140
} 
#endif
#line 3142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3143
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3158
::exit(___);}
#if 0
#line 3143
{ 
#line 3144
uint4 tmp; 
#line 3145
if (comp == 0) { 
#line 3146
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3148
if (comp == 1) { 
#line 3149
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3151
if (comp == 2) { 
#line 3152
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3154
if (comp == 3) { 
#line 3155
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3157
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 3158
} 
#endif
#line 3160 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3161
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3176
::exit(___);}
#if 0
#line 3161
{ 
#line 3162
uint4 tmp; 
#line 3163
if (comp == 0) { 
#line 3164
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3166
if (comp == 1) { 
#line 3167
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3169
if (comp == 2) { 
#line 3170
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3172
if (comp == 3) { 
#line 3173
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3175
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3176
} 
#endif
#line 3184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(float *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3185
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3200
::exit(___);}
#if 0
#line 3185
{ 
#line 3186
float4 tmp; 
#line 3187
if (comp == 0) { 
#line 3188
__asm tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3190
if (comp == 1) { 
#line 3191
__asm tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3193
if (comp == 2) { 
#line 3194
__asm tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3196
if (comp == 3) { 
#line 3197
__asm tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3199
(*retVal) = (tmp.x); 
#line 3200
} 
#endif
#line 3202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3203
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3218
::exit(___);}
#if 0
#line 3203
{ 
#line 3204
float4 tmp; 
#line 3205
if (comp == 0) { 
#line 3206
__asm tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3208
if (comp == 1) { 
#line 3209
__asm tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3211
if (comp == 2) { 
#line 3212
__asm tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3214
if (comp == 3) { 
#line 3215
__asm tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3217
(*retVal) = make_float1(tmp.x); 
#line 3218
} 
#endif
#line 3220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3221
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3236
::exit(___);}
#if 0
#line 3221
{ 
#line 3222
float4 tmp; 
#line 3223
if (comp == 0) { 
#line 3224
__asm tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3226
if (comp == 1) { 
#line 3227
__asm tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3229
if (comp == 2) { 
#line 3230
__asm tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3232
if (comp == 3) { 
#line 3233
__asm tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3235
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3236
} 
#endif
#line 3238 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3239
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3254
::exit(___);}
#if 0
#line 3239
{ 
#line 3240
float4 tmp; 
#line 3241
if (comp == 0) { 
#line 3242
__asm tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3244
if (comp == 1) { 
#line 3245
__asm tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3247
if (comp == 2) { 
#line 3248
__asm tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3250
if (comp == 3) { 
#line 3251
__asm tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3253
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3254
} 
#endif
#line 3262 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 3263
tex2Dgather(::cudaTextureObject_t to, float x, float y, int comp = 0) 
#line 3264
{int volatile ___ = 1;(void)to;(void)x;(void)y;(void)comp;
#line 3268
::exit(___);}
#if 0
#line 3264
{ 
#line 3265
T ret; 
#line 3266
tex2Dgather(&ret, to, x, y, comp); 
#line 3267
return ret; 
#line 3268
} 
#endif
#line 3276 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(char *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3277
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 3277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 3282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 3283
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
#line 3285 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 3286
} 
#endif
#line 3287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3288
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3292
::exit(___);}
#if 0
#line 3288
{ 
#line 3289
int4 tmp; 
#line 3290
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = ((signed char)(tmp.x)); 
#line 3292
} 
#endif
#line 3294 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3295
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3299
::exit(___);}
#if 0
#line 3295
{ 
#line 3296
int4 tmp; 
#line 3297
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_char1(tmp.x); 
#line 3299
} 
#endif
#line 3301 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3302
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3306
::exit(___);}
#if 0
#line 3302
{ 
#line 3303
int4 tmp; 
#line 3304
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3306
} 
#endif
#line 3308 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3309
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3313
::exit(___);}
#if 0
#line 3309
{ 
#line 3310
int4 tmp; 
#line 3311
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3313
} 
#endif
#line 3315 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3316
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3320
::exit(___);}
#if 0
#line 3316
{ 
#line 3317
uint4 tmp; 
#line 3318
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 3320
} 
#endif
#line 3322 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3323
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3327
::exit(___);}
#if 0
#line 3323
{ 
#line 3324
uint4 tmp; 
#line 3325
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_uchar1(tmp.x); 
#line 3327
} 
#endif
#line 3329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3330
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3334
::exit(___);}
#if 0
#line 3330
{ 
#line 3331
uint4 tmp; 
#line 3332
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3334
} 
#endif
#line 3336 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3337
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3341
::exit(___);}
#if 0
#line 3337
{ 
#line 3338
uint4 tmp; 
#line 3339
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3341
} 
#endif
#line 3349 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(short *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3350
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3354
::exit(___);}
#if 0
#line 3350
{ 
#line 3351
int4 tmp; 
#line 3352
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = ((short)(tmp.x)); 
#line 3354
} 
#endif
#line 3356 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3357
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3361
::exit(___);}
#if 0
#line 3357
{ 
#line 3358
int4 tmp; 
#line 3359
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_short1(tmp.x); 
#line 3361
} 
#endif
#line 3363 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3364
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3368
::exit(___);}
#if 0
#line 3364
{ 
#line 3365
int4 tmp; 
#line 3366
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3368
} 
#endif
#line 3370 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3371
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3375
::exit(___);}
#if 0
#line 3371
{ 
#line 3372
int4 tmp; 
#line 3373
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3375
} 
#endif
#line 3377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3378
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3382
::exit(___);}
#if 0
#line 3378
{ 
#line 3379
uint4 tmp; 
#line 3380
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 3382
} 
#endif
#line 3384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3385
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3389
::exit(___);}
#if 0
#line 3385
{ 
#line 3386
uint4 tmp; 
#line 3387
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_ushort1(tmp.x); 
#line 3389
} 
#endif
#line 3391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3392
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3396
::exit(___);}
#if 0
#line 3392
{ 
#line 3393
uint4 tmp; 
#line 3394
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 3396
} 
#endif
#line 3398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3399
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3403
::exit(___);}
#if 0
#line 3399
{ 
#line 3400
uint4 tmp; 
#line 3401
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3403
} 
#endif
#line 3411 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(int *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3412
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3416
::exit(___);}
#if 0
#line 3412
{ 
#line 3413
int4 tmp; 
#line 3414
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = (tmp.x); 
#line 3416
} 
#endif
#line 3418 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3419
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3423
::exit(___);}
#if 0
#line 3419
{ 
#line 3420
int4 tmp; 
#line 3421
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_int1(tmp.x); 
#line 3423
} 
#endif
#line 3425 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3426
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3430
::exit(___);}
#if 0
#line 3426
{ 
#line 3427
int4 tmp; 
#line 3428
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 3430
} 
#endif
#line 3432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3433
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3437
::exit(___);}
#if 0
#line 3433
{ 
#line 3434
int4 tmp; 
#line 3435
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3437
} 
#endif
#line 3439 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3440
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3444
::exit(___);}
#if 0
#line 3440
{ 
#line 3441
uint4 tmp; 
#line 3442
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = (tmp.x); 
#line 3444
} 
#endif
#line 3446 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3447
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3451
::exit(___);}
#if 0
#line 3447
{ 
#line 3448
uint4 tmp; 
#line 3449
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_uint1(tmp.x); 
#line 3451
} 
#endif
#line 3453 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3458
::exit(___);}
#if 0
#line 3454
{ 
#line 3455
uint4 tmp; 
#line 3456
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3458
} 
#endif
#line 3460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3465
::exit(___);}
#if 0
#line 3461
{ 
#line 3462
uint4 tmp; 
#line 3463
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3465
} 
#endif
#line 3475 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(long *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3476
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3480
::exit(___);}
#if 0
#line 3476
{ 
#line 3477
int4 tmp; 
#line 3478
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = ((long)(tmp.x)); 
#line 3480
} 
#endif
#line 3482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3483
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3487
::exit(___);}
#if 0
#line 3483
{ 
#line 3484
int4 tmp; 
#line 3485
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_long1(tmp.x); 
#line 3487
} 
#endif
#line 3489 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3490
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3494
::exit(___);}
#if 0
#line 3490
{ 
#line 3491
int4 tmp; 
#line 3492
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 3494
} 
#endif
#line 3496 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3497
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3501
::exit(___);}
#if 0
#line 3497
{ 
#line 3498
int4 tmp; 
#line 3499
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3501
} 
#endif
#line 3503 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3504
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3508
::exit(___);}
#if 0
#line 3504
{ 
#line 3505
uint4 tmp; 
#line 3506
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 3508
} 
#endif
#line 3510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3511
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3515
::exit(___);}
#if 0
#line 3511
{ 
#line 3512
uint4 tmp; 
#line 3513
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_ulong1(tmp.x); 
#line 3515
} 
#endif
#line 3517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3518
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3522
::exit(___);}
#if 0
#line 3518
{ 
#line 3519
uint4 tmp; 
#line 3520
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 3522
} 
#endif
#line 3524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3525
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3529
::exit(___);}
#if 0
#line 3525
{ 
#line 3526
uint4 tmp; 
#line 3527
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3529
} 
#endif
#line 3540 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(float *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3541
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3545
::exit(___);}
#if 0
#line 3541
{ 
#line 3542
float4 tmp; 
#line 3543
__asm tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = (tmp.x); 
#line 3545
} 
#endif
#line 3547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3548
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3552
::exit(___);}
#if 0
#line 3548
{ 
#line 3549
float4 tmp; 
#line 3550
__asm tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_float1(tmp.x); 
#line 3552
} 
#endif
#line 3554 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3555
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3559
::exit(___);}
#if 0
#line 3555
{ 
#line 3556
float4 tmp; 
#line 3557
__asm tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3559
} 
#endif
#line 3561 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3562
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3566
::exit(___);}
#if 0
#line 3562
{ 
#line 3563
float4 tmp; 
#line 3564
__asm tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3566
} 
#endif
#line 3574 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 3575
tex1DLod(::cudaTextureObject_t texObject, float x, float level) 
#line 3576
{int volatile ___ = 1;(void)texObject;(void)x;(void)level;
#line 3580
::exit(___);}
#if 0
#line 3576
{ 
#line 3577
T ret; 
#line 3578
tex1DLod(&ret, texObject, x, level); 
#line 3579
return ret; 
#line 3580
} 
#endif
#line 3588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3589
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3598 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 3589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 3594 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 3595
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
#line 3597 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 3598
} 
#endif
#line 3599 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3600
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3604
::exit(___);}
#if 0
#line 3600
{ 
#line 3601
int4 tmp; 
#line 3602
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((signed char)(tmp.x)); 
#line 3604
} 
#endif
#line 3606 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3607
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3611
::exit(___);}
#if 0
#line 3607
{ 
#line 3608
int4 tmp; 
#line 3609
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_char1(tmp.x); 
#line 3611
} 
#endif
#line 3613 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3614
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3618
::exit(___);}
#if 0
#line 3614
{ 
#line 3615
int4 tmp; 
#line 3616
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3618
} 
#endif
#line 3620 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3621
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3625
::exit(___);}
#if 0
#line 3621
{ 
#line 3622
int4 tmp; 
#line 3623
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3625
} 
#endif
#line 3627 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3628
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3632
::exit(___);}
#if 0
#line 3628
{ 
#line 3629
uint4 tmp; 
#line 3630
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 3632
} 
#endif
#line 3634 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3635
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3639
::exit(___);}
#if 0
#line 3635
{ 
#line 3636
uint4 tmp; 
#line 3637
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uchar1(tmp.x); 
#line 3639
} 
#endif
#line 3641 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3642
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3646
::exit(___);}
#if 0
#line 3642
{ 
#line 3643
uint4 tmp; 
#line 3644
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3646
} 
#endif
#line 3648 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3649
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3653
::exit(___);}
#if 0
#line 3649
{ 
#line 3650
uint4 tmp; 
#line 3651
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3653
} 
#endif
#line 3661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3662
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3666
::exit(___);}
#if 0
#line 3662
{ 
#line 3663
int4 tmp; 
#line 3664
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((short)(tmp.x)); 
#line 3666
} 
#endif
#line 3668 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3669
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3673
::exit(___);}
#if 0
#line 3669
{ 
#line 3670
int4 tmp; 
#line 3671
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_short1(tmp.x); 
#line 3673
} 
#endif
#line 3675 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3676
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3680
::exit(___);}
#if 0
#line 3676
{ 
#line 3677
int4 tmp; 
#line 3678
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3680
} 
#endif
#line 3682 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3683
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3687
::exit(___);}
#if 0
#line 3683
{ 
#line 3684
int4 tmp; 
#line 3685
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3687
} 
#endif
#line 3689 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3690
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3694
::exit(___);}
#if 0
#line 3690
{ 
#line 3691
uint4 tmp; 
#line 3692
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 3694
} 
#endif
#line 3696 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3697
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3701
::exit(___);}
#if 0
#line 3697
{ 
#line 3698
uint4 tmp; 
#line 3699
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ushort1(tmp.x); 
#line 3701
} 
#endif
#line 3703 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3704
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3708
::exit(___);}
#if 0
#line 3704
{ 
#line 3705
uint4 tmp; 
#line 3706
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 3708
} 
#endif
#line 3710 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3711
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3715
::exit(___);}
#if 0
#line 3711
{ 
#line 3712
uint4 tmp; 
#line 3713
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3715
} 
#endif
#line 3723 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3724
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3728
::exit(___);}
#if 0
#line 3724
{ 
#line 3725
int4 tmp; 
#line 3726
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = (tmp.x); 
#line 3728
} 
#endif
#line 3730 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3731
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3735
::exit(___);}
#if 0
#line 3731
{ 
#line 3732
int4 tmp; 
#line 3733
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_int1(tmp.x); 
#line 3735
} 
#endif
#line 3737 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3738
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3742
::exit(___);}
#if 0
#line 3738
{ 
#line 3739
int4 tmp; 
#line 3740
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 3742
} 
#endif
#line 3744 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3745
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3749
::exit(___);}
#if 0
#line 3745
{ 
#line 3746
int4 tmp; 
#line 3747
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3749
} 
#endif
#line 3751 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3752
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3756
::exit(___);}
#if 0
#line 3752
{ 
#line 3753
uint4 tmp; 
#line 3754
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = (tmp.x); 
#line 3756
} 
#endif
#line 3758 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3759
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3763
::exit(___);}
#if 0
#line 3759
{ 
#line 3760
uint4 tmp; 
#line 3761
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uint1(tmp.x); 
#line 3763
} 
#endif
#line 3765 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3766
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3770
::exit(___);}
#if 0
#line 3766
{ 
#line 3767
uint4 tmp; 
#line 3768
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3770
} 
#endif
#line 3772 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3777
::exit(___);}
#if 0
#line 3773
{ 
#line 3774
uint4 tmp; 
#line 3775
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3777
} 
#endif
#line 3787 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3788
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3792
::exit(___);}
#if 0
#line 3788
{ 
#line 3789
int4 tmp; 
#line 3790
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((long)(tmp.x)); 
#line 3792
} 
#endif
#line 3794 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3795
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3799
::exit(___);}
#if 0
#line 3795
{ 
#line 3796
int4 tmp; 
#line 3797
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_long1(tmp.x); 
#line 3799
} 
#endif
#line 3801 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3802
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3806
::exit(___);}
#if 0
#line 3802
{ 
#line 3803
int4 tmp; 
#line 3804
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 3806
} 
#endif
#line 3808 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3809
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3813
::exit(___);}
#if 0
#line 3809
{ 
#line 3810
int4 tmp; 
#line 3811
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3813
} 
#endif
#line 3815 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3816
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3820
::exit(___);}
#if 0
#line 3816
{ 
#line 3817
uint4 tmp; 
#line 3818
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 3820
} 
#endif
#line 3822 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3823
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3827
::exit(___);}
#if 0
#line 3823
{ 
#line 3824
uint4 tmp; 
#line 3825
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ulong1(tmp.x); 
#line 3827
} 
#endif
#line 3829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3830
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3834
::exit(___);}
#if 0
#line 3830
{ 
#line 3831
uint4 tmp; 
#line 3832
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 3834
} 
#endif
#line 3836 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3837
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3841
::exit(___);}
#if 0
#line 3837
{ 
#line 3838
uint4 tmp; 
#line 3839
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3841
} 
#endif
#line 3852 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3853
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3857
::exit(___);}
#if 0
#line 3853
{ 
#line 3854
float4 tmp; 
#line 3855
__asm tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = (tmp.x); 
#line 3857
} 
#endif
#line 3859 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3860
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3864
::exit(___);}
#if 0
#line 3860
{ 
#line 3861
float4 tmp; 
#line 3862
__asm tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_float1(tmp.x); 
#line 3864
} 
#endif
#line 3866 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3867
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3871
::exit(___);}
#if 0
#line 3867
{ 
#line 3868
float4 tmp; 
#line 3869
__asm tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3871
} 
#endif
#line 3873 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3874
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3878
::exit(___);}
#if 0
#line 3874
{ 
#line 3875
float4 tmp; 
#line 3876
__asm tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3878
} 
#endif
#line 3886 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 3887
tex2DLod(::cudaTextureObject_t texObject, float x, float y, float level) 
#line 3888
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;
#line 3892
::exit(___);}
#if 0
#line 3888
{ 
#line 3889
T ret; 
#line 3890
tex2DLod(&ret, texObject, x, y, level); 
#line 3891
return ret; 
#line 3892
} 
#endif
#line 3900 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3901
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3910 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 3901 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 3906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 3907
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
#line 3909 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 3910
} 
#endif
#line 3911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3912
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3916
::exit(___);}
#if 0
#line 3912
{ 
#line 3913
int4 tmp; 
#line 3914
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((signed char)(tmp.x)); 
#line 3916
} 
#endif
#line 3918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3919
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3923
::exit(___);}
#if 0
#line 3919
{ 
#line 3920
int4 tmp; 
#line 3921
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char1(tmp.x); 
#line 3923
} 
#endif
#line 3925 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3926
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3930
::exit(___);}
#if 0
#line 3926
{ 
#line 3927
int4 tmp; 
#line 3928
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3930
} 
#endif
#line 3932 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3933
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3937
::exit(___);}
#if 0
#line 3933
{ 
#line 3934
int4 tmp; 
#line 3935
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3937
} 
#endif
#line 3939 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3940
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3944
::exit(___);}
#if 0
#line 3940
{ 
#line 3941
uint4 tmp; 
#line 3942
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 3944
} 
#endif
#line 3946 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3947
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3951
::exit(___);}
#if 0
#line 3947
{ 
#line 3948
uint4 tmp; 
#line 3949
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar1(tmp.x); 
#line 3951
} 
#endif
#line 3953 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3954
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3958
::exit(___);}
#if 0
#line 3954
{ 
#line 3955
uint4 tmp; 
#line 3956
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3958
} 
#endif
#line 3960 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3961
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3965
::exit(___);}
#if 0
#line 3961
{ 
#line 3962
uint4 tmp; 
#line 3963
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3965
} 
#endif
#line 3973 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3974
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3978
::exit(___);}
#if 0
#line 3974
{ 
#line 3975
int4 tmp; 
#line 3976
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((short)(tmp.x)); 
#line 3978
} 
#endif
#line 3980 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3981
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3985
::exit(___);}
#if 0
#line 3981
{ 
#line 3982
int4 tmp; 
#line 3983
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short1(tmp.x); 
#line 3985
} 
#endif
#line 3987 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3988
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3992
::exit(___);}
#if 0
#line 3988
{ 
#line 3989
int4 tmp; 
#line 3990
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3992
} 
#endif
#line 3994 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3995
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3999
::exit(___);}
#if 0
#line 3995
{ 
#line 3996
int4 tmp; 
#line 3997
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3999
} 
#endif
#line 4001 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4002
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4006
::exit(___);}
#if 0
#line 4002
{ 
#line 4003
uint4 tmp; 
#line 4004
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 4006
} 
#endif
#line 4008 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4009
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4013
::exit(___);}
#if 0
#line 4009
{ 
#line 4010
uint4 tmp; 
#line 4011
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort1(tmp.x); 
#line 4013
} 
#endif
#line 4015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4016
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4020
::exit(___);}
#if 0
#line 4016
{ 
#line 4017
uint4 tmp; 
#line 4018
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 4020
} 
#endif
#line 4022 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4023
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4027
::exit(___);}
#if 0
#line 4023
{ 
#line 4024
uint4 tmp; 
#line 4025
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4027
} 
#endif
#line 4035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4036
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4040
::exit(___);}
#if 0
#line 4036
{ 
#line 4037
int4 tmp; 
#line 4038
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4040
} 
#endif
#line 4042 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4043
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4047
::exit(___);}
#if 0
#line 4043
{ 
#line 4044
int4 tmp; 
#line 4045
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int1(tmp.x); 
#line 4047
} 
#endif
#line 4049 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4050
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4054
::exit(___);}
#if 0
#line 4050
{ 
#line 4051
int4 tmp; 
#line 4052
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 4054
} 
#endif
#line 4056 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4057
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4061
::exit(___);}
#if 0
#line 4057
{ 
#line 4058
int4 tmp; 
#line 4059
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4061
} 
#endif
#line 4063 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4064
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4068
::exit(___);}
#if 0
#line 4064
{ 
#line 4065
uint4 tmp; 
#line 4066
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4068
} 
#endif
#line 4070 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4071
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4075
::exit(___);}
#if 0
#line 4071
{ 
#line 4072
uint4 tmp; 
#line 4073
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint1(tmp.x); 
#line 4075
} 
#endif
#line 4077 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4078
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4082
::exit(___);}
#if 0
#line 4078
{ 
#line 4079
uint4 tmp; 
#line 4080
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 4082
} 
#endif
#line 4084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4089
::exit(___);}
#if 0
#line 4085
{ 
#line 4086
uint4 tmp; 
#line 4087
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4089
} 
#endif
#line 4099 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4100
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4104
::exit(___);}
#if 0
#line 4100
{ 
#line 4101
int4 tmp; 
#line 4102
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((long)(tmp.x)); 
#line 4104
} 
#endif
#line 4106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4107
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4111
::exit(___);}
#if 0
#line 4107
{ 
#line 4108
int4 tmp; 
#line 4109
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long1(tmp.x); 
#line 4111
} 
#endif
#line 4113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4114
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4118
::exit(___);}
#if 0
#line 4114
{ 
#line 4115
int4 tmp; 
#line 4116
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 4118
} 
#endif
#line 4120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4121
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4125
::exit(___);}
#if 0
#line 4121
{ 
#line 4122
int4 tmp; 
#line 4123
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4125
} 
#endif
#line 4127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4128
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4132
::exit(___);}
#if 0
#line 4128
{ 
#line 4129
uint4 tmp; 
#line 4130
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 4132
} 
#endif
#line 4134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4135
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4139
::exit(___);}
#if 0
#line 4135
{ 
#line 4136
uint4 tmp; 
#line 4137
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong1(tmp.x); 
#line 4139
} 
#endif
#line 4141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4142
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4146
::exit(___);}
#if 0
#line 4142
{ 
#line 4143
uint4 tmp; 
#line 4144
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 4146
} 
#endif
#line 4148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4153
::exit(___);}
#if 0
#line 4149
{ 
#line 4150
uint4 tmp; 
#line 4151
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4153
} 
#endif
#line 4164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4165
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4169
::exit(___);}
#if 0
#line 4165
{ 
#line 4166
float4 tmp; 
#line 4167
__asm tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4169
} 
#endif
#line 4171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4172
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4176
::exit(___);}
#if 0
#line 4172
{ 
#line 4173
float4 tmp; 
#line 4174
__asm tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float1(tmp.x); 
#line 4176
} 
#endif
#line 4178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4179
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4183
::exit(___);}
#if 0
#line 4179
{ 
#line 4180
float4 tmp; 
#line 4181
__asm tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 4183
} 
#endif
#line 4185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4186
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4190
::exit(___);}
#if 0
#line 4186
{ 
#line 4187
float4 tmp; 
#line 4188
__asm tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4190
} 
#endif
#line 4198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 4199
tex3DLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4200
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4204
::exit(___);}
#if 0
#line 4200
{ 
#line 4201
T ret; 
#line 4202
tex3DLod(&ret, texObject, x, y, z, level); 
#line 4203
return ret; 
#line 4204
} 
#endif
#line 4212 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4213
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4222 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 4213 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 4218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 4219
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
#line 4221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 4222
} 
#endif
#line 4223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4224
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4228
::exit(___);}
#if 0
#line 4224
{ 
#line 4225
int4 tmp; 
#line 4226
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((signed char)(tmp.x)); 
#line 4228
} 
#endif
#line 4230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4231
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4235
::exit(___);}
#if 0
#line 4231
{ 
#line 4232
int4 tmp; 
#line 4233
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_char1(tmp.x); 
#line 4235
} 
#endif
#line 4237 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4238
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4242
::exit(___);}
#if 0
#line 4238
{ 
#line 4239
int4 tmp; 
#line 4240
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 4242
} 
#endif
#line 4244 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4245
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4249
::exit(___);}
#if 0
#line 4245
{ 
#line 4246
int4 tmp; 
#line 4247
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4249
} 
#endif
#line 4251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4252
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4256
::exit(___);}
#if 0
#line 4252
{ 
#line 4253
uint4 tmp; 
#line 4254
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 4256
} 
#endif
#line 4258 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4259
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4263
::exit(___);}
#if 0
#line 4259
{ 
#line 4260
uint4 tmp; 
#line 4261
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uchar1(tmp.x); 
#line 4263
} 
#endif
#line 4265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4266
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4270
::exit(___);}
#if 0
#line 4266
{ 
#line 4267
uint4 tmp; 
#line 4268
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 4270
} 
#endif
#line 4272 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4273
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4277
::exit(___);}
#if 0
#line 4273
{ 
#line 4274
uint4 tmp; 
#line 4275
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4277
} 
#endif
#line 4285 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4286
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4290
::exit(___);}
#if 0
#line 4286
{ 
#line 4287
int4 tmp; 
#line 4288
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((short)(tmp.x)); 
#line 4290
} 
#endif
#line 4292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4293
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4297
::exit(___);}
#if 0
#line 4293
{ 
#line 4294
int4 tmp; 
#line 4295
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_short1(tmp.x); 
#line 4297
} 
#endif
#line 4299 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4300
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4304
::exit(___);}
#if 0
#line 4300
{ 
#line 4301
int4 tmp; 
#line 4302
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 4304
} 
#endif
#line 4306 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4307
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4311
::exit(___);}
#if 0
#line 4307
{ 
#line 4308
int4 tmp; 
#line 4309
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4311
} 
#endif
#line 4313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4314
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4318
::exit(___);}
#if 0
#line 4314
{ 
#line 4315
uint4 tmp; 
#line 4316
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 4318
} 
#endif
#line 4320 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4321
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4325
::exit(___);}
#if 0
#line 4321
{ 
#line 4322
uint4 tmp; 
#line 4323
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ushort1(tmp.x); 
#line 4325
} 
#endif
#line 4327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4328
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4332
::exit(___);}
#if 0
#line 4328
{ 
#line 4329
uint4 tmp; 
#line 4330
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 4332
} 
#endif
#line 4334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4335
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4339
::exit(___);}
#if 0
#line 4335
{ 
#line 4336
uint4 tmp; 
#line 4337
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4339
} 
#endif
#line 4347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4348
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4352
::exit(___);}
#if 0
#line 4348
{ 
#line 4349
int4 tmp; 
#line 4350
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = (tmp.x); 
#line 4352
} 
#endif
#line 4354 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4355
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4359
::exit(___);}
#if 0
#line 4355
{ 
#line 4356
int4 tmp; 
#line 4357
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_int1(tmp.x); 
#line 4359
} 
#endif
#line 4361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4362
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4366
::exit(___);}
#if 0
#line 4362
{ 
#line 4363
int4 tmp; 
#line 4364
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 4366
} 
#endif
#line 4368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4369
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4373
::exit(___);}
#if 0
#line 4369
{ 
#line 4370
int4 tmp; 
#line 4371
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4373
} 
#endif
#line 4375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4376
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4380
::exit(___);}
#if 0
#line 4376
{ 
#line 4377
uint4 tmp; 
#line 4378
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = (tmp.x); 
#line 4380
} 
#endif
#line 4382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4383
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4387
::exit(___);}
#if 0
#line 4383
{ 
#line 4384
uint4 tmp; 
#line 4385
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uint1(tmp.x); 
#line 4387
} 
#endif
#line 4389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4390
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4394
::exit(___);}
#if 0
#line 4390
{ 
#line 4391
uint4 tmp; 
#line 4392
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 4394
} 
#endif
#line 4396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4397
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4401
::exit(___);}
#if 0
#line 4397
{ 
#line 4398
uint4 tmp; 
#line 4399
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4401
} 
#endif
#line 4411 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4412
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4416
::exit(___);}
#if 0
#line 4412
{ 
#line 4413
int4 tmp; 
#line 4414
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((long)(tmp.x)); 
#line 4416
} 
#endif
#line 4418 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4419
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4423
::exit(___);}
#if 0
#line 4419
{ 
#line 4420
int4 tmp; 
#line 4421
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_long1(tmp.x); 
#line 4423
} 
#endif
#line 4425 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4426
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4430
::exit(___);}
#if 0
#line 4426
{ 
#line 4427
int4 tmp; 
#line 4428
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 4430
} 
#endif
#line 4432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4433
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4437
::exit(___);}
#if 0
#line 4433
{ 
#line 4434
int4 tmp; 
#line 4435
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4437
} 
#endif
#line 4439 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4440
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4444
::exit(___);}
#if 0
#line 4440
{ 
#line 4441
uint4 tmp; 
#line 4442
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 4444
} 
#endif
#line 4446 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4447
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4451
::exit(___);}
#if 0
#line 4447
{ 
#line 4448
uint4 tmp; 
#line 4449
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ulong1(tmp.x); 
#line 4451
} 
#endif
#line 4453 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4458
::exit(___);}
#if 0
#line 4454
{ 
#line 4455
uint4 tmp; 
#line 4456
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 4458
} 
#endif
#line 4460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4465
::exit(___);}
#if 0
#line 4461
{ 
#line 4462
uint4 tmp; 
#line 4463
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4465
} 
#endif
#line 4476 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4477
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4481
::exit(___);}
#if 0
#line 4477
{ 
#line 4478
float4 tmp; 
#line 4479
__asm tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = (tmp.x); 
#line 4481
} 
#endif
#line 4483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4484
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4488
::exit(___);}
#if 0
#line 4484
{ 
#line 4485
float4 tmp; 
#line 4486
__asm tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_float1(tmp.x); 
#line 4488
} 
#endif
#line 4490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4491
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4495
::exit(___);}
#if 0
#line 4491
{ 
#line 4492
float4 tmp; 
#line 4493
__asm tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 4495
} 
#endif
#line 4497 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4498
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4502
::exit(___);}
#if 0
#line 4498
{ 
#line 4499
float4 tmp; 
#line 4500
__asm tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4502
} 
#endif
#line 4510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 4511
tex1DLayeredLod(::cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4512
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)level;
#line 4516
::exit(___);}
#if 0
#line 4512
{ 
#line 4513
T ret; 
#line 4514
tex1DLayeredLod(&ret, texObject, x, layer, level); 
#line 4515
return ret; 
#line 4516
} 
#endif
#line 4524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4525
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4534 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 4525 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 4530 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 4531
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
#line 4533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 4534
} 
#endif
#line 4535 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4536
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4540
::exit(___);}
#if 0
#line 4536
{ 
#line 4537
int4 tmp; 
#line 4538
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((signed char)(tmp.x)); 
#line 4540
} 
#endif
#line 4542 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4543
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4547
::exit(___);}
#if 0
#line 4543
{ 
#line 4544
int4 tmp; 
#line 4545
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char1(tmp.x); 
#line 4547
} 
#endif
#line 4549 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4550
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4554
::exit(___);}
#if 0
#line 4550
{ 
#line 4551
int4 tmp; 
#line 4552
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 4554
} 
#endif
#line 4556 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4557
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4561
::exit(___);}
#if 0
#line 4557
{ 
#line 4558
int4 tmp; 
#line 4559
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4561
} 
#endif
#line 4563 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4564
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4568
::exit(___);}
#if 0
#line 4564
{ 
#line 4565
uint4 tmp; 
#line 4566
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 4568
} 
#endif
#line 4570 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4571
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4575
::exit(___);}
#if 0
#line 4571
{ 
#line 4572
uint4 tmp; 
#line 4573
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar1(tmp.x); 
#line 4575
} 
#endif
#line 4577 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4578
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4582
::exit(___);}
#if 0
#line 4578
{ 
#line 4579
uint4 tmp; 
#line 4580
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 4582
} 
#endif
#line 4584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4585
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4589
::exit(___);}
#if 0
#line 4585
{ 
#line 4586
uint4 tmp; 
#line 4587
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4589
} 
#endif
#line 4597 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4598
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4602
::exit(___);}
#if 0
#line 4598
{ 
#line 4599
int4 tmp; 
#line 4600
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((short)(tmp.x)); 
#line 4602
} 
#endif
#line 4604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4605
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4609
::exit(___);}
#if 0
#line 4605
{ 
#line 4606
int4 tmp; 
#line 4607
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short1(tmp.x); 
#line 4609
} 
#endif
#line 4611 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4612
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4616
::exit(___);}
#if 0
#line 4612
{ 
#line 4613
int4 tmp; 
#line 4614
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 4616
} 
#endif
#line 4618 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4619
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4623
::exit(___);}
#if 0
#line 4619
{ 
#line 4620
int4 tmp; 
#line 4621
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4623
} 
#endif
#line 4625 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4626
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4630
::exit(___);}
#if 0
#line 4626
{ 
#line 4627
uint4 tmp; 
#line 4628
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 4630
} 
#endif
#line 4632 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4633
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4637
::exit(___);}
#if 0
#line 4633
{ 
#line 4634
uint4 tmp; 
#line 4635
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort1(tmp.x); 
#line 4637
} 
#endif
#line 4639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4640
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4644
::exit(___);}
#if 0
#line 4640
{ 
#line 4641
uint4 tmp; 
#line 4642
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 4644
} 
#endif
#line 4646 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4647
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4651
::exit(___);}
#if 0
#line 4647
{ 
#line 4648
uint4 tmp; 
#line 4649
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4651
} 
#endif
#line 4659 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4660
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4664
::exit(___);}
#if 0
#line 4660
{ 
#line 4661
int4 tmp; 
#line 4662
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4664
} 
#endif
#line 4666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4667
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4671
::exit(___);}
#if 0
#line 4667
{ 
#line 4668
int4 tmp; 
#line 4669
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int1(tmp.x); 
#line 4671
} 
#endif
#line 4673 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4674
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4678
::exit(___);}
#if 0
#line 4674
{ 
#line 4675
int4 tmp; 
#line 4676
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 4678
} 
#endif
#line 4680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4681
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4685
::exit(___);}
#if 0
#line 4681
{ 
#line 4682
int4 tmp; 
#line 4683
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4685
} 
#endif
#line 4687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4688
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4692
::exit(___);}
#if 0
#line 4688
{ 
#line 4689
uint4 tmp; 
#line 4690
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4692
} 
#endif
#line 4694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4695
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4699
::exit(___);}
#if 0
#line 4695
{ 
#line 4696
uint4 tmp; 
#line 4697
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint1(tmp.x); 
#line 4699
} 
#endif
#line 4701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4702
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4706
::exit(___);}
#if 0
#line 4702
{ 
#line 4703
uint4 tmp; 
#line 4704
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 4706
} 
#endif
#line 4708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4709
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4713
::exit(___);}
#if 0
#line 4709
{ 
#line 4710
uint4 tmp; 
#line 4711
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4713
} 
#endif
#line 4723 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4724
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4728
::exit(___);}
#if 0
#line 4724
{ 
#line 4725
int4 tmp; 
#line 4726
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((long)(tmp.x)); 
#line 4728
} 
#endif
#line 4730 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4731
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4735
::exit(___);}
#if 0
#line 4731
{ 
#line 4732
int4 tmp; 
#line 4733
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long1(tmp.x); 
#line 4735
} 
#endif
#line 4737 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4738
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4742
::exit(___);}
#if 0
#line 4738
{ 
#line 4739
int4 tmp; 
#line 4740
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 4742
} 
#endif
#line 4744 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4745
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4749
::exit(___);}
#if 0
#line 4745
{ 
#line 4746
int4 tmp; 
#line 4747
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4749
} 
#endif
#line 4751 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4752
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4756
::exit(___);}
#if 0
#line 4752
{ 
#line 4753
uint4 tmp; 
#line 4754
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 4756
} 
#endif
#line 4758 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4759
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4763
::exit(___);}
#if 0
#line 4759
{ 
#line 4760
uint4 tmp; 
#line 4761
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong1(tmp.x); 
#line 4763
} 
#endif
#line 4765 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4766
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4770
::exit(___);}
#if 0
#line 4766
{ 
#line 4767
uint4 tmp; 
#line 4768
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 4770
} 
#endif
#line 4772 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4777
::exit(___);}
#if 0
#line 4773
{ 
#line 4774
uint4 tmp; 
#line 4775
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4777
} 
#endif
#line 4788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4789
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4793
::exit(___);}
#if 0
#line 4789
{ 
#line 4790
float4 tmp; 
#line 4791
__asm tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4793
} 
#endif
#line 4795 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4796
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4800
::exit(___);}
#if 0
#line 4796
{ 
#line 4797
float4 tmp; 
#line 4798
__asm tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float1(tmp.x); 
#line 4800
} 
#endif
#line 4802 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4803
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4807
::exit(___);}
#if 0
#line 4803
{ 
#line 4804
float4 tmp; 
#line 4805
__asm tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 4807
} 
#endif
#line 4809 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4810
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4814
::exit(___);}
#if 0
#line 4810
{ 
#line 4811
float4 tmp; 
#line 4812
__asm tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4814
} 
#endif
#line 4822 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 4823
tex2DLayeredLod(::cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4824
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4828
::exit(___);}
#if 0
#line 4824
{ 
#line 4825
T ret; 
#line 4826
tex2DLayeredLod(&ret, texObject, x, y, layer, level); 
#line 4827
return ret; 
#line 4828
} 
#endif
#line 4836 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4837
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4846 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 4837 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 4842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 4843
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
#line 4845 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 4846
} 
#endif
#line 4847 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4848
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4852
::exit(___);}
#if 0
#line 4848
{ 
#line 4849
int4 tmp; 
#line 4850
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((signed char)(tmp.x)); 
#line 4852
} 
#endif
#line 4854 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4855
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4859
::exit(___);}
#if 0
#line 4855
{ 
#line 4856
int4 tmp; 
#line 4857
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char1(tmp.x); 
#line 4859
} 
#endif
#line 4861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4862
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4866
::exit(___);}
#if 0
#line 4862
{ 
#line 4863
int4 tmp; 
#line 4864
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 4866
} 
#endif
#line 4868 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4869
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4873
::exit(___);}
#if 0
#line 4869
{ 
#line 4870
int4 tmp; 
#line 4871
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4873
} 
#endif
#line 4875 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4876
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4880
::exit(___);}
#if 0
#line 4876
{ 
#line 4877
uint4 tmp; 
#line 4878
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 4880
} 
#endif
#line 4882 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4883
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4887
::exit(___);}
#if 0
#line 4883
{ 
#line 4884
uint4 tmp; 
#line 4885
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar1(tmp.x); 
#line 4887
} 
#endif
#line 4889 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4890
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4894
::exit(___);}
#if 0
#line 4890
{ 
#line 4891
uint4 tmp; 
#line 4892
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 4894
} 
#endif
#line 4896 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4897
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4901
::exit(___);}
#if 0
#line 4897
{ 
#line 4898
uint4 tmp; 
#line 4899
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4901
} 
#endif
#line 4909 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4910
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4914
::exit(___);}
#if 0
#line 4910
{ 
#line 4911
int4 tmp; 
#line 4912
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((short)(tmp.x)); 
#line 4914
} 
#endif
#line 4916 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4917
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4921
::exit(___);}
#if 0
#line 4917
{ 
#line 4918
int4 tmp; 
#line 4919
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short1(tmp.x); 
#line 4921
} 
#endif
#line 4923 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4924
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4928
::exit(___);}
#if 0
#line 4924
{ 
#line 4925
int4 tmp; 
#line 4926
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 4928
} 
#endif
#line 4930 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4931
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4935
::exit(___);}
#if 0
#line 4931
{ 
#line 4932
int4 tmp; 
#line 4933
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4935
} 
#endif
#line 4937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4938
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4942
::exit(___);}
#if 0
#line 4938
{ 
#line 4939
uint4 tmp; 
#line 4940
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 4942
} 
#endif
#line 4944 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4945
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4949
::exit(___);}
#if 0
#line 4945
{ 
#line 4946
uint4 tmp; 
#line 4947
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort1(tmp.x); 
#line 4949
} 
#endif
#line 4951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4952
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4956
::exit(___);}
#if 0
#line 4952
{ 
#line 4953
uint4 tmp; 
#line 4954
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 4956
} 
#endif
#line 4958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4959
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4963
::exit(___);}
#if 0
#line 4959
{ 
#line 4960
uint4 tmp; 
#line 4961
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4963
} 
#endif
#line 4971 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4972
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4976
::exit(___);}
#if 0
#line 4972
{ 
#line 4973
int4 tmp; 
#line 4974
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4976
} 
#endif
#line 4978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4979
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4983
::exit(___);}
#if 0
#line 4979
{ 
#line 4980
int4 tmp; 
#line 4981
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int1(tmp.x); 
#line 4983
} 
#endif
#line 4985 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4986
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4990
::exit(___);}
#if 0
#line 4986
{ 
#line 4987
int4 tmp; 
#line 4988
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 4990
} 
#endif
#line 4992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4993
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4997
::exit(___);}
#if 0
#line 4993
{ 
#line 4994
int4 tmp; 
#line 4995
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4997
} 
#endif
#line 4999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5000
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5004
::exit(___);}
#if 0
#line 5000
{ 
#line 5001
uint4 tmp; 
#line 5002
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 5004
} 
#endif
#line 5006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5007
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5011
::exit(___);}
#if 0
#line 5007
{ 
#line 5008
uint4 tmp; 
#line 5009
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint1(tmp.x); 
#line 5011
} 
#endif
#line 5013 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5014
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5018
::exit(___);}
#if 0
#line 5014
{ 
#line 5015
uint4 tmp; 
#line 5016
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 5018
} 
#endif
#line 5020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5021
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5025
::exit(___);}
#if 0
#line 5021
{ 
#line 5022
uint4 tmp; 
#line 5023
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5025
} 
#endif
#line 5035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5036
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5040
::exit(___);}
#if 0
#line 5036
{ 
#line 5037
int4 tmp; 
#line 5038
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((long)(tmp.x)); 
#line 5040
} 
#endif
#line 5042 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5043
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5047
::exit(___);}
#if 0
#line 5043
{ 
#line 5044
int4 tmp; 
#line 5045
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long1(tmp.x); 
#line 5047
} 
#endif
#line 5049 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5050
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5054
::exit(___);}
#if 0
#line 5050
{ 
#line 5051
int4 tmp; 
#line 5052
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 5054
} 
#endif
#line 5056 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5057
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5061
::exit(___);}
#if 0
#line 5057
{ 
#line 5058
int4 tmp; 
#line 5059
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5061
} 
#endif
#line 5063 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5064
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5068
::exit(___);}
#if 0
#line 5064
{ 
#line 5065
uint4 tmp; 
#line 5066
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 5068
} 
#endif
#line 5070 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5071
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5075
::exit(___);}
#if 0
#line 5071
{ 
#line 5072
uint4 tmp; 
#line 5073
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong1(tmp.x); 
#line 5075
} 
#endif
#line 5077 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5078
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5082
::exit(___);}
#if 0
#line 5078
{ 
#line 5079
uint4 tmp; 
#line 5080
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 5082
} 
#endif
#line 5084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5089
::exit(___);}
#if 0
#line 5085
{ 
#line 5086
uint4 tmp; 
#line 5087
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5089
} 
#endif
#line 5100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5101
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5105
::exit(___);}
#if 0
#line 5101
{ 
#line 5102
float4 tmp; 
#line 5103
__asm tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 5105
} 
#endif
#line 5107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5108
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5112
::exit(___);}
#if 0
#line 5108
{ 
#line 5109
float4 tmp; 
#line 5110
__asm tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float1(tmp.x); 
#line 5112
} 
#endif
#line 5114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5115
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5119
::exit(___);}
#if 0
#line 5115
{ 
#line 5116
float4 tmp; 
#line 5117
__asm tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 5119
} 
#endif
#line 5121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5122
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5126
::exit(___);}
#if 0
#line 5122
{ 
#line 5123
float4 tmp; 
#line 5124
__asm tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5126
} 
#endif
#line 5134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 5135
texCubemapLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5136
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5140
::exit(___);}
#if 0
#line 5136
{ 
#line 5137
T ret; 
#line 5138
texCubemapLod(&ret, texObject, x, y, z, level); 
#line 5139
return ret; 
#line 5140
} 
#endif
#line 5148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5158 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 5149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 5154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 5155
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
#line 5157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 5158
} 
#endif
#line 5159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5160
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5164
::exit(___);}
#if 0
#line 5160
{ 
#line 5161
int4 tmp; 
#line 5162
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = ((signed char)(tmp.x)); 
#line 5164
} 
#endif
#line 5166 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5167
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5171
::exit(___);}
#if 0
#line 5167
{ 
#line 5168
int4 tmp; 
#line 5169
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_char1(tmp.x); 
#line 5171
} 
#endif
#line 5173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5174
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5178
::exit(___);}
#if 0
#line 5174
{ 
#line 5175
int4 tmp; 
#line 5176
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 5178
} 
#endif
#line 5180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5181
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5185
::exit(___);}
#if 0
#line 5181
{ 
#line 5182
int4 tmp; 
#line 5183
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5185
} 
#endif
#line 5187 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5188
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5192
::exit(___);}
#if 0
#line 5188
{ 
#line 5189
uint4 tmp; 
#line 5190
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 5192
} 
#endif
#line 5194 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5195
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5199
::exit(___);}
#if 0
#line 5195
{ 
#line 5196
uint4 tmp; 
#line 5197
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_uchar1(tmp.x); 
#line 5199
} 
#endif
#line 5201 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5202
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5206
::exit(___);}
#if 0
#line 5202
{ 
#line 5203
uint4 tmp; 
#line 5204
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 5206
} 
#endif
#line 5208 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5209
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5213
::exit(___);}
#if 0
#line 5209
{ 
#line 5210
uint4 tmp; 
#line 5211
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5213
} 
#endif
#line 5221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5222
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5226
::exit(___);}
#if 0
#line 5222
{ 
#line 5223
int4 tmp; 
#line 5224
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = ((short)(tmp.x)); 
#line 5226
} 
#endif
#line 5228 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5229
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5233
::exit(___);}
#if 0
#line 5229
{ 
#line 5230
int4 tmp; 
#line 5231
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_short1(tmp.x); 
#line 5233
} 
#endif
#line 5235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5236
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5240
::exit(___);}
#if 0
#line 5236
{ 
#line 5237
int4 tmp; 
#line 5238
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 5240
} 
#endif
#line 5242 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5243
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5247
::exit(___);}
#if 0
#line 5243
{ 
#line 5244
int4 tmp; 
#line 5245
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5247
} 
#endif
#line 5249 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5250
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5254
::exit(___);}
#if 0
#line 5250
{ 
#line 5251
uint4 tmp; 
#line 5252
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 5254
} 
#endif
#line 5256 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5257
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5261
::exit(___);}
#if 0
#line 5257
{ 
#line 5258
uint4 tmp; 
#line 5259
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_ushort1(tmp.x); 
#line 5261
} 
#endif
#line 5263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5264
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5268
::exit(___);}
#if 0
#line 5264
{ 
#line 5265
uint4 tmp; 
#line 5266
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 5268
} 
#endif
#line 5270 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5271
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5275
::exit(___);}
#if 0
#line 5271
{ 
#line 5272
uint4 tmp; 
#line 5273
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5275
} 
#endif
#line 5283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5284
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5288
::exit(___);}
#if 0
#line 5284
{ 
#line 5285
int4 tmp; 
#line 5286
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = (tmp.x); 
#line 5288
} 
#endif
#line 5290 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5291
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5295
::exit(___);}
#if 0
#line 5291
{ 
#line 5292
int4 tmp; 
#line 5293
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_int1(tmp.x); 
#line 5295
} 
#endif
#line 5297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5298
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5302
::exit(___);}
#if 0
#line 5298
{ 
#line 5299
int4 tmp; 
#line 5300
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 5302
} 
#endif
#line 5304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5305
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5309
::exit(___);}
#if 0
#line 5305
{ 
#line 5306
int4 tmp; 
#line 5307
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5309
} 
#endif
#line 5311 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5312
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5316
::exit(___);}
#if 0
#line 5312
{ 
#line 5313
uint4 tmp; 
#line 5314
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = (tmp.x); 
#line 5316
} 
#endif
#line 5318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5319
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5323
::exit(___);}
#if 0
#line 5319
{ 
#line 5320
uint4 tmp; 
#line 5321
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_uint1(tmp.x); 
#line 5323
} 
#endif
#line 5325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5326
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5330
::exit(___);}
#if 0
#line 5326
{ 
#line 5327
uint4 tmp; 
#line 5328
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 5330
} 
#endif
#line 5332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5333
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5337
::exit(___);}
#if 0
#line 5333
{ 
#line 5334
uint4 tmp; 
#line 5335
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5337
} 
#endif
#line 5347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5348
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5352
::exit(___);}
#if 0
#line 5348
{ 
#line 5349
int4 tmp; 
#line 5350
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = ((long)(tmp.x)); 
#line 5352
} 
#endif
#line 5354 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5355
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5359
::exit(___);}
#if 0
#line 5355
{ 
#line 5356
int4 tmp; 
#line 5357
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_long1(tmp.x); 
#line 5359
} 
#endif
#line 5361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5362
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5366
::exit(___);}
#if 0
#line 5362
{ 
#line 5363
int4 tmp; 
#line 5364
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 5366
} 
#endif
#line 5368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5369
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5373
::exit(___);}
#if 0
#line 5369
{ 
#line 5370
int4 tmp; 
#line 5371
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5373
} 
#endif
#line 5375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5376
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5380
::exit(___);}
#if 0
#line 5376
{ 
#line 5377
uint4 tmp; 
#line 5378
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 5380
} 
#endif
#line 5382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5383
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5387
::exit(___);}
#if 0
#line 5383
{ 
#line 5384
uint4 tmp; 
#line 5385
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_ulong1(tmp.x); 
#line 5387
} 
#endif
#line 5389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5390
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5394
::exit(___);}
#if 0
#line 5390
{ 
#line 5391
uint4 tmp; 
#line 5392
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 5394
} 
#endif
#line 5396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5397
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5401
::exit(___);}
#if 0
#line 5397
{ 
#line 5398
uint4 tmp; 
#line 5399
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5401
} 
#endif
#line 5412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5413
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5417
::exit(___);}
#if 0
#line 5413
{ 
#line 5414
float4 tmp; 
#line 5415
__asm tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = (tmp.x); 
#line 5417
} 
#endif
#line 5419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5420
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5424
::exit(___);}
#if 0
#line 5420
{ 
#line 5421
float4 tmp; 
#line 5422
__asm tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_float1(tmp.x); 
#line 5424
} 
#endif
#line 5426 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5427
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5431
::exit(___);}
#if 0
#line 5427
{ 
#line 5428
float4 tmp; 
#line 5429
__asm tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 5431
} 
#endif
#line 5433 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5434
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5438
::exit(___);}
#if 0
#line 5434
{ 
#line 5435
float4 tmp; 
#line 5436
__asm tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5438
} 
#endif
#line 5446 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 5447
texCubemapLayeredLod(::cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5448
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5452
::exit(___);}
#if 0
#line 5448
{ 
#line 5449
T ret; 
#line 5450
texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level); 
#line 5451
return ret; 
#line 5452
} 
#endif
#line 5460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5470 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 5461 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 5466 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 5467
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
#line 5469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 5470
} 
#endif
#line 5471 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5472
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5476
::exit(___);}
#if 0
#line 5472
{ 
#line 5473
int4 tmp; 
#line 5474
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = ((signed char)(tmp.x)); 
#line 5476
} 
#endif
#line 5478 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5479
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5483
::exit(___);}
#if 0
#line 5479
{ 
#line 5480
int4 tmp; 
#line 5481
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_char1(tmp.x); 
#line 5483
} 
#endif
#line 5485 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5486
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5490
::exit(___);}
#if 0
#line 5486
{ 
#line 5487
int4 tmp; 
#line 5488
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 5490
} 
#endif
#line 5492 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5493
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5497
::exit(___);}
#if 0
#line 5493
{ 
#line 5494
int4 tmp; 
#line 5495
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5497
} 
#endif
#line 5499 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5500
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5504
::exit(___);}
#if 0
#line 5500
{ 
#line 5501
uint4 tmp; 
#line 5502
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = ((unsigned char)(tmp.x)); 
#line 5504
} 
#endif
#line 5506 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5507
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5511
::exit(___);}
#if 0
#line 5507
{ 
#line 5508
uint4 tmp; 
#line 5509
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_uchar1(tmp.x); 
#line 5511
} 
#endif
#line 5513 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5514
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5518
::exit(___);}
#if 0
#line 5514
{ 
#line 5515
uint4 tmp; 
#line 5516
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 5518
} 
#endif
#line 5520 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5521
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5525
::exit(___);}
#if 0
#line 5521
{ 
#line 5522
uint4 tmp; 
#line 5523
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5525
} 
#endif
#line 5533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5534
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5538
::exit(___);}
#if 0
#line 5534
{ 
#line 5535
int4 tmp; 
#line 5536
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = ((short)(tmp.x)); 
#line 5538
} 
#endif
#line 5540 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5541
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5545
::exit(___);}
#if 0
#line 5541
{ 
#line 5542
int4 tmp; 
#line 5543
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_short1(tmp.x); 
#line 5545
} 
#endif
#line 5547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5548
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5552
::exit(___);}
#if 0
#line 5548
{ 
#line 5549
int4 tmp; 
#line 5550
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 5552
} 
#endif
#line 5554 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5555
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5559
::exit(___);}
#if 0
#line 5555
{ 
#line 5556
int4 tmp; 
#line 5557
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5559
} 
#endif
#line 5561 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5562
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5566
::exit(___);}
#if 0
#line 5562
{ 
#line 5563
uint4 tmp; 
#line 5564
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = ((unsigned short)(tmp.x)); 
#line 5566
} 
#endif
#line 5568 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5569
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5573
::exit(___);}
#if 0
#line 5569
{ 
#line 5570
uint4 tmp; 
#line 5571
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_ushort1(tmp.x); 
#line 5573
} 
#endif
#line 5575 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5576
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5580
::exit(___);}
#if 0
#line 5576
{ 
#line 5577
uint4 tmp; 
#line 5578
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 5580
} 
#endif
#line 5582 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5583
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5587
::exit(___);}
#if 0
#line 5583
{ 
#line 5584
uint4 tmp; 
#line 5585
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5587
} 
#endif
#line 5595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(int *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5596
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5600
::exit(___);}
#if 0
#line 5596
{ 
#line 5597
int4 tmp; 
#line 5598
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = (tmp.x); 
#line 5600
} 
#endif
#line 5602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5603
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5607
::exit(___);}
#if 0
#line 5603
{ 
#line 5604
int4 tmp; 
#line 5605
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_int1(tmp.x); 
#line 5607
} 
#endif
#line 5609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5610
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5614
::exit(___);}
#if 0
#line 5610
{ 
#line 5611
int4 tmp; 
#line 5612
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 5614
} 
#endif
#line 5616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5617
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5621
::exit(___);}
#if 0
#line 5617
{ 
#line 5618
int4 tmp; 
#line 5619
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5621
} 
#endif
#line 5623 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5624
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5628
::exit(___);}
#if 0
#line 5624
{ 
#line 5625
uint4 tmp; 
#line 5626
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = (tmp.x); 
#line 5628
} 
#endif
#line 5630 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5631
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5635
::exit(___);}
#if 0
#line 5631
{ 
#line 5632
uint4 tmp; 
#line 5633
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_uint1(tmp.x); 
#line 5635
} 
#endif
#line 5637 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5638
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5642
::exit(___);}
#if 0
#line 5638
{ 
#line 5639
uint4 tmp; 
#line 5640
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 5642
} 
#endif
#line 5644 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5645
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5649
::exit(___);}
#if 0
#line 5645
{ 
#line 5646
uint4 tmp; 
#line 5647
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5649
} 
#endif
#line 5659 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(long *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5660
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5664
::exit(___);}
#if 0
#line 5660
{ 
#line 5661
int4 tmp; 
#line 5662
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = ((long)(tmp.x)); 
#line 5664
} 
#endif
#line 5666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5667
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5671
::exit(___);}
#if 0
#line 5667
{ 
#line 5668
int4 tmp; 
#line 5669
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_long1(tmp.x); 
#line 5671
} 
#endif
#line 5673 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5674
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5678
::exit(___);}
#if 0
#line 5674
{ 
#line 5675
int4 tmp; 
#line 5676
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 5678
} 
#endif
#line 5680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5681
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5685
::exit(___);}
#if 0
#line 5681
{ 
#line 5682
int4 tmp; 
#line 5683
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5685
} 
#endif
#line 5687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5688
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5692
::exit(___);}
#if 0
#line 5688
{ 
#line 5689
uint4 tmp; 
#line 5690
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = ((unsigned long)(tmp.x)); 
#line 5692
} 
#endif
#line 5694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5695
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5699
::exit(___);}
#if 0
#line 5695
{ 
#line 5696
uint4 tmp; 
#line 5697
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_ulong1(tmp.x); 
#line 5699
} 
#endif
#line 5701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5702
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5706
::exit(___);}
#if 0
#line 5702
{ 
#line 5703
uint4 tmp; 
#line 5704
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 5706
} 
#endif
#line 5708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5709
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5713
::exit(___);}
#if 0
#line 5709
{ 
#line 5710
uint4 tmp; 
#line 5711
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5713
} 
#endif
#line 5724 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(float *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5725
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5729
::exit(___);}
#if 0
#line 5725
{ 
#line 5726
float4 tmp; 
#line 5727
__asm tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = (tmp.x); 
#line 5729
} 
#endif
#line 5731 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5732
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5736
::exit(___);}
#if 0
#line 5732
{ 
#line 5733
float4 tmp; 
#line 5734
__asm tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_float1(tmp.x); 
#line 5736
} 
#endif
#line 5738 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5739
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5743
::exit(___);}
#if 0
#line 5739
{ 
#line 5740
float4 tmp; 
#line 5741
__asm tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 5743
} 
#endif
#line 5745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5746
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5750
::exit(___);}
#if 0
#line 5746
{ 
#line 5747
float4 tmp; 
#line 5748
__asm tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5750
} 
#endif
#line 5758 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 5759
tex1DGrad(::cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5760
{int volatile ___ = 1;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5764
::exit(___);}
#if 0
#line 5760
{ 
#line 5761
T ret; 
#line 5762
tex1DGrad(&ret, texObject, x, dPdx, dPdy); 
#line 5763
return ret; 
#line 5764
} 
#endif
#line 5772 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5782 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 5773 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 5778 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 5779
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
#line 5781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 5782
} 
#endif
#line 5783 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5784
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5788
::exit(___);}
#if 0
#line 5784
{ 
#line 5785
int4 tmp; 
#line 5786
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = ((signed char)(tmp.x)); 
#line 5788
} 
#endif
#line 5790 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5791
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5795
::exit(___);}
#if 0
#line 5791
{ 
#line 5792
int4 tmp; 
#line 5793
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_char1(tmp.x); 
#line 5795
} 
#endif
#line 5797 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5798
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5802
::exit(___);}
#if 0
#line 5798
{ 
#line 5799
int4 tmp; 
#line 5800
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 5802
} 
#endif
#line 5804 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5805
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5809
::exit(___);}
#if 0
#line 5805
{ 
#line 5806
int4 tmp; 
#line 5807
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5809
} 
#endif
#line 5811 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5812
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5816
::exit(___);}
#if 0
#line 5812
{ 
#line 5813
uint4 tmp; 
#line 5814
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = ((unsigned char)(tmp.x)); 
#line 5816
} 
#endif
#line 5818 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5819
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5823
::exit(___);}
#if 0
#line 5819
{ 
#line 5820
uint4 tmp; 
#line 5821
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_uchar1(tmp.x); 
#line 5823
} 
#endif
#line 5825 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5826
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5830
::exit(___);}
#if 0
#line 5826
{ 
#line 5827
uint4 tmp; 
#line 5828
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 5830
} 
#endif
#line 5832 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5833
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5837
::exit(___);}
#if 0
#line 5833
{ 
#line 5834
uint4 tmp; 
#line 5835
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5837
} 
#endif
#line 5845 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5846
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5850
::exit(___);}
#if 0
#line 5846
{ 
#line 5847
int4 tmp; 
#line 5848
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = ((short)(tmp.x)); 
#line 5850
} 
#endif
#line 5852 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5853
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5857
::exit(___);}
#if 0
#line 5853
{ 
#line 5854
int4 tmp; 
#line 5855
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_short1(tmp.x); 
#line 5857
} 
#endif
#line 5859 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5860
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5864
::exit(___);}
#if 0
#line 5860
{ 
#line 5861
int4 tmp; 
#line 5862
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 5864
} 
#endif
#line 5866 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5867
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5871
::exit(___);}
#if 0
#line 5867
{ 
#line 5868
int4 tmp; 
#line 5869
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5871
} 
#endif
#line 5873 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5874
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5878
::exit(___);}
#if 0
#line 5874
{ 
#line 5875
uint4 tmp; 
#line 5876
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = ((unsigned short)(tmp.x)); 
#line 5878
} 
#endif
#line 5880 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5881
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5885
::exit(___);}
#if 0
#line 5881
{ 
#line 5882
uint4 tmp; 
#line 5883
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_ushort1(tmp.x); 
#line 5885
} 
#endif
#line 5887 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5888
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5892
::exit(___);}
#if 0
#line 5888
{ 
#line 5889
uint4 tmp; 
#line 5890
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 5892
} 
#endif
#line 5894 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5895
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5899
::exit(___);}
#if 0
#line 5895
{ 
#line 5896
uint4 tmp; 
#line 5897
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5899
} 
#endif
#line 5907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5908
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5912
::exit(___);}
#if 0
#line 5908
{ 
#line 5909
int4 tmp; 
#line 5910
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = (tmp.x); 
#line 5912
} 
#endif
#line 5914 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5915
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5919
::exit(___);}
#if 0
#line 5915
{ 
#line 5916
int4 tmp; 
#line 5917
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_int1(tmp.x); 
#line 5919
} 
#endif
#line 5921 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5922
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5926
::exit(___);}
#if 0
#line 5922
{ 
#line 5923
int4 tmp; 
#line 5924
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 5926
} 
#endif
#line 5928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5929
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5933
::exit(___);}
#if 0
#line 5929
{ 
#line 5930
int4 tmp; 
#line 5931
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5933
} 
#endif
#line 5935 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5936
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5940
::exit(___);}
#if 0
#line 5936
{ 
#line 5937
uint4 tmp; 
#line 5938
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = (tmp.x); 
#line 5940
} 
#endif
#line 5942 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5943
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5947
::exit(___);}
#if 0
#line 5943
{ 
#line 5944
uint4 tmp; 
#line 5945
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_uint1(tmp.x); 
#line 5947
} 
#endif
#line 5949 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5950
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5954
::exit(___);}
#if 0
#line 5950
{ 
#line 5951
uint4 tmp; 
#line 5952
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 5954
} 
#endif
#line 5956 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5957
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5961
::exit(___);}
#if 0
#line 5957
{ 
#line 5958
uint4 tmp; 
#line 5959
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5961
} 
#endif
#line 5971 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5972
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5976
::exit(___);}
#if 0
#line 5972
{ 
#line 5973
int4 tmp; 
#line 5974
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = ((long)(tmp.x)); 
#line 5976
} 
#endif
#line 5978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5979
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5983
::exit(___);}
#if 0
#line 5979
{ 
#line 5980
int4 tmp; 
#line 5981
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_long1(tmp.x); 
#line 5983
} 
#endif
#line 5985 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5986
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5990
::exit(___);}
#if 0
#line 5986
{ 
#line 5987
int4 tmp; 
#line 5988
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 5990
} 
#endif
#line 5992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5993
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5997
::exit(___);}
#if 0
#line 5993
{ 
#line 5994
int4 tmp; 
#line 5995
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5997
} 
#endif
#line 5999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6000
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6004
::exit(___);}
#if 0
#line 6000
{ 
#line 6001
uint4 tmp; 
#line 6002
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = ((unsigned long)(tmp.x)); 
#line 6004
} 
#endif
#line 6006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6007
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6011
::exit(___);}
#if 0
#line 6007
{ 
#line 6008
uint4 tmp; 
#line 6009
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_ulong1(tmp.x); 
#line 6011
} 
#endif
#line 6013 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6014
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6018
::exit(___);}
#if 0
#line 6014
{ 
#line 6015
uint4 tmp; 
#line 6016
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 6018
} 
#endif
#line 6020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6021
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6025
::exit(___);}
#if 0
#line 6021
{ 
#line 6022
uint4 tmp; 
#line 6023
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6025
} 
#endif
#line 6036 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6037
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6041
::exit(___);}
#if 0
#line 6037
{ 
#line 6038
float4 tmp; 
#line 6039
__asm tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = (tmp.x); 
#line 6041
} 
#endif
#line 6043 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6044
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6048
::exit(___);}
#if 0
#line 6044
{ 
#line 6045
float4 tmp; 
#line 6046
__asm tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_float1(tmp.x); 
#line 6048
} 
#endif
#line 6050 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6051
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6055
::exit(___);}
#if 0
#line 6051
{ 
#line 6052
float4 tmp; 
#line 6053
__asm tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 6055
} 
#endif
#line 6057 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6058
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6062
::exit(___);}
#if 0
#line 6058
{ 
#line 6059
float4 tmp; 
#line 6060
__asm tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6062
} 
#endif
#line 6070 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 6071
tex2DGrad(::cudaTextureObject_t texObject, float x, float y, ::float2 dPdx, ::float2 dPdy) 
#line 6072
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6076
::exit(___);}
#if 0
#line 6072
{ 
#line 6073
T ret; 
#line 6074
tex2DGrad(&ret, texObject, x, y, dPdx, dPdy); 
#line 6075
return ret; 
#line 6076
} 
#endif
#line 6084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 6085 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 6090 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 6091
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
#line 6093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 6094
} 
#endif
#line 6095 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6096
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6100
::exit(___);}
#if 0
#line 6096
{ 
#line 6097
int4 tmp; 
#line 6098
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = ((signed char)(tmp.x)); 
#line 6100
} 
#endif
#line 6102 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6103
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6107
::exit(___);}
#if 0
#line 6103
{ 
#line 6104
int4 tmp; 
#line 6105
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_char1(tmp.x); 
#line 6107
} 
#endif
#line 6109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6110
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6114
::exit(___);}
#if 0
#line 6110
{ 
#line 6111
int4 tmp; 
#line 6112
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 6114
} 
#endif
#line 6116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6117
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6121
::exit(___);}
#if 0
#line 6117
{ 
#line 6118
int4 tmp; 
#line 6119
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6121
} 
#endif
#line 6123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6124
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6128
::exit(___);}
#if 0
#line 6124
{ 
#line 6125
uint4 tmp; 
#line 6126
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = ((unsigned char)(tmp.x)); 
#line 6128
} 
#endif
#line 6130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6131
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6135
::exit(___);}
#if 0
#line 6131
{ 
#line 6132
uint4 tmp; 
#line 6133
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_uchar1(tmp.x); 
#line 6135
} 
#endif
#line 6137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6138
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6142
::exit(___);}
#if 0
#line 6138
{ 
#line 6139
uint4 tmp; 
#line 6140
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 6142
} 
#endif
#line 6144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6145
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6149
::exit(___);}
#if 0
#line 6145
{ 
#line 6146
uint4 tmp; 
#line 6147
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6149
} 
#endif
#line 6157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6158
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6162
::exit(___);}
#if 0
#line 6158
{ 
#line 6159
int4 tmp; 
#line 6160
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = ((short)(tmp.x)); 
#line 6162
} 
#endif
#line 6164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6165
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6169
::exit(___);}
#if 0
#line 6165
{ 
#line 6166
int4 tmp; 
#line 6167
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_short1(tmp.x); 
#line 6169
} 
#endif
#line 6171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6172
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6176
::exit(___);}
#if 0
#line 6172
{ 
#line 6173
int4 tmp; 
#line 6174
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 6176
} 
#endif
#line 6178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6179
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6183
::exit(___);}
#if 0
#line 6179
{ 
#line 6180
int4 tmp; 
#line 6181
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6183
} 
#endif
#line 6185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6186
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6190
::exit(___);}
#if 0
#line 6186
{ 
#line 6187
uint4 tmp; 
#line 6188
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = ((unsigned short)(tmp.x)); 
#line 6190
} 
#endif
#line 6192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6193
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6197
::exit(___);}
#if 0
#line 6193
{ 
#line 6194
uint4 tmp; 
#line 6195
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_ushort1(tmp.x); 
#line 6197
} 
#endif
#line 6199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6200
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6204
::exit(___);}
#if 0
#line 6200
{ 
#line 6201
uint4 tmp; 
#line 6202
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 6204
} 
#endif
#line 6206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6207
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6211
::exit(___);}
#if 0
#line 6207
{ 
#line 6208
uint4 tmp; 
#line 6209
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6211
} 
#endif
#line 6219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6220
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6224
::exit(___);}
#if 0
#line 6220
{ 
#line 6221
int4 tmp; 
#line 6222
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = (tmp.x); 
#line 6224
} 
#endif
#line 6226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6227
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6231
::exit(___);}
#if 0
#line 6227
{ 
#line 6228
int4 tmp; 
#line 6229
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_int1(tmp.x); 
#line 6231
} 
#endif
#line 6233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6234
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6238
::exit(___);}
#if 0
#line 6234
{ 
#line 6235
int4 tmp; 
#line 6236
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 6238
} 
#endif
#line 6240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6241
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6245
::exit(___);}
#if 0
#line 6241
{ 
#line 6242
int4 tmp; 
#line 6243
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6245
} 
#endif
#line 6247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6248
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6252
::exit(___);}
#if 0
#line 6248
{ 
#line 6249
uint4 tmp; 
#line 6250
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = (tmp.x); 
#line 6252
} 
#endif
#line 6254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6259
::exit(___);}
#if 0
#line 6255
{ 
#line 6256
uint4 tmp; 
#line 6257
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_uint1(tmp.x); 
#line 6259
} 
#endif
#line 6261 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6262
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6266
::exit(___);}
#if 0
#line 6262
{ 
#line 6263
uint4 tmp; 
#line 6264
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 6266
} 
#endif
#line 6268 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6269
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6273
::exit(___);}
#if 0
#line 6269
{ 
#line 6270
uint4 tmp; 
#line 6271
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6273
} 
#endif
#line 6283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6284
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6288
::exit(___);}
#if 0
#line 6284
{ 
#line 6285
int4 tmp; 
#line 6286
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = ((long)(tmp.x)); 
#line 6288
} 
#endif
#line 6290 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6291
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6295
::exit(___);}
#if 0
#line 6291
{ 
#line 6292
int4 tmp; 
#line 6293
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_long1(tmp.x); 
#line 6295
} 
#endif
#line 6297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6298
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6302
::exit(___);}
#if 0
#line 6298
{ 
#line 6299
int4 tmp; 
#line 6300
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 6302
} 
#endif
#line 6304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6305
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6309
::exit(___);}
#if 0
#line 6305
{ 
#line 6306
int4 tmp; 
#line 6307
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6309
} 
#endif
#line 6311 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6312
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6316
::exit(___);}
#if 0
#line 6312
{ 
#line 6313
uint4 tmp; 
#line 6314
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = ((unsigned long)(tmp.x)); 
#line 6316
} 
#endif
#line 6318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6319
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6323
::exit(___);}
#if 0
#line 6319
{ 
#line 6320
uint4 tmp; 
#line 6321
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_ulong1(tmp.x); 
#line 6323
} 
#endif
#line 6325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6326
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6330
::exit(___);}
#if 0
#line 6326
{ 
#line 6327
uint4 tmp; 
#line 6328
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 6330
} 
#endif
#line 6332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6333
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6337
::exit(___);}
#if 0
#line 6333
{ 
#line 6334
uint4 tmp; 
#line 6335
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6337
} 
#endif
#line 6348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6349
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6353
::exit(___);}
#if 0
#line 6349
{ 
#line 6350
float4 tmp; 
#line 6351
__asm tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = (tmp.x); 
#line 6353
} 
#endif
#line 6355 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6356
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6360
::exit(___);}
#if 0
#line 6356
{ 
#line 6357
float4 tmp; 
#line 6358
__asm tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_float1(tmp.x); 
#line 6360
} 
#endif
#line 6362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6363
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6367
::exit(___);}
#if 0
#line 6363
{ 
#line 6364
float4 tmp; 
#line 6365
__asm tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 6367
} 
#endif
#line 6369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6370
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6374
::exit(___);}
#if 0
#line 6370
{ 
#line 6371
float4 tmp; 
#line 6372
__asm tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6374
} 
#endif
#line 6382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 6383
tex3DGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) 
#line 6384
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6388
::exit(___);}
#if 0
#line 6384
{ 
#line 6385
T ret; 
#line 6386
tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy); 
#line 6387
return ret; 
#line 6388
} 
#endif
#line 6396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6397
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6406 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 6397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 6402 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 6403
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
#line 6405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 6406
} 
#endif
#line 6407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6408
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6412
::exit(___);}
#if 0
#line 6408
{ 
#line 6409
int4 tmp; 
#line 6410
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = ((signed char)(tmp.x)); 
#line 6412
} 
#endif
#line 6414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6415
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6419
::exit(___);}
#if 0
#line 6415
{ 
#line 6416
int4 tmp; 
#line 6417
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_char1(tmp.x); 
#line 6419
} 
#endif
#line 6421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6422
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6426
::exit(___);}
#if 0
#line 6422
{ 
#line 6423
int4 tmp; 
#line 6424
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 6426
} 
#endif
#line 6428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6429
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6433
::exit(___);}
#if 0
#line 6429
{ 
#line 6430
int4 tmp; 
#line 6431
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6433
} 
#endif
#line 6435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6436
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6440
::exit(___);}
#if 0
#line 6436
{ 
#line 6437
uint4 tmp; 
#line 6438
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = ((unsigned char)(tmp.x)); 
#line 6440
} 
#endif
#line 6442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6443
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6447
::exit(___);}
#if 0
#line 6443
{ 
#line 6444
uint4 tmp; 
#line 6445
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_uchar1(tmp.x); 
#line 6447
} 
#endif
#line 6449 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6450
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6454
::exit(___);}
#if 0
#line 6450
{ 
#line 6451
uint4 tmp; 
#line 6452
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 6454
} 
#endif
#line 6456 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6457
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6461
::exit(___);}
#if 0
#line 6457
{ 
#line 6458
uint4 tmp; 
#line 6459
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6461
} 
#endif
#line 6469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6470
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6474
::exit(___);}
#if 0
#line 6470
{ 
#line 6471
int4 tmp; 
#line 6472
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = ((short)(tmp.x)); 
#line 6474
} 
#endif
#line 6476 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6477
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6481
::exit(___);}
#if 0
#line 6477
{ 
#line 6478
int4 tmp; 
#line 6479
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_short1(tmp.x); 
#line 6481
} 
#endif
#line 6483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6484
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6488
::exit(___);}
#if 0
#line 6484
{ 
#line 6485
int4 tmp; 
#line 6486
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 6488
} 
#endif
#line 6490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6491
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6495
::exit(___);}
#if 0
#line 6491
{ 
#line 6492
int4 tmp; 
#line 6493
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6495
} 
#endif
#line 6497 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6498
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6502
::exit(___);}
#if 0
#line 6498
{ 
#line 6499
uint4 tmp; 
#line 6500
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = ((unsigned short)(tmp.x)); 
#line 6502
} 
#endif
#line 6504 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6505
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6509
::exit(___);}
#if 0
#line 6505
{ 
#line 6506
uint4 tmp; 
#line 6507
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_ushort1(tmp.x); 
#line 6509
} 
#endif
#line 6511 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6512
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6516
::exit(___);}
#if 0
#line 6512
{ 
#line 6513
uint4 tmp; 
#line 6514
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 6516
} 
#endif
#line 6518 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6519
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6523
::exit(___);}
#if 0
#line 6519
{ 
#line 6520
uint4 tmp; 
#line 6521
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6523
} 
#endif
#line 6531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6536
::exit(___);}
#if 0
#line 6532
{ 
#line 6533
int4 tmp; 
#line 6534
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = (tmp.x); 
#line 6536
} 
#endif
#line 6538 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6539
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6543
::exit(___);}
#if 0
#line 6539
{ 
#line 6540
int4 tmp; 
#line 6541
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_int1(tmp.x); 
#line 6543
} 
#endif
#line 6545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6546
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6550
::exit(___);}
#if 0
#line 6546
{ 
#line 6547
int4 tmp; 
#line 6548
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 6550
} 
#endif
#line 6552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6553
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6557
::exit(___);}
#if 0
#line 6553
{ 
#line 6554
int4 tmp; 
#line 6555
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6557
} 
#endif
#line 6559 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6560
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6564
::exit(___);}
#if 0
#line 6560
{ 
#line 6561
uint4 tmp; 
#line 6562
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = (tmp.x); 
#line 6564
} 
#endif
#line 6566 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6567
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6571
::exit(___);}
#if 0
#line 6567
{ 
#line 6568
uint4 tmp; 
#line 6569
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_uint1(tmp.x); 
#line 6571
} 
#endif
#line 6573 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6574
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6578
::exit(___);}
#if 0
#line 6574
{ 
#line 6575
uint4 tmp; 
#line 6576
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 6578
} 
#endif
#line 6580 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6581
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6585
::exit(___);}
#if 0
#line 6581
{ 
#line 6582
uint4 tmp; 
#line 6583
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6585
} 
#endif
#line 6595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(long *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6596
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6600
::exit(___);}
#if 0
#line 6596
{ 
#line 6597
int4 tmp; 
#line 6598
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = ((long)(tmp.x)); 
#line 6600
} 
#endif
#line 6602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(long1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6603
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6607
::exit(___);}
#if 0
#line 6603
{ 
#line 6604
int4 tmp; 
#line 6605
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_long1(tmp.x); 
#line 6607
} 
#endif
#line 6609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(long2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6610
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6614
::exit(___);}
#if 0
#line 6610
{ 
#line 6611
int4 tmp; 
#line 6612
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 6614
} 
#endif
#line 6616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(long4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6617
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6621
::exit(___);}
#if 0
#line 6617
{ 
#line 6618
int4 tmp; 
#line 6619
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6621
} 
#endif
#line 6623 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6624
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6628
::exit(___);}
#if 0
#line 6624
{ 
#line 6625
uint4 tmp; 
#line 6626
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = ((unsigned long)(tmp.x)); 
#line 6628
} 
#endif
#line 6630 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6631
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6635
::exit(___);}
#if 0
#line 6631
{ 
#line 6632
uint4 tmp; 
#line 6633
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_ulong1(tmp.x); 
#line 6635
} 
#endif
#line 6637 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6638
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6642
::exit(___);}
#if 0
#line 6638
{ 
#line 6639
uint4 tmp; 
#line 6640
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 6642
} 
#endif
#line 6644 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6645
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6649
::exit(___);}
#if 0
#line 6645
{ 
#line 6646
uint4 tmp; 
#line 6647
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6649
} 
#endif
#line 6660 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6661
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6665
::exit(___);}
#if 0
#line 6661
{ 
#line 6662
float4 tmp; 
#line 6663
__asm tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = (tmp.x); 
#line 6665
} 
#endif
#line 6667 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6668
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6672
::exit(___);}
#if 0
#line 6668
{ 
#line 6669
float4 tmp; 
#line 6670
__asm tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_float1(tmp.x); 
#line 6672
} 
#endif
#line 6674 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6675
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6679
::exit(___);}
#if 0
#line 6675
{ 
#line 6676
float4 tmp; 
#line 6677
__asm tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 6679
} 
#endif
#line 6681 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6682
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6686
::exit(___);}
#if 0
#line 6682
{ 
#line 6683
float4 tmp; 
#line 6684
__asm tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6686
} 
#endif
#line 6694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 6695
tex1DLayeredGrad(::cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6696
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6700
::exit(___);}
#if 0
#line 6696
{ 
#line 6697
T ret; 
#line 6698
tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy); 
#line 6699
return ret; 
#line 6700
} 
#endif
#line 6708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6709
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6718 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 6709 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
{ 
#line 6714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 6715
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
#line 6717 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 6718
} 
#endif
#line 6719 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6720
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6724
::exit(___);}
#if 0
#line 6720
{ 
#line 6721
int4 tmp; 
#line 6722
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = ((signed char)(tmp.x)); 
#line 6724
} 
#endif
#line 6726 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6727
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6731
::exit(___);}
#if 0
#line 6727
{ 
#line 6728
int4 tmp; 
#line 6729
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_char1(tmp.x); 
#line 6731
} 
#endif
#line 6733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6734
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6738
::exit(___);}
#if 0
#line 6734
{ 
#line 6735
int4 tmp; 
#line 6736
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 6738
} 
#endif
#line 6740 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6741
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6745
::exit(___);}
#if 0
#line 6741
{ 
#line 6742
int4 tmp; 
#line 6743
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6745
} 
#endif
#line 6747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6748
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6752
::exit(___);}
#if 0
#line 6748
{ 
#line 6749
uint4 tmp; 
#line 6750
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = ((unsigned char)(tmp.x)); 
#line 6752
} 
#endif
#line 6754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6755
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6759
::exit(___);}
#if 0
#line 6755
{ 
#line 6756
uint4 tmp; 
#line 6757
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_uchar1(tmp.x); 
#line 6759
} 
#endif
#line 6761 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6762
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6766
::exit(___);}
#if 0
#line 6762
{ 
#line 6763
uint4 tmp; 
#line 6764
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 6766
} 
#endif
#line 6768 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6769
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6773
::exit(___);}
#if 0
#line 6769
{ 
#line 6770
uint4 tmp; 
#line 6771
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6773
} 
#endif
#line 6781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6782
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6786
::exit(___);}
#if 0
#line 6782
{ 
#line 6783
int4 tmp; 
#line 6784
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = ((short)(tmp.x)); 
#line 6786
} 
#endif
#line 6788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6789
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6793
::exit(___);}
#if 0
#line 6789
{ 
#line 6790
int4 tmp; 
#line 6791
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_short1(tmp.x); 
#line 6793
} 
#endif
#line 6795 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6796
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6800
::exit(___);}
#if 0
#line 6796
{ 
#line 6797
int4 tmp; 
#line 6798
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 6800
} 
#endif
#line 6802 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6803
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6807
::exit(___);}
#if 0
#line 6803
{ 
#line 6804
int4 tmp; 
#line 6805
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6807
} 
#endif
#line 6809 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6810
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6814
::exit(___);}
#if 0
#line 6810
{ 
#line 6811
uint4 tmp; 
#line 6812
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = ((unsigned short)(tmp.x)); 
#line 6814
} 
#endif
#line 6816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6817
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6821
::exit(___);}
#if 0
#line 6817
{ 
#line 6818
uint4 tmp; 
#line 6819
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_ushort1(tmp.x); 
#line 6821
} 
#endif
#line 6823 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6824
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6828
::exit(___);}
#if 0
#line 6824
{ 
#line 6825
uint4 tmp; 
#line 6826
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 6828
} 
#endif
#line 6830 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6831
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6835
::exit(___);}
#if 0
#line 6831
{ 
#line 6832
uint4 tmp; 
#line 6833
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6835
} 
#endif
#line 6843 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6844
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6848
::exit(___);}
#if 0
#line 6844
{ 
#line 6845
int4 tmp; 
#line 6846
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = (tmp.x); 
#line 6848
} 
#endif
#line 6850 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6851
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6855
::exit(___);}
#if 0
#line 6851
{ 
#line 6852
int4 tmp; 
#line 6853
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_int1(tmp.x); 
#line 6855
} 
#endif
#line 6857 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6858
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6862
::exit(___);}
#if 0
#line 6858
{ 
#line 6859
int4 tmp; 
#line 6860
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 6862
} 
#endif
#line 6864 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6865
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6869
::exit(___);}
#if 0
#line 6865
{ 
#line 6866
int4 tmp; 
#line 6867
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6869
} 
#endif
#line 6871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6872
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6876
::exit(___);}
#if 0
#line 6872
{ 
#line 6873
uint4 tmp; 
#line 6874
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = (tmp.x); 
#line 6876
} 
#endif
#line 6878 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6879
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6883
::exit(___);}
#if 0
#line 6879
{ 
#line 6880
uint4 tmp; 
#line 6881
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_uint1(tmp.x); 
#line 6883
} 
#endif
#line 6885 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6886
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6890
::exit(___);}
#if 0
#line 6886
{ 
#line 6887
uint4 tmp; 
#line 6888
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 6890
} 
#endif
#line 6892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6893
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6897
::exit(___);}
#if 0
#line 6893
{ 
#line 6894
uint4 tmp; 
#line 6895
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6897
} 
#endif
#line 6907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6908
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6912
::exit(___);}
#if 0
#line 6908
{ 
#line 6909
int4 tmp; 
#line 6910
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = ((long)(tmp.x)); 
#line 6912
} 
#endif
#line 6914 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6915
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6919
::exit(___);}
#if 0
#line 6915
{ 
#line 6916
int4 tmp; 
#line 6917
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_long1(tmp.x); 
#line 6919
} 
#endif
#line 6921 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6922
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6926
::exit(___);}
#if 0
#line 6922
{ 
#line 6923
int4 tmp; 
#line 6924
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 6926
} 
#endif
#line 6928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6929
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6933
::exit(___);}
#if 0
#line 6929
{ 
#line 6930
int4 tmp; 
#line 6931
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6933
} 
#endif
#line 6935 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6936
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6940
::exit(___);}
#if 0
#line 6936
{ 
#line 6937
uint4 tmp; 
#line 6938
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = ((unsigned long)(tmp.x)); 
#line 6940
} 
#endif
#line 6942 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6943
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6947
::exit(___);}
#if 0
#line 6943
{ 
#line 6944
uint4 tmp; 
#line 6945
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_ulong1(tmp.x); 
#line 6947
} 
#endif
#line 6949 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6950
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6954
::exit(___);}
#if 0
#line 6950
{ 
#line 6951
uint4 tmp; 
#line 6952
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 6954
} 
#endif
#line 6956 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6957
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6961
::exit(___);}
#if 0
#line 6957
{ 
#line 6958
uint4 tmp; 
#line 6959
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6961
} 
#endif
#line 6972 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6973
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6977
::exit(___);}
#if 0
#line 6973
{ 
#line 6974
float4 tmp; 
#line 6975
__asm tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = (tmp.x); 
#line 6977
} 
#endif
#line 6979 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6980
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6984
::exit(___);}
#if 0
#line 6980
{ 
#line 6981
float4 tmp; 
#line 6982
__asm tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_float1(tmp.x); 
#line 6984
} 
#endif
#line 6986 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6987
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6991
::exit(___);}
#if 0
#line 6987
{ 
#line 6988
float4 tmp; 
#line 6989
__asm tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 6991
} 
#endif
#line 6993 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6994
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6998
::exit(___);}
#if 0
#line 6994
{ 
#line 6995
float4 tmp; 
#line 6996
__asm tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6998
} 
#endif
#line 7006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 7007
tex2DLayeredGrad(::cudaTextureObject_t texObject, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) 
#line 7008
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 7012
::exit(___);}
#if 0
#line 7008
{ 
#line 7009
T ret; 
#line 7010
tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy); 
#line 7011
return ret; 
#line 7012
} 
#endif
#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 71
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 83
::exit(___);}
#if 0
#line 71
{ 
#line 72
int tmp; 
#line 73
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 74
__asm suld.b.1d.b8.trap  {%0}, [%1, {%2}];
} else { 
#line 76
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 77
__asm suld.b.1d.b8.clamp {%0}, [%1, {%2}];
} else { 
#line 79
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 80
__asm suld.b.1d.b8.zero  {%0}, [%1, {%2}];
}  }  }  
#line 82
(*retVal) = ((char)tmp); 
#line 83
} 
#endif
#line 85 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 86
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 98
::exit(___);}
#if 0
#line 86
{ 
#line 87
int tmp; 
#line 88
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 89
__asm suld.b.1d.b8.trap  {%0}, [%1, {%2}];
} else { 
#line 91
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 92
__asm suld.b.1d.b8.clamp {%0}, [%1, {%2}];
} else { 
#line 94
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 95
__asm suld.b.1d.b8.zero  {%0}, [%1, {%2}];
}  }  }  
#line 97
(*retVal) = ((signed char)tmp); 
#line 98
} 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 101
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 113
::exit(___);}
#if 0
#line 101
{ 
#line 102
int1 tmp; 
#line 103
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 104
__asm suld.b.1d.b8.trap  {%0}, [%1, {%2}];
} else { 
#line 106
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 107
__asm suld.b.1d.b8.clamp {%0}, [%1, {%2}];
} else { 
#line 109
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 110
__asm suld.b.1d.b8.zero  {%0}, [%1, {%2}];
}  }  }  
#line 112
(*retVal) = make_char1(tmp.x); 
#line 113
} 
#endif
#line 115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 116
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 128
::exit(___);}
#if 0
#line 116
{ 
#line 117
unsigned tmp; 
#line 118
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 119
__asm suld.b.1d.b8.trap  {%0}, [%1, {%2}];
} else { 
#line 121
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 122
__asm suld.b.1d.b8.clamp {%0}, [%1, {%2}];
} else { 
#line 124
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 125
__asm suld.b.1d.b8.zero  {%0}, [%1, {%2}];
}  }  }  
#line 127
(*retVal) = ((unsigned char)tmp); 
#line 128
} 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 131
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 143
::exit(___);}
#if 0
#line 131
{ 
#line 132
uint1 tmp; 
#line 133
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 134
__asm suld.b.1d.b8.trap  {%0}, [%1, {%2}];
} else { 
#line 136
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 137
__asm suld.b.1d.b8.clamp {%0}, [%1, {%2}];
} else { 
#line 139
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 140
__asm suld.b.1d.b8.zero  {%0}, [%1, {%2}];
}  }  }  
#line 142
(*retVal) = make_uchar1(tmp.x); 
#line 143
} 
#endif
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 146
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 158
::exit(___);}
#if 0
#line 146
{ 
#line 147
short tmp; 
#line 148
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 149
__asm suld.b.1d.b16.trap  {%0}, [%1, {%2}];
} else { 
#line 151
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 152
__asm suld.b.1d.b16.clamp {%0}, [%1, {%2}];
} else { 
#line 154
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 155
__asm suld.b.1d.b16.zero  {%0}, [%1, {%2}];
}  }  }  
#line 157
(*retVal) = tmp; 
#line 158
} 
#endif
#line 160 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 161
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 173
::exit(___);}
#if 0
#line 161
{ 
#line 162
short1 tmp; 
#line 163
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 164
__asm suld.b.1d.b16.trap  {%0}, [%1, {%2}];
} else { 
#line 166
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 167
__asm suld.b.1d.b16.clamp {%0}, [%1, {%2}];
} else { 
#line 169
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 170
__asm suld.b.1d.b16.zero  {%0}, [%1, {%2}];
}  }  }  
#line 172
(*retVal) = make_short1(tmp.x); 
#line 173
} 
#endif
#line 175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 176
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 188
::exit(___);}
#if 0
#line 176
{ 
#line 177
unsigned short tmp; 
#line 178
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 179
__asm suld.b.1d.b16.trap  {%0}, [%1, {%2}];
} else { 
#line 181
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 182
__asm suld.b.1d.b16.clamp {%0}, [%1, {%2}];
} else { 
#line 184
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 185
__asm suld.b.1d.b16.zero  {%0}, [%1, {%2}];
}  }  }  
#line 187
(*retVal) = tmp; 
#line 188
} 
#endif
#line 190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 191
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 203
::exit(___);}
#if 0
#line 191
{ 
#line 192
ushort1 tmp; 
#line 193
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 194
__asm suld.b.1d.b16.trap  {%0}, [%1, {%2}];
} else { 
#line 196
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 197
__asm suld.b.1d.b16.clamp {%0}, [%1, {%2}];
} else { 
#line 199
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 200
__asm suld.b.1d.b16.zero  {%0}, [%1, {%2}];
}  }  }  
#line 202
(*retVal) = make_ushort1(tmp.x); 
#line 203
} 
#endif
#line 205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 206
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 218
::exit(___);}
#if 0
#line 206
{ 
#line 207
int tmp; 
#line 208
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 209
__asm suld.b.1d.b32.trap  {%0}, [%1, {%2}];
} else { 
#line 211
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 212
__asm suld.b.1d.b32.clamp {%0}, [%1, {%2}];
} else { 
#line 214
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 215
__asm suld.b.1d.b32.zero  {%0}, [%1, {%2}];
}  }  }  
#line 217
(*retVal) = tmp; 
#line 218
} 
#endif
#line 220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 221
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 233
::exit(___);}
#if 0
#line 221
{ 
#line 222
int1 tmp; 
#line 223
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 224
__asm suld.b.1d.b32.trap  {%0}, [%1, {%2}];
} else { 
#line 226
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 227
__asm suld.b.1d.b32.clamp {%0}, [%1, {%2}];
} else { 
#line 229
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 230
__asm suld.b.1d.b32.zero  {%0}, [%1, {%2}];
}  }  }  
#line 232
(*retVal) = make_int1(tmp.x); 
#line 233
} 
#endif
#line 235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 236
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 248
::exit(___);}
#if 0
#line 236
{ 
#line 237
unsigned tmp; 
#line 238
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 239
__asm suld.b.1d.b32.trap  {%0}, [%1, {%2}];
} else { 
#line 241
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 242
__asm suld.b.1d.b32.clamp {%0}, [%1, {%2}];
} else { 
#line 244
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 245
__asm suld.b.1d.b32.zero  {%0}, [%1, {%2}];
}  }  }  
#line 247
(*retVal) = tmp; 
#line 248
} 
#endif
#line 250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 251
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 263
::exit(___);}
#if 0
#line 251
{ 
#line 252
uint1 tmp; 
#line 253
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 254
__asm suld.b.1d.b32.trap  {%0}, [%1, {%2}];
} else { 
#line 256
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 257
__asm suld.b.1d.b32.clamp {%0}, [%1, {%2}];
} else { 
#line 259
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 260
__asm suld.b.1d.b32.zero  {%0}, [%1, {%2}];
}  }  }  
#line 262
(*retVal) = make_uint1(tmp.x); 
#line 263
} 
#endif
#line 265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 266
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 278
::exit(___);}
#if 0
#line 266
{ 
#line 267
__int64 tmp; 
#line 268
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 269
__asm suld.b.1d.b64.trap  {%0}, [%1, {%2}];
} else { 
#line 271
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 272
__asm suld.b.1d.b64.clamp {%0}, [%1, {%2}];
} else { 
#line 274
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 275
__asm suld.b.1d.b64.zero  {%0}, [%1, {%2}];
}  }  }  
#line 277
(*retVal) = tmp; 
#line 278
} 
#endif
#line 280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 281
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 293
::exit(___);}
#if 0
#line 281
{ 
#line 282
longlong1 tmp; 
#line 283
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 284
__asm suld.b.1d.b64.trap  {%0}, [%1, {%2}];
} else { 
#line 286
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 287
__asm suld.b.1d.b64.clamp {%0}, [%1, {%2}];
} else { 
#line 289
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 290
__asm suld.b.1d.b64.zero  {%0}, [%1, {%2}];
}  }  }  
#line 292
(*retVal) = make_longlong1(tmp.x); 
#line 293
} 
#endif
#line 295 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 296
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 308
::exit(___);}
#if 0
#line 296
{ 
#line 297
unsigned __int64 tmp; 
#line 298
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 299
__asm suld.b.1d.b64.trap  {%0}, [%1, {%2}];
} else { 
#line 301
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 302
__asm suld.b.1d.b64.clamp {%0}, [%1, {%2}];
} else { 
#line 304
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 305
__asm suld.b.1d.b64.zero  {%0}, [%1, {%2}];
}  }  }  
#line 307
(*retVal) = tmp; 
#line 308
} 
#endif
#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 311
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 323
::exit(___);}
#if 0
#line 311
{ 
#line 312
ulonglong1 tmp; 
#line 313
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 314
__asm suld.b.1d.b64.trap  {%0}, [%1, {%2}];
} else { 
#line 316
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 317
__asm suld.b.1d.b64.clamp {%0}, [%1, {%2}];
} else { 
#line 319
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 320
__asm suld.b.1d.b64.zero  {%0}, [%1, {%2}];
}  }  }  
#line 322
(*retVal) = make_ulonglong1(tmp.x); 
#line 323
} 
#endif
#line 325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 326
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 338
::exit(___);}
#if 0
#line 326
{ 
#line 327
float tmp; 
#line 328
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 329
__asm suld.b.1d.b32.trap  {%0}, [%1, {%2}];
} else { 
#line 331
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 332
__asm suld.b.1d.b32.clamp {%0}, [%1, {%2}];
} else { 
#line 334
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 335
__asm suld.b.1d.b32.zero  {%0}, [%1, {%2}];
}  }  }  
#line 337
(*retVal) = tmp; 
#line 338
} 
#endif
#line 340 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 341
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 353
::exit(___);}
#if 0
#line 341
{ 
#line 342
float1 tmp; 
#line 343
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 344
__asm suld.b.1d.b32.trap  {%0}, [%1, {%2}];
} else { 
#line 346
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 347
__asm suld.b.1d.b32.clamp {%0}, [%1, {%2}];
} else { 
#line 349
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 350
__asm suld.b.1d.b32.zero  {%0}, [%1, {%2}];
}  }  }  
#line 352
(*retVal) = make_float1(tmp.x); 
#line 353
} 
#endif
#line 361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 362
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 374
::exit(___);}
#if 0
#line 362
{ 
#line 363
int2 tmp; 
#line 364
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 365
__asm suld.b.1d.v2.b8.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 367
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 368
__asm suld.b.1d.v2.b8.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 370
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 371
__asm suld.b.1d.v2.b8.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 373
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 374
} 
#endif
#line 376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 377
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 389
::exit(___);}
#if 0
#line 377
{ 
#line 378
uint2 tmp; 
#line 379
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 380
__asm suld.b.1d.v2.b8.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 382
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 383
__asm suld.b.1d.v2.b8.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 385
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 386
__asm suld.b.1d.v2.b8.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 388
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 389
} 
#endif
#line 391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 392
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 404
::exit(___);}
#if 0
#line 392
{ 
#line 393
short2 tmp; 
#line 394
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 395
__asm suld.b.1d.v2.b16.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 397
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 398
__asm suld.b.1d.v2.b16.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 400
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 401
__asm suld.b.1d.v2.b16.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 403
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 404
} 
#endif
#line 406 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 407
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 419
::exit(___);}
#if 0
#line 407
{ 
#line 408
ushort2 tmp; 
#line 409
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 410
__asm suld.b.1d.v2.b16.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 412
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 413
__asm suld.b.1d.v2.b16.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 415
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 416
__asm suld.b.1d.v2.b16.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 418
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 419
} 
#endif
#line 421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 422
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 434
::exit(___);}
#if 0
#line 422
{ 
#line 423
int2 tmp; 
#line 424
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 425
__asm suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 427
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 428
__asm suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 430
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 431
__asm suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 433
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 434
} 
#endif
#line 436 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 437
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 449
::exit(___);}
#if 0
#line 437
{ 
#line 438
uint2 tmp; 
#line 439
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 440
__asm suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 442
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 443
__asm suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 445
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 446
__asm suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 448
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 449
} 
#endif
#line 451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 452
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 464
::exit(___);}
#if 0
#line 452
{ 
#line 453
longlong2 tmp; 
#line 454
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 455
__asm suld.b.1d.v2.b64.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 457
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 458
__asm suld.b.1d.v2.b64.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 460
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 461
__asm suld.b.1d.v2.b64.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 463
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 464
} 
#endif
#line 466 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 467
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 479
::exit(___);}
#if 0
#line 467
{ 
#line 468
ulonglong2 tmp; 
#line 469
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 470
__asm suld.b.1d.v2.b64.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 472
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 473
__asm suld.b.1d.v2.b64.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 475
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 476
__asm suld.b.1d.v2.b64.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 478
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 479
} 
#endif
#line 481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 482
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 494
::exit(___);}
#if 0
#line 482
{ 
#line 483
float2 tmp; 
#line 484
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 485
__asm suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 487
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 488
__asm suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 490
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 491
__asm suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 493
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 494
} 
#endif
#line 502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 503
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 515
::exit(___);}
#if 0
#line 503
{ 
#line 504
int4 tmp; 
#line 505
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 506
__asm suld.b.1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 508
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 509
__asm suld.b.1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 511
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 512
__asm suld.b.1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 514
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 515
} 
#endif
#line 517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 518
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 530
::exit(___);}
#if 0
#line 518
{ 
#line 519
uint4 tmp; 
#line 520
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 521
__asm suld.b.1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 523
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 524
__asm suld.b.1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 526
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 527
__asm suld.b.1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 529
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 530
} 
#endif
#line 532 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 533
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 545
::exit(___);}
#if 0
#line 533
{ 
#line 534
short4 tmp; 
#line 535
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 536
__asm suld.b.1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 538
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 539
__asm suld.b.1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 541
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 542
__asm suld.b.1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 544
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 545
} 
#endif
#line 547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 548
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 560
::exit(___);}
#if 0
#line 548
{ 
#line 549
ushort4 tmp; 
#line 550
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 551
__asm suld.b.1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 553
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 554
__asm suld.b.1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 556
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 557
__asm suld.b.1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 559
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 560
} 
#endif
#line 562 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 563
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 575
::exit(___);}
#if 0
#line 563
{ 
#line 564
int4 tmp; 
#line 565
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 566
__asm suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 568
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 569
__asm suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 571
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 572
__asm suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 574
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 575
} 
#endif
#line 577 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 578
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 590
::exit(___);}
#if 0
#line 578
{ 
#line 579
uint4 tmp; 
#line 580
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 581
__asm suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 583
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 584
__asm suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 586
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 587
__asm suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 589
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 590
} 
#endif
#line 592 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 593
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 605
::exit(___);}
#if 0
#line 593
{ 
#line 594
float4 tmp; 
#line 595
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 596
__asm suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 598
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 599
__asm suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 601
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 602
__asm suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 604
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 605
} 
#endif
#line 613 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 614
surf1Dread(::cudaSurfaceObject_t surfObject, int x, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 615
{int volatile ___ = 1;(void)surfObject;(void)x;(void)boundaryMode;
#line 619
::exit(___);}
#if 0
#line 615
{ 
#line 616
T ret; 
#line 617
surf1Dread(&ret, surfObject, x, boundaryMode); 
#line 618
return ret; 
#line 619
} 
#endif
#line 627 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 628
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 640
::exit(___);}
#if 0
#line 628
{ 
#line 629
int tmp; 
#line 630
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 631
__asm suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 633
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 634
__asm suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 636
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 637
__asm suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 639
(*retVal) = ((char)tmp); 
#line 640
} 
#endif
#line 642 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 643
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 655
::exit(___);}
#if 0
#line 643
{ 
#line 644
int tmp; 
#line 645
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 646
__asm suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 648
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 649
__asm suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 651
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 652
__asm suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 654
(*retVal) = ((signed char)tmp); 
#line 655
} 
#endif
#line 657 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 658
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 670
::exit(___);}
#if 0
#line 658
{ 
#line 659
int1 tmp; 
#line 660
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 661
__asm suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 663
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 664
__asm suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 666
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 667
__asm suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 669
(*retVal) = make_char1(tmp.x); 
#line 670
} 
#endif
#line 672 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 673
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 685
::exit(___);}
#if 0
#line 673
{ 
#line 674
unsigned tmp; 
#line 675
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 676
__asm suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 678
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 679
__asm suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 681
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 682
__asm suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 684
(*retVal) = ((unsigned char)tmp); 
#line 685
} 
#endif
#line 687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 688
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 700
::exit(___);}
#if 0
#line 688
{ 
#line 689
uint1 tmp; 
#line 690
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 691
__asm suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 693
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 694
__asm suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 696
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 697
__asm suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 699
(*retVal) = make_uchar1(tmp.x); 
#line 700
} 
#endif
#line 702 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 703
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 715
::exit(___);}
#if 0
#line 703
{ 
#line 704
short tmp; 
#line 705
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 706
__asm suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 708
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 709
__asm suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 711
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 712
__asm suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 714
(*retVal) = tmp; 
#line 715
} 
#endif
#line 717 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 718
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 730
::exit(___);}
#if 0
#line 718
{ 
#line 719
short1 tmp; 
#line 720
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 721
__asm suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 723
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 724
__asm suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 726
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 727
__asm suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 729
(*retVal) = make_short1(tmp.x); 
#line 730
} 
#endif
#line 732 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 733
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 745
::exit(___);}
#if 0
#line 733
{ 
#line 734
unsigned short tmp; 
#line 735
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 736
__asm suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 738
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 739
__asm suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 741
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 742
__asm suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 744
(*retVal) = tmp; 
#line 745
} 
#endif
#line 747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 748
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 760
::exit(___);}
#if 0
#line 748
{ 
#line 749
ushort1 tmp; 
#line 750
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 751
__asm suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 753
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 754
__asm suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 756
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 757
__asm suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 759
(*retVal) = make_ushort1(tmp.x); 
#line 760
} 
#endif
#line 762 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 763
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 775
::exit(___);}
#if 0
#line 763
{ 
#line 764
int tmp; 
#line 765
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 766
__asm suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 768
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 769
__asm suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 771
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 772
__asm suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 774
(*retVal) = tmp; 
#line 775
} 
#endif
#line 777 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 778
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 790
::exit(___);}
#if 0
#line 778
{ 
#line 779
int1 tmp; 
#line 780
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 781
__asm suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 783
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 784
__asm suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 786
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 787
__asm suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 789
(*retVal) = make_int1(tmp.x); 
#line 790
} 
#endif
#line 792 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 793
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 805
::exit(___);}
#if 0
#line 793
{ 
#line 794
unsigned tmp; 
#line 795
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 796
__asm suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 798
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 799
__asm suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 801
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 802
__asm suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 804
(*retVal) = tmp; 
#line 805
} 
#endif
#line 807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 808
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 820
::exit(___);}
#if 0
#line 808
{ 
#line 809
uint1 tmp; 
#line 810
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 811
__asm suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 813
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 814
__asm suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 816
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 817
__asm suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 819
(*retVal) = make_uint1(tmp.x); 
#line 820
} 
#endif
#line 822 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 823
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 835
::exit(___);}
#if 0
#line 823
{ 
#line 824
__int64 tmp; 
#line 825
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 826
__asm suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 828
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 829
__asm suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 831
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 832
__asm suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 834
(*retVal) = tmp; 
#line 835
} 
#endif
#line 837 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 838
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 850
::exit(___);}
#if 0
#line 838
{ 
#line 839
longlong1 tmp; 
#line 840
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 841
__asm suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 843
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 844
__asm suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 846
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 847
__asm suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 849
(*retVal) = make_longlong1(tmp.x); 
#line 850
} 
#endif
#line 852 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 853
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 865
::exit(___);}
#if 0
#line 853
{ 
#line 854
unsigned __int64 tmp; 
#line 855
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 856
__asm suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 858
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 859
__asm suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 861
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 862
__asm suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 864
(*retVal) = tmp; 
#line 865
} 
#endif
#line 867 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 868
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 880
::exit(___);}
#if 0
#line 868
{ 
#line 869
ulonglong1 tmp; 
#line 870
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 871
__asm suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 873
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 874
__asm suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 876
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 877
__asm suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 879
(*retVal) = make_ulonglong1(tmp.x); 
#line 880
} 
#endif
#line 882 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 883
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 895
::exit(___);}
#if 0
#line 883
{ 
#line 884
float tmp; 
#line 885
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 886
__asm suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 888
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 889
__asm suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 891
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 892
__asm suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 894
(*retVal) = tmp; 
#line 895
} 
#endif
#line 897 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 898
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 910
::exit(___);}
#if 0
#line 898
{ 
#line 899
float1 tmp; 
#line 900
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 901
__asm suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 903
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 904
__asm suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 906
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 907
__asm suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 909
(*retVal) = make_float1(tmp.x); 
#line 910
} 
#endif
#line 918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 919
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 931
::exit(___);}
#if 0
#line 919
{ 
#line 920
int2 tmp; 
#line 921
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 922
__asm suld.b.2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 924
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 925
__asm suld.b.2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 927
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 928
__asm suld.b.2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 930
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 931
} 
#endif
#line 933 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 934
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 946
::exit(___);}
#if 0
#line 934
{ 
#line 935
uint2 tmp; 
#line 936
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 937
__asm suld.b.2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 939
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 940
__asm suld.b.2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 942
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 943
__asm suld.b.2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 945
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 946
} 
#endif
#line 948 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 949
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 961
::exit(___);}
#if 0
#line 949
{ 
#line 950
short2 tmp; 
#line 951
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 952
__asm suld.b.2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 954
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 955
__asm suld.b.2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 957
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 958
__asm suld.b.2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 960
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 961
} 
#endif
#line 963 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 964
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 976
::exit(___);}
#if 0
#line 964
{ 
#line 965
ushort2 tmp; 
#line 966
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 967
__asm suld.b.2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 969
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 970
__asm suld.b.2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 972
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 973
__asm suld.b.2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 975
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 976
} 
#endif
#line 978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 979
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 991
::exit(___);}
#if 0
#line 979
{ 
#line 980
int2 tmp; 
#line 981
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 982
__asm suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 984
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 985
__asm suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 987
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 988
__asm suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 990
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 991
} 
#endif
#line 993 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 994
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1006
::exit(___);}
#if 0
#line 994
{ 
#line 995
uint2 tmp; 
#line 996
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 997
__asm suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 999
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1000
__asm suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1002
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1003
__asm suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 1005
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1006
} 
#endif
#line 1008 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1009
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1021
::exit(___);}
#if 0
#line 1009
{ 
#line 1010
longlong2 tmp; 
#line 1011
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1012
__asm suld.b.2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1014
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1015
__asm suld.b.2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1017
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1018
__asm suld.b.2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 1020
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 1021
} 
#endif
#line 1023 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1024
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1036
::exit(___);}
#if 0
#line 1024
{ 
#line 1025
ulonglong2 tmp; 
#line 1026
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1027
__asm suld.b.2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1029
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1030
__asm suld.b.2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1032
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1033
__asm suld.b.2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 1035
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 1036
} 
#endif
#line 1038 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1039
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1051
::exit(___);}
#if 0
#line 1039
{ 
#line 1040
float2 tmp; 
#line 1041
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1042
__asm suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1044
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1045
__asm suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1047
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1048
__asm suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 1050
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1051
} 
#endif
#line 1059 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1060
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1072
::exit(___);}
#if 0
#line 1060
{ 
#line 1061
int4 tmp; 
#line 1062
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1063
__asm suld.b.2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1065
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1066
__asm suld.b.2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1068
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1069
__asm suld.b.2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1071
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1072
} 
#endif
#line 1074 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1075
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1087
::exit(___);}
#if 0
#line 1075
{ 
#line 1076
uint4 tmp; 
#line 1077
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1078
__asm suld.b.2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1080
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1081
__asm suld.b.2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1083
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1084
__asm suld.b.2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1086
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1087
} 
#endif
#line 1089 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1090
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1102
::exit(___);}
#if 0
#line 1090
{ 
#line 1091
short4 tmp; 
#line 1092
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1093
__asm suld.b.2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1095
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1096
__asm suld.b.2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1098
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1099
__asm suld.b.2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1101
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1102
} 
#endif
#line 1104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1105
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1117
::exit(___);}
#if 0
#line 1105
{ 
#line 1106
ushort4 tmp; 
#line 1107
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1108
__asm suld.b.2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1110
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1111
__asm suld.b.2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1113
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1114
__asm suld.b.2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1116
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1117
} 
#endif
#line 1119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1120
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1132
::exit(___);}
#if 0
#line 1120
{ 
#line 1121
int4 tmp; 
#line 1122
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1123
__asm suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1125
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1126
__asm suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1128
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1129
__asm suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1131
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1132
} 
#endif
#line 1134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1135
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1147
::exit(___);}
#if 0
#line 1135
{ 
#line 1136
uint4 tmp; 
#line 1137
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1138
__asm suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1140
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1141
__asm suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1143
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1144
__asm suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1146
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1147
} 
#endif
#line 1149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1150
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1162
::exit(___);}
#if 0
#line 1150
{ 
#line 1151
float4 tmp; 
#line 1152
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1153
__asm suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1155
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1156
__asm suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1158
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1159
__asm suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1161
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1162
} 
#endif
#line 1170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 1171
surf2Dread(::cudaSurfaceObject_t surfObject, int x, int y, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1172
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1176
::exit(___);}
#if 0
#line 1172
{ 
#line 1173
T ret; 
#line 1174
surf2Dread(&ret, surfObject, x, y, boundaryMode); 
#line 1175
return ret; 
#line 1176
} 
#endif
#line 1184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1185
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1197
::exit(___);}
#if 0
#line 1185
{ 
#line 1186
int tmp; 
#line 1187
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1188
__asm suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1190
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1191
__asm suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1193
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1194
__asm suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1196
(*retVal) = ((char)tmp); 
#line 1197
} 
#endif
#line 1199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1200
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1212
::exit(___);}
#if 0
#line 1200
{ 
#line 1201
int tmp; 
#line 1202
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1203
__asm suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1205
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1206
__asm suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1208
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1209
__asm suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1211
(*retVal) = ((signed char)tmp); 
#line 1212
} 
#endif
#line 1214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1215
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1227
::exit(___);}
#if 0
#line 1215
{ 
#line 1216
int1 tmp; 
#line 1217
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1218
__asm suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1220
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1221
__asm suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1223
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1224
__asm suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1226
(*retVal) = make_char1(tmp.x); 
#line 1227
} 
#endif
#line 1229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1230
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1242
::exit(___);}
#if 0
#line 1230
{ 
#line 1231
unsigned tmp; 
#line 1232
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1233
__asm suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1235
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1236
__asm suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1238
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1239
__asm suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1241
(*retVal) = ((unsigned char)tmp); 
#line 1242
} 
#endif
#line 1244 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1245
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1257
::exit(___);}
#if 0
#line 1245
{ 
#line 1246
uint1 tmp; 
#line 1247
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1248
__asm suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1250
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1251
__asm suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1253
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1254
__asm suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1256
(*retVal) = make_uchar1(tmp.x); 
#line 1257
} 
#endif
#line 1259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1260
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1272
::exit(___);}
#if 0
#line 1260
{ 
#line 1261
short tmp; 
#line 1262
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1263
__asm suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1265
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1266
__asm suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1268
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1269
__asm suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1271
(*retVal) = tmp; 
#line 1272
} 
#endif
#line 1274 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1275
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1287
::exit(___);}
#if 0
#line 1275
{ 
#line 1276
short1 tmp; 
#line 1277
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1278
__asm suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1280
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1281
__asm suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1283
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1284
__asm suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1286
(*retVal) = make_short1(tmp.x); 
#line 1287
} 
#endif
#line 1289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1290
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1302
::exit(___);}
#if 0
#line 1290
{ 
#line 1291
unsigned short tmp; 
#line 1292
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1293
__asm suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1295
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1296
__asm suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1298
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1299
__asm suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1301
(*retVal) = tmp; 
#line 1302
} 
#endif
#line 1304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1305
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1317
::exit(___);}
#if 0
#line 1305
{ 
#line 1306
ushort1 tmp; 
#line 1307
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1308
__asm suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1310
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1311
__asm suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1313
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1314
__asm suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1316
(*retVal) = make_ushort1(tmp.x); 
#line 1317
} 
#endif
#line 1319 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1320
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1332
::exit(___);}
#if 0
#line 1320
{ 
#line 1321
int tmp; 
#line 1322
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1323
__asm suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1325
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1326
__asm suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1328
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1329
__asm suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1331
(*retVal) = tmp; 
#line 1332
} 
#endif
#line 1334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1335
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1347
::exit(___);}
#if 0
#line 1335
{ 
#line 1336
int1 tmp; 
#line 1337
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1338
__asm suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1340
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1341
__asm suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1343
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1344
__asm suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1346
(*retVal) = make_int1(tmp.x); 
#line 1347
} 
#endif
#line 1349 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1350
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1362
::exit(___);}
#if 0
#line 1350
{ 
#line 1351
unsigned tmp; 
#line 1352
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1353
__asm suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1355
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1356
__asm suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1358
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1359
__asm suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1361
(*retVal) = tmp; 
#line 1362
} 
#endif
#line 1364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1365
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1377
::exit(___);}
#if 0
#line 1365
{ 
#line 1366
uint1 tmp; 
#line 1367
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1368
__asm suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1370
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1371
__asm suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1373
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1374
__asm suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1376
(*retVal) = make_uint1(tmp.x); 
#line 1377
} 
#endif
#line 1379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1380
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1392
::exit(___);}
#if 0
#line 1380
{ 
#line 1381
__int64 tmp; 
#line 1382
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1383
__asm suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1385
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1386
__asm suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1388
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1389
__asm suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1391
(*retVal) = tmp; 
#line 1392
} 
#endif
#line 1394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1395
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1407
::exit(___);}
#if 0
#line 1395
{ 
#line 1396
longlong1 tmp; 
#line 1397
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1398
__asm suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1400
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1401
__asm suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1403
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1404
__asm suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1406
(*retVal) = make_longlong1(tmp.x); 
#line 1407
} 
#endif
#line 1409 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1410
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1422
::exit(___);}
#if 0
#line 1410
{ 
#line 1411
unsigned __int64 tmp; 
#line 1412
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1413
__asm suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1415
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1416
__asm suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1418
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1419
__asm suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1421
(*retVal) = tmp; 
#line 1422
} 
#endif
#line 1424 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1425
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1437
::exit(___);}
#if 0
#line 1425
{ 
#line 1426
ulonglong1 tmp; 
#line 1427
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1428
__asm suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1430
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1431
__asm suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1433
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1434
__asm suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1436
(*retVal) = make_ulonglong1(tmp.x); 
#line 1437
} 
#endif
#line 1439 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1440
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1452
::exit(___);}
#if 0
#line 1440
{ 
#line 1441
float tmp; 
#line 1442
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1443
__asm suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1445
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1446
__asm suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1448
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1449
__asm suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1451
(*retVal) = tmp; 
#line 1452
} 
#endif
#line 1454 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1455
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1467
::exit(___);}
#if 0
#line 1455
{ 
#line 1456
float1 tmp; 
#line 1457
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1458
__asm suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1460
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1461
__asm suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1463
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1464
__asm suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1466
(*retVal) = make_float1(tmp.x); 
#line 1467
} 
#endif
#line 1475 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1476
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1488
::exit(___);}
#if 0
#line 1476
{ 
#line 1477
int2 tmp; 
#line 1478
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1479
__asm suld.b.3d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1481
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1482
__asm suld.b.3d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1484
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1485
__asm suld.b.3d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1487
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1488
} 
#endif
#line 1490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1491
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1503
::exit(___);}
#if 0
#line 1491
{ 
#line 1492
uint2 tmp; 
#line 1493
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1494
__asm suld.b.3d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1496
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1497
__asm suld.b.3d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1499
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1500
__asm suld.b.3d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1502
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 1503
} 
#endif
#line 1505 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1506
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1518
::exit(___);}
#if 0
#line 1506
{ 
#line 1507
short2 tmp; 
#line 1508
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1509
__asm suld.b.3d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1511
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1512
__asm suld.b.3d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1514
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1515
__asm suld.b.3d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1517
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 1518
} 
#endif
#line 1520 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1521
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1533
::exit(___);}
#if 0
#line 1521
{ 
#line 1522
ushort2 tmp; 
#line 1523
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1524
__asm suld.b.3d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1526
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1527
__asm suld.b.3d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1529
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1530
__asm suld.b.3d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1532
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 1533
} 
#endif
#line 1535 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1536
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1548
::exit(___);}
#if 0
#line 1536
{ 
#line 1537
int2 tmp; 
#line 1538
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1539
__asm suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1541
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1542
__asm suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1544
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1545
__asm suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1547
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 1548
} 
#endif
#line 1550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1551
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1563
::exit(___);}
#if 0
#line 1551
{ 
#line 1552
uint2 tmp; 
#line 1553
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1554
__asm suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1556
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1557
__asm suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1559
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1560
__asm suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1562
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1563
} 
#endif
#line 1565 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1566
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1578
::exit(___);}
#if 0
#line 1566
{ 
#line 1567
longlong2 tmp; 
#line 1568
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1569
__asm suld.b.3d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1571
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1572
__asm suld.b.3d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1574
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1575
__asm suld.b.3d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1577
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 1578
} 
#endif
#line 1580 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1581
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1593
::exit(___);}
#if 0
#line 1581
{ 
#line 1582
ulonglong2 tmp; 
#line 1583
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1584
__asm suld.b.3d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1586
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1587
__asm suld.b.3d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1589
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1590
__asm suld.b.3d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1592
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 1593
} 
#endif
#line 1595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1596
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1608
::exit(___);}
#if 0
#line 1596
{ 
#line 1597
float2 tmp; 
#line 1598
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1599
__asm suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1601
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1602
__asm suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1604
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1605
__asm suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1607
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1608
} 
#endif
#line 1616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1617
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1629
::exit(___);}
#if 0
#line 1617
{ 
#line 1618
int4 tmp; 
#line 1619
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1620
__asm suld.b.3d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1622
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1623
__asm suld.b.3d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1625
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1626
__asm suld.b.3d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1628
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1629
} 
#endif
#line 1631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1632
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1644
::exit(___);}
#if 0
#line 1632
{ 
#line 1633
uint4 tmp; 
#line 1634
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1635
__asm suld.b.3d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1637
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1638
__asm suld.b.3d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1640
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1641
__asm suld.b.3d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1643
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1644
} 
#endif
#line 1646 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1647
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1659
::exit(___);}
#if 0
#line 1647
{ 
#line 1648
short4 tmp; 
#line 1649
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1650
__asm suld.b.3d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1652
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1653
__asm suld.b.3d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1655
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1656
__asm suld.b.3d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1658
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1659
} 
#endif
#line 1661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1662
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1674
::exit(___);}
#if 0
#line 1662
{ 
#line 1663
ushort4 tmp; 
#line 1664
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1665
__asm suld.b.3d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1667
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1668
__asm suld.b.3d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1670
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1671
__asm suld.b.3d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1673
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1674
} 
#endif
#line 1676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1677
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1689
::exit(___);}
#if 0
#line 1677
{ 
#line 1678
int4 tmp; 
#line 1679
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1680
__asm suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1682
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1683
__asm suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1685
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1686
__asm suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1688
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1689
} 
#endif
#line 1691 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1692
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1704
::exit(___);}
#if 0
#line 1692
{ 
#line 1693
uint4 tmp; 
#line 1694
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1695
__asm suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1697
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1698
__asm suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1700
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1701
__asm suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1703
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1704
} 
#endif
#line 1706 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1707
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1719
::exit(___);}
#if 0
#line 1707
{ 
#line 1708
float4 tmp; 
#line 1709
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1710
__asm suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1712
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1713
__asm suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1715
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1716
__asm suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1718
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1719
} 
#endif
#line 1727 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 1728
surf3Dread(::cudaSurfaceObject_t surfObject, int x, int y, int z, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1729
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1733
::exit(___);}
#if 0
#line 1729
{ 
#line 1730
T ret; 
#line 1731
surf3Dread(&ret, surfObject, x, y, z, boundaryMode); 
#line 1732
return ret; 
#line 1733
} 
#endif
#line 1741 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1742
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1754
::exit(___);}
#if 0
#line 1742
{ 
#line 1743
int tmp; 
#line 1744
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1745
__asm suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1747
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1748
__asm suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1750
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1751
__asm suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1753
(*retVal) = ((char)tmp); 
#line 1754
} 
#endif
#line 1756 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1757
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1769
::exit(___);}
#if 0
#line 1757
{ 
#line 1758
int tmp; 
#line 1759
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1760
__asm suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1762
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1763
__asm suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1765
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1766
__asm suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1768
(*retVal) = ((signed char)tmp); 
#line 1769
} 
#endif
#line 1771 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1772
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1784
::exit(___);}
#if 0
#line 1772
{ 
#line 1773
int1 tmp; 
#line 1774
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1775
__asm suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1777
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1778
__asm suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1780
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1781
__asm suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1783
(*retVal) = make_char1(tmp.x); 
#line 1784
} 
#endif
#line 1786 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1787
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1799
::exit(___);}
#if 0
#line 1787
{ 
#line 1788
unsigned tmp; 
#line 1789
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1790
__asm suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1792
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1793
__asm suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1795
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1796
__asm suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1798
(*retVal) = ((unsigned char)tmp); 
#line 1799
} 
#endif
#line 1801 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1802
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1814
::exit(___);}
#if 0
#line 1802
{ 
#line 1803
uint1 tmp; 
#line 1804
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1805
__asm suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1807
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1808
__asm suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1810
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1811
__asm suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1813
(*retVal) = make_uchar1(tmp.x); 
#line 1814
} 
#endif
#line 1816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1817
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1829
::exit(___);}
#if 0
#line 1817
{ 
#line 1818
short tmp; 
#line 1819
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1820
__asm suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1822
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1823
__asm suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1825
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1826
__asm suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1828
(*retVal) = tmp; 
#line 1829
} 
#endif
#line 1831 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1832
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1844
::exit(___);}
#if 0
#line 1832
{ 
#line 1833
short1 tmp; 
#line 1834
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1835
__asm suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1837
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1838
__asm suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1840
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1841
__asm suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1843
(*retVal) = make_short1(tmp.x); 
#line 1844
} 
#endif
#line 1846 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1847
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1859
::exit(___);}
#if 0
#line 1847
{ 
#line 1848
unsigned short tmp; 
#line 1849
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1850
__asm suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1852
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1853
__asm suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1855
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1856
__asm suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1858
(*retVal) = tmp; 
#line 1859
} 
#endif
#line 1861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1862
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1874
::exit(___);}
#if 0
#line 1862
{ 
#line 1863
ushort1 tmp; 
#line 1864
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1865
__asm suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1867
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1868
__asm suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1870
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1871
__asm suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1873
(*retVal) = make_ushort1(tmp.x); 
#line 1874
} 
#endif
#line 1876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1877
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1889
::exit(___);}
#if 0
#line 1877
{ 
#line 1878
int tmp; 
#line 1879
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1880
__asm suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1882
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1883
__asm suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1885
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1886
__asm suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1888
(*retVal) = tmp; 
#line 1889
} 
#endif
#line 1891 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1892
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1904
::exit(___);}
#if 0
#line 1892
{ 
#line 1893
int1 tmp; 
#line 1894
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1895
__asm suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1897
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1898
__asm suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1900
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1901
__asm suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1903
(*retVal) = make_int1(tmp.x); 
#line 1904
} 
#endif
#line 1906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1907
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1919
::exit(___);}
#if 0
#line 1907
{ 
#line 1908
unsigned tmp; 
#line 1909
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1910
__asm suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1912
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1913
__asm suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1915
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1916
__asm suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1918
(*retVal) = tmp; 
#line 1919
} 
#endif
#line 1921 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1922
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1934
::exit(___);}
#if 0
#line 1922
{ 
#line 1923
uint1 tmp; 
#line 1924
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1925
__asm suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1927
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1928
__asm suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1930
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1931
__asm suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1933
(*retVal) = make_uint1(tmp.x); 
#line 1934
} 
#endif
#line 1936 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1937
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1949
::exit(___);}
#if 0
#line 1937
{ 
#line 1938
__int64 tmp; 
#line 1939
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1940
__asm suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1942
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1943
__asm suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1945
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1946
__asm suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1948
(*retVal) = tmp; 
#line 1949
} 
#endif
#line 1951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1952
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1964
::exit(___);}
#if 0
#line 1952
{ 
#line 1953
longlong1 tmp; 
#line 1954
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1955
__asm suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1957
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1958
__asm suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1960
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1961
__asm suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1963
(*retVal) = make_longlong1(tmp.x); 
#line 1964
} 
#endif
#line 1966 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1967
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1979
::exit(___);}
#if 0
#line 1967
{ 
#line 1968
unsigned __int64 tmp; 
#line 1969
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1970
__asm suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1972
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1973
__asm suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1975
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1976
__asm suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1978
(*retVal) = tmp; 
#line 1979
} 
#endif
#line 1981 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1982
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1994
::exit(___);}
#if 0
#line 1982
{ 
#line 1983
ulonglong1 tmp; 
#line 1984
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1985
__asm suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1987
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1988
__asm suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1990
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1991
__asm suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1993
(*retVal) = make_ulonglong1(tmp.x); 
#line 1994
} 
#endif
#line 1996 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1997
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2009
::exit(___);}
#if 0
#line 1997
{ 
#line 1998
float tmp; 
#line 1999
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2000
__asm suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 2002
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2003
__asm suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 2005
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2006
__asm suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 2008
(*retVal) = tmp; 
#line 2009
} 
#endif
#line 2011 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2012
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2024
::exit(___);}
#if 0
#line 2012
{ 
#line 2013
float1 tmp; 
#line 2014
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2015
__asm suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 2017
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2018
__asm suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 2020
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2021
__asm suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 2023
(*retVal) = make_float1(tmp.x); 
#line 2024
} 
#endif
#line 2032 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2033
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2045
::exit(___);}
#if 0
#line 2033
{ 
#line 2034
int2 tmp; 
#line 2035
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2036
__asm suld.b.a1d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2038
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2039
__asm suld.b.a1d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2041
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2042
__asm suld.b.a1d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2044
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 2045
} 
#endif
#line 2047 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2048
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2060
::exit(___);}
#if 0
#line 2048
{ 
#line 2049
uint2 tmp; 
#line 2050
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2051
__asm suld.b.a1d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2053
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2054
__asm suld.b.a1d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2056
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2057
__asm suld.b.a1d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2059
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 2060
} 
#endif
#line 2062 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2063
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2075
::exit(___);}
#if 0
#line 2063
{ 
#line 2064
short2 tmp; 
#line 2065
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2066
__asm suld.b.a1d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2068
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2069
__asm suld.b.a1d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2071
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2072
__asm suld.b.a1d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2074
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 2075
} 
#endif
#line 2077 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2078
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2090
::exit(___);}
#if 0
#line 2078
{ 
#line 2079
ushort2 tmp; 
#line 2080
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2081
__asm suld.b.a1d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2083
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2084
__asm suld.b.a1d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2086
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2087
__asm suld.b.a1d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2089
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 2090
} 
#endif
#line 2092 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2093
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2105
::exit(___);}
#if 0
#line 2093
{ 
#line 2094
int2 tmp; 
#line 2095
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2096
__asm suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2098
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2099
__asm suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2101
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2102
__asm suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2104
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2105
} 
#endif
#line 2107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2108
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2120
::exit(___);}
#if 0
#line 2108
{ 
#line 2109
uint2 tmp; 
#line 2110
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2111
__asm suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2113
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2114
__asm suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2116
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2117
__asm suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2119
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 2120
} 
#endif
#line 2122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2123
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2135
::exit(___);}
#if 0
#line 2123
{ 
#line 2124
longlong2 tmp; 
#line 2125
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2126
__asm suld.b.a1d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2128
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2129
__asm suld.b.a1d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2131
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2132
__asm suld.b.a1d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2134
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 2135
} 
#endif
#line 2137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2138
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2150
::exit(___);}
#if 0
#line 2138
{ 
#line 2139
ulonglong2 tmp; 
#line 2140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2141
__asm suld.b.a1d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2144
__asm suld.b.a1d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2146
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2147
__asm suld.b.a1d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2149
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 2150
} 
#endif
#line 2152 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2153
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2165
::exit(___);}
#if 0
#line 2153
{ 
#line 2154
float2 tmp; 
#line 2155
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2156
__asm suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2158
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2159
__asm suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2161
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2162
__asm suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2164
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 2165
} 
#endif
#line 2173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2174
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2186
::exit(___);}
#if 0
#line 2174
{ 
#line 2175
int4 tmp; 
#line 2176
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2177
__asm suld.b.a1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2179
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2180
__asm suld.b.a1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2182
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2183
__asm suld.b.a1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2185
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2186
} 
#endif
#line 2188 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2189
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2201
::exit(___);}
#if 0
#line 2189
{ 
#line 2190
uint4 tmp; 
#line 2191
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2192
__asm suld.b.a1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2194
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2195
__asm suld.b.a1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2197
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2198
__asm suld.b.a1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2200
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2201
} 
#endif
#line 2203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2204
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2216
::exit(___);}
#if 0
#line 2204
{ 
#line 2205
short4 tmp; 
#line 2206
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2207
__asm suld.b.a1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2209
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2210
__asm suld.b.a1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2212
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2213
__asm suld.b.a1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2215
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2216
} 
#endif
#line 2218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2219
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2231
::exit(___);}
#if 0
#line 2219
{ 
#line 2220
ushort4 tmp; 
#line 2221
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2222
__asm suld.b.a1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2224
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2225
__asm suld.b.a1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2227
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2228
__asm suld.b.a1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2230
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2231
} 
#endif
#line 2233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2234
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2246
::exit(___);}
#if 0
#line 2234
{ 
#line 2235
int4 tmp; 
#line 2236
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2237
__asm suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2239
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2240
__asm suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2242
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2243
__asm suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2245
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2246
} 
#endif
#line 2248 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2249
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2261
::exit(___);}
#if 0
#line 2249
{ 
#line 2250
uint4 tmp; 
#line 2251
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2252
__asm suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2254
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2255
__asm suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2257
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2258
__asm suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2260
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2261
} 
#endif
#line 2263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2264
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2276
::exit(___);}
#if 0
#line 2264
{ 
#line 2265
float4 tmp; 
#line 2266
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2267
__asm suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2269
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2270
__asm suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2272
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2273
__asm suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2275
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2276
} 
#endif
#line 2284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 2285
surf1DLayeredread(::cudaSurfaceObject_t surfObject, int x, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2286
{int volatile ___ = 1;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2290
::exit(___);}
#if 0
#line 2286
{ 
#line 2287
T ret; 
#line 2288
surf1DLayeredread(&ret, surfObject, x, layer, boundaryMode); 
#line 2289
return ret; 
#line 2290
} 
#endif
#line 2298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2299
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2311
::exit(___);}
#if 0
#line 2299
{ 
#line 2300
int tmp; 
#line 2301
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2302
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2304
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2305
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2307
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2308
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2310
(*retVal) = ((char)tmp); 
#line 2311
} 
#endif
#line 2313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2314
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2326
::exit(___);}
#if 0
#line 2314
{ 
#line 2315
int tmp; 
#line 2316
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2317
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2319
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2320
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2322
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2323
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2325
(*retVal) = ((signed char)tmp); 
#line 2326
} 
#endif
#line 2328 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2329
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2341
::exit(___);}
#if 0
#line 2329
{ 
#line 2330
int1 tmp; 
#line 2331
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2332
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2334
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2335
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2337
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2338
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2340
(*retVal) = make_char1(tmp.x); 
#line 2341
} 
#endif
#line 2343 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2344
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2356
::exit(___);}
#if 0
#line 2344
{ 
#line 2345
unsigned tmp; 
#line 2346
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2347
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2349
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2350
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2352
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2353
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2355
(*retVal) = ((unsigned char)tmp); 
#line 2356
} 
#endif
#line 2358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2359
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2371
::exit(___);}
#if 0
#line 2359
{ 
#line 2360
uint1 tmp; 
#line 2361
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2362
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2364
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2365
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2367
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2368
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2370
(*retVal) = make_uchar1(tmp.x); 
#line 2371
} 
#endif
#line 2373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2374
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2386
::exit(___);}
#if 0
#line 2374
{ 
#line 2375
short tmp; 
#line 2376
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2377
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2379
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2380
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2382
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2383
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2385
(*retVal) = tmp; 
#line 2386
} 
#endif
#line 2388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2389
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2401
::exit(___);}
#if 0
#line 2389
{ 
#line 2390
short1 tmp; 
#line 2391
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2392
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2394
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2395
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2397
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2398
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2400
(*retVal) = make_short1(tmp.x); 
#line 2401
} 
#endif
#line 2403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2404
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2416
::exit(___);}
#if 0
#line 2404
{ 
#line 2405
unsigned short tmp; 
#line 2406
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2407
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2409
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2410
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2412
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2413
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2415
(*retVal) = tmp; 
#line 2416
} 
#endif
#line 2418 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2419
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2431
::exit(___);}
#if 0
#line 2419
{ 
#line 2420
ushort1 tmp; 
#line 2421
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2422
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2424
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2425
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2427
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2428
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2430
(*retVal) = make_ushort1(tmp.x); 
#line 2431
} 
#endif
#line 2433 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2434
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2446
::exit(___);}
#if 0
#line 2434
{ 
#line 2435
int tmp; 
#line 2436
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2437
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2439
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2440
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2442
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2443
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2445
(*retVal) = tmp; 
#line 2446
} 
#endif
#line 2448 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2449
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2461
::exit(___);}
#if 0
#line 2449
{ 
#line 2450
int1 tmp; 
#line 2451
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2452
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2454
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2455
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2457
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2458
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2460
(*retVal) = make_int1(tmp.x); 
#line 2461
} 
#endif
#line 2463 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2464
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2476
::exit(___);}
#if 0
#line 2464
{ 
#line 2465
unsigned tmp; 
#line 2466
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2467
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2469
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2470
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2472
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2473
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2475
(*retVal) = tmp; 
#line 2476
} 
#endif
#line 2478 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2479
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2491
::exit(___);}
#if 0
#line 2479
{ 
#line 2480
uint1 tmp; 
#line 2481
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2482
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2484
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2485
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2487
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2488
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2490
(*retVal) = make_uint1(tmp.x); 
#line 2491
} 
#endif
#line 2493 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2494
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2506
::exit(___);}
#if 0
#line 2494
{ 
#line 2495
__int64 tmp; 
#line 2496
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2497
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2499
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2500
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2502
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2503
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2505
(*retVal) = tmp; 
#line 2506
} 
#endif
#line 2508 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2509
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2521
::exit(___);}
#if 0
#line 2509
{ 
#line 2510
longlong1 tmp; 
#line 2511
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2512
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2514
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2515
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2517
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2518
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2520
(*retVal) = make_longlong1(tmp.x); 
#line 2521
} 
#endif
#line 2523 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2524
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2536
::exit(___);}
#if 0
#line 2524
{ 
#line 2525
unsigned __int64 tmp; 
#line 2526
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2527
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2529
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2530
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2532
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2533
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2535
(*retVal) = tmp; 
#line 2536
} 
#endif
#line 2538 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2539
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2551
::exit(___);}
#if 0
#line 2539
{ 
#line 2540
ulonglong1 tmp; 
#line 2541
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2542
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2544
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2545
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2547
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2548
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2550
(*retVal) = make_ulonglong1(tmp.x); 
#line 2551
} 
#endif
#line 2553 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2554
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2566
::exit(___);}
#if 0
#line 2554
{ 
#line 2555
float tmp; 
#line 2556
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2557
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2559
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2560
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2562
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2563
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2565
(*retVal) = tmp; 
#line 2566
} 
#endif
#line 2568 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2569
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2581
::exit(___);}
#if 0
#line 2569
{ 
#line 2570
float1 tmp; 
#line 2571
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2572
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2574
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2575
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2577
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2578
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2580
(*retVal) = make_float1(tmp.x); 
#line 2581
} 
#endif
#line 2589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2590
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2602
::exit(___);}
#if 0
#line 2590
{ 
#line 2591
int2 tmp; 
#line 2592
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2593
__asm suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2595
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2596
__asm suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2598
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2599
__asm suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2601
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 2602
} 
#endif
#line 2604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2605
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2617
::exit(___);}
#if 0
#line 2605
{ 
#line 2606
uint2 tmp; 
#line 2607
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2608
__asm suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2610
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2611
__asm suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2613
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2614
__asm suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2616
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 2617
} 
#endif
#line 2619 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2620
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2632
::exit(___);}
#if 0
#line 2620
{ 
#line 2621
short2 tmp; 
#line 2622
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2623
__asm suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2625
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2626
__asm suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2628
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2629
__asm suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2631
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 2632
} 
#endif
#line 2634 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2635
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2647
::exit(___);}
#if 0
#line 2635
{ 
#line 2636
ushort2 tmp; 
#line 2637
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2638
__asm suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2640
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2641
__asm suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2643
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2644
__asm suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2646
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 2647
} 
#endif
#line 2649 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2650
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2662
::exit(___);}
#if 0
#line 2650
{ 
#line 2651
int2 tmp; 
#line 2652
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2653
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2655
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2656
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2658
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2659
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2661
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2662
} 
#endif
#line 2664 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2665
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2677
::exit(___);}
#if 0
#line 2665
{ 
#line 2666
uint2 tmp; 
#line 2667
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2668
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2670
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2671
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2673
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2674
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2676
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 2677
} 
#endif
#line 2679 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2680
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2692
::exit(___);}
#if 0
#line 2680
{ 
#line 2681
longlong2 tmp; 
#line 2682
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2683
__asm suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2685
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2686
__asm suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2688
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2689
__asm suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2691
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 2692
} 
#endif
#line 2694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2695
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2707
::exit(___);}
#if 0
#line 2695
{ 
#line 2696
ulonglong2 tmp; 
#line 2697
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2698
__asm suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2700
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2701
__asm suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2703
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2704
__asm suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2706
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 2707
} 
#endif
#line 2709 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2710
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2722
::exit(___);}
#if 0
#line 2710
{ 
#line 2711
float2 tmp; 
#line 2712
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2713
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2715
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2716
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2718
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2719
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2721
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 2722
} 
#endif
#line 2730 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2731
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2743
::exit(___);}
#if 0
#line 2731
{ 
#line 2732
int4 tmp; 
#line 2733
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2734
__asm suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2736
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2737
__asm suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2739
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2740
__asm suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2742
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2743
} 
#endif
#line 2745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2746
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2758
::exit(___);}
#if 0
#line 2746
{ 
#line 2747
uint4 tmp; 
#line 2748
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2749
__asm suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2751
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2752
__asm suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2754
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2755
__asm suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2757
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2758
} 
#endif
#line 2760 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2761
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2773
::exit(___);}
#if 0
#line 2761
{ 
#line 2762
short4 tmp; 
#line 2763
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2764
__asm suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2766
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2767
__asm suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2769
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2770
__asm suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2772
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2773
} 
#endif
#line 2775 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2776
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2788
::exit(___);}
#if 0
#line 2776
{ 
#line 2777
ushort4 tmp; 
#line 2778
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2779
__asm suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2781
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2782
__asm suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2784
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2785
__asm suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2787
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2788
} 
#endif
#line 2790 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2791
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2803
::exit(___);}
#if 0
#line 2791
{ 
#line 2792
int4 tmp; 
#line 2793
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2794
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2796
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2797
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2799
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2800
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2802
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2803
} 
#endif
#line 2805 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2806
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2818
::exit(___);}
#if 0
#line 2806
{ 
#line 2807
uint4 tmp; 
#line 2808
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2809
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2811
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2812
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2814
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2815
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2817
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2818
} 
#endif
#line 2820 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2821
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2833
::exit(___);}
#if 0
#line 2821
{ 
#line 2822
float4 tmp; 
#line 2823
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2824
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2826
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2827
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2829
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2830
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2832
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2833
} 
#endif
#line 2841 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 2842
surf2DLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2843
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2847
::exit(___);}
#if 0
#line 2843
{ 
#line 2844
T ret; 
#line 2845
surf2DLayeredread(&ret, surfObject, x, y, layer, boundaryMode); 
#line 2846
return ret; 
#line 2847
} 
#endif
#line 2855 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2856
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2868
::exit(___);}
#if 0
#line 2856
{ 
#line 2857
int tmp; 
#line 2858
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2859
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2861
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2862
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2864
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2865
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2867
(*retVal) = ((char)tmp); 
#line 2868
} 
#endif
#line 2870 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2871
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2883
::exit(___);}
#if 0
#line 2871
{ 
#line 2872
int tmp; 
#line 2873
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2874
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2876
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2877
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2879
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2880
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2882
(*retVal) = ((signed char)tmp); 
#line 2883
} 
#endif
#line 2885 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2886
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2898
::exit(___);}
#if 0
#line 2886
{ 
#line 2887
int1 tmp; 
#line 2888
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2889
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2891
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2892
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2894
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2895
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2897
(*retVal) = make_char1(tmp.x); 
#line 2898
} 
#endif
#line 2900 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2901
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2913
::exit(___);}
#if 0
#line 2901
{ 
#line 2902
unsigned tmp; 
#line 2903
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2904
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2906
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2907
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2909
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2910
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2912
(*retVal) = ((unsigned char)tmp); 
#line 2913
} 
#endif
#line 2915 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2916
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2928
::exit(___);}
#if 0
#line 2916
{ 
#line 2917
uint1 tmp; 
#line 2918
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2919
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2921
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2922
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2924
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2925
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2927
(*retVal) = make_uchar1(tmp.x); 
#line 2928
} 
#endif
#line 2930 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2931
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2943
::exit(___);}
#if 0
#line 2931
{ 
#line 2932
short tmp; 
#line 2933
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2934
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2936
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2937
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2939
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2940
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2942
(*retVal) = tmp; 
#line 2943
} 
#endif
#line 2945 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2946
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2958
::exit(___);}
#if 0
#line 2946
{ 
#line 2947
short1 tmp; 
#line 2948
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2949
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2951
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2952
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2954
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2955
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2957
(*retVal) = make_short1(tmp.x); 
#line 2958
} 
#endif
#line 2960 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2961
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2973
::exit(___);}
#if 0
#line 2961
{ 
#line 2962
unsigned short tmp; 
#line 2963
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2964
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2966
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2967
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2969
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2970
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2972
(*retVal) = tmp; 
#line 2973
} 
#endif
#line 2975 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2976
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2988
::exit(___);}
#if 0
#line 2976
{ 
#line 2977
ushort1 tmp; 
#line 2978
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2979
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2981
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2982
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2984
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2985
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2987
(*retVal) = make_ushort1(tmp.x); 
#line 2988
} 
#endif
#line 2990 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2991
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3003
::exit(___);}
#if 0
#line 2991
{ 
#line 2992
int tmp; 
#line 2993
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2994
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2996
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2997
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2999
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3000
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3002
(*retVal) = tmp; 
#line 3003
} 
#endif
#line 3005 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3006
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3018
::exit(___);}
#if 0
#line 3006
{ 
#line 3007
int1 tmp; 
#line 3008
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3009
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3011
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3012
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3014
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3015
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3017
(*retVal) = make_int1(tmp.x); 
#line 3018
} 
#endif
#line 3020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3021
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3033
::exit(___);}
#if 0
#line 3021
{ 
#line 3022
unsigned tmp; 
#line 3023
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3024
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3026
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3027
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3029
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3030
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3032
(*retVal) = tmp; 
#line 3033
} 
#endif
#line 3035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3036
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3048
::exit(___);}
#if 0
#line 3036
{ 
#line 3037
uint1 tmp; 
#line 3038
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3039
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3041
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3042
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3044
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3045
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3047
(*retVal) = make_uint1(tmp.x); 
#line 3048
} 
#endif
#line 3050 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3051
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3063
::exit(___);}
#if 0
#line 3051
{ 
#line 3052
__int64 tmp; 
#line 3053
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3054
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3056
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3057
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3059
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3060
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3062
(*retVal) = tmp; 
#line 3063
} 
#endif
#line 3065 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3066
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3078
::exit(___);}
#if 0
#line 3066
{ 
#line 3067
longlong1 tmp; 
#line 3068
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3069
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3071
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3072
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3074
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3075
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3077
(*retVal) = make_longlong1(tmp.x); 
#line 3078
} 
#endif
#line 3080 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3081
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3093
::exit(___);}
#if 0
#line 3081
{ 
#line 3082
unsigned __int64 tmp; 
#line 3083
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3084
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3086
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3087
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3089
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3090
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3092
(*retVal) = tmp; 
#line 3093
} 
#endif
#line 3095 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3096
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3108
::exit(___);}
#if 0
#line 3096
{ 
#line 3097
ulonglong1 tmp; 
#line 3098
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3099
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3101
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3102
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3104
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3105
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3107
(*retVal) = make_ulonglong1(tmp.x); 
#line 3108
} 
#endif
#line 3110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3111
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3123
::exit(___);}
#if 0
#line 3111
{ 
#line 3112
float tmp; 
#line 3113
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3114
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3116
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3117
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3119
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3120
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3122
(*retVal) = tmp; 
#line 3123
} 
#endif
#line 3125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3126
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3138
::exit(___);}
#if 0
#line 3126
{ 
#line 3127
float1 tmp; 
#line 3128
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3129
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3131
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3132
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3134
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3135
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3137
(*retVal) = make_float1(tmp.x); 
#line 3138
} 
#endif
#line 3146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3147
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3159
::exit(___);}
#if 0
#line 3147
{ 
#line 3148
int2 tmp; 
#line 3149
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3150
__asm suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3152
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3153
__asm suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3155
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3156
__asm suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3158
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3159
} 
#endif
#line 3161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3162
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3174
::exit(___);}
#if 0
#line 3162
{ 
#line 3163
uint2 tmp; 
#line 3164
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3165
__asm suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3167
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3168
__asm suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3170
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3171
__asm suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3173
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3174
} 
#endif
#line 3176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3177
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3189
::exit(___);}
#if 0
#line 3177
{ 
#line 3178
short2 tmp; 
#line 3179
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3180
__asm suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3182
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3183
__asm suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3185
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3186
__asm suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3188
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3189
} 
#endif
#line 3191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3192
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3204
::exit(___);}
#if 0
#line 3192
{ 
#line 3193
ushort2 tmp; 
#line 3194
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3195
__asm suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3197
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3198
__asm suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3200
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3201
__asm suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3203
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 3204
} 
#endif
#line 3206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3207
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3219
::exit(___);}
#if 0
#line 3207
{ 
#line 3208
int2 tmp; 
#line 3209
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3210
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3212
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3213
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3215
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3216
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3218
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 3219
} 
#endif
#line 3221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3222
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3234
::exit(___);}
#if 0
#line 3222
{ 
#line 3223
uint2 tmp; 
#line 3224
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3225
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3227
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3228
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3230
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3231
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3233
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3234
} 
#endif
#line 3236 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3237
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3249
::exit(___);}
#if 0
#line 3237
{ 
#line 3238
longlong2 tmp; 
#line 3239
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3240
__asm suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3242
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3243
__asm suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3245
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3246
__asm suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3248
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 3249
} 
#endif
#line 3251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3252
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3264
::exit(___);}
#if 0
#line 3252
{ 
#line 3253
ulonglong2 tmp; 
#line 3254
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3255
__asm suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3257
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3258
__asm suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3260
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3261
__asm suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3263
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 3264
} 
#endif
#line 3266 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3267
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3279
::exit(___);}
#if 0
#line 3267
{ 
#line 3268
float2 tmp; 
#line 3269
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3270
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3272
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3273
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3275
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3276
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3278
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3279
} 
#endif
#line 3287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3288
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3300
::exit(___);}
#if 0
#line 3288
{ 
#line 3289
int4 tmp; 
#line 3290
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3291
__asm suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3293
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3294
__asm suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3296
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3297
__asm suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3299
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3300
} 
#endif
#line 3302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3303
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3315
::exit(___);}
#if 0
#line 3303
{ 
#line 3304
uint4 tmp; 
#line 3305
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3306
__asm suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3308
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3309
__asm suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3311
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3312
__asm suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3314
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3315
} 
#endif
#line 3317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3318
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3330
::exit(___);}
#if 0
#line 3318
{ 
#line 3319
short4 tmp; 
#line 3320
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3321
__asm suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3323
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3324
__asm suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3326
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3327
__asm suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3329
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3330
} 
#endif
#line 3332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3333
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3345
::exit(___);}
#if 0
#line 3333
{ 
#line 3334
ushort4 tmp; 
#line 3335
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3336
__asm suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3338
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3339
__asm suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3341
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3342
__asm suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3344
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3345
} 
#endif
#line 3347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3348
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3360
::exit(___);}
#if 0
#line 3348
{ 
#line 3349
int4 tmp; 
#line 3350
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3351
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3353
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3354
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3356
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3357
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3359
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3360
} 
#endif
#line 3362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3363
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3375
::exit(___);}
#if 0
#line 3363
{ 
#line 3364
uint4 tmp; 
#line 3365
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3366
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3368
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3369
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3371
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3372
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3374
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3375
} 
#endif
#line 3377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3378
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3390
::exit(___);}
#if 0
#line 3378
{ 
#line 3379
float4 tmp; 
#line 3380
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3381
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3383
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3384
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3386
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3387
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3389
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3390
} 
#endif
#line 3398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 3399
surfCubemapread(::cudaSurfaceObject_t surfObject, int x, int y, int face, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3400
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3404
::exit(___);}
#if 0
#line 3400
{ 
#line 3401
T ret; 
#line 3402
surfCubemapread(&ret, surfObject, face, x, y, boundaryMode); 
#line 3403
return ret; 
#line 3404
} 
#endif
#line 3412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3413
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3425
::exit(___);}
#if 0
#line 3413
{ 
#line 3414
int tmp; 
#line 3415
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3416
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3418
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3419
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3421
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3422
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3424
(*retVal) = ((char)tmp); 
#line 3425
} 
#endif
#line 3427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3428
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3440
::exit(___);}
#if 0
#line 3428
{ 
#line 3429
int tmp; 
#line 3430
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3431
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3433
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3434
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3436
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3437
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3439
(*retVal) = ((signed char)tmp); 
#line 3440
} 
#endif
#line 3442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3443
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3455
::exit(___);}
#if 0
#line 3443
{ 
#line 3444
int1 tmp; 
#line 3445
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3446
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3448
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3449
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3451
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3452
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3454
(*retVal) = make_char1(tmp.x); 
#line 3455
} 
#endif
#line 3457 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3458
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3470
::exit(___);}
#if 0
#line 3458
{ 
#line 3459
unsigned tmp; 
#line 3460
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3461
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3463
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3464
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3466
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3467
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3469
(*retVal) = ((unsigned char)tmp); 
#line 3470
} 
#endif
#line 3472 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3473
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3485
::exit(___);}
#if 0
#line 3473
{ 
#line 3474
uint1 tmp; 
#line 3475
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3476
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3478
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3479
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3481
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3482
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3484
(*retVal) = make_uchar1(tmp.x); 
#line 3485
} 
#endif
#line 3487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3488
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3500
::exit(___);}
#if 0
#line 3488
{ 
#line 3489
short tmp; 
#line 3490
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3491
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3493
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3494
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3496
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3497
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3499
(*retVal) = tmp; 
#line 3500
} 
#endif
#line 3502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3503
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3515
::exit(___);}
#if 0
#line 3503
{ 
#line 3504
short1 tmp; 
#line 3505
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3506
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3508
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3509
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3511
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3512
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3514
(*retVal) = make_short1(tmp.x); 
#line 3515
} 
#endif
#line 3517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3518
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3530
::exit(___);}
#if 0
#line 3518
{ 
#line 3519
unsigned short tmp; 
#line 3520
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3521
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3523
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3524
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3526
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3527
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3529
(*retVal) = tmp; 
#line 3530
} 
#endif
#line 3532 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3533
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3545
::exit(___);}
#if 0
#line 3533
{ 
#line 3534
ushort1 tmp; 
#line 3535
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3536
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3538
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3539
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3541
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3542
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3544
(*retVal) = make_ushort1(tmp.x); 
#line 3545
} 
#endif
#line 3547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3548
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3560
::exit(___);}
#if 0
#line 3548
{ 
#line 3549
int tmp; 
#line 3550
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3551
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3553
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3554
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3556
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3557
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3559
(*retVal) = tmp; 
#line 3560
} 
#endif
#line 3562 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3563
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3575
::exit(___);}
#if 0
#line 3563
{ 
#line 3564
int1 tmp; 
#line 3565
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3566
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3568
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3569
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3571
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3572
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3574
(*retVal) = make_int1(tmp.x); 
#line 3575
} 
#endif
#line 3577 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3578
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3590
::exit(___);}
#if 0
#line 3578
{ 
#line 3579
unsigned tmp; 
#line 3580
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3581
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3583
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3584
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3586
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3587
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3589
(*retVal) = tmp; 
#line 3590
} 
#endif
#line 3592 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3593
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3605
::exit(___);}
#if 0
#line 3593
{ 
#line 3594
uint1 tmp; 
#line 3595
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3596
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3598
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3599
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3601
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3602
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3604
(*retVal) = make_uint1(tmp.x); 
#line 3605
} 
#endif
#line 3607 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3608
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3620
::exit(___);}
#if 0
#line 3608
{ 
#line 3609
__int64 tmp; 
#line 3610
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3611
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3613
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3614
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3616
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3617
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3619
(*retVal) = tmp; 
#line 3620
} 
#endif
#line 3622 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3623
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3635
::exit(___);}
#if 0
#line 3623
{ 
#line 3624
longlong1 tmp; 
#line 3625
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3626
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3628
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3629
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3631
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3632
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3634
(*retVal) = make_longlong1(tmp.x); 
#line 3635
} 
#endif
#line 3637 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3638
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3650
::exit(___);}
#if 0
#line 3638
{ 
#line 3639
unsigned __int64 tmp; 
#line 3640
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3641
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3643
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3644
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3646
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3647
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3649
(*retVal) = tmp; 
#line 3650
} 
#endif
#line 3652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3653
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3665
::exit(___);}
#if 0
#line 3653
{ 
#line 3654
ulonglong1 tmp; 
#line 3655
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3656
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3658
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3659
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3661
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3662
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3664
(*retVal) = make_ulonglong1(tmp.x); 
#line 3665
} 
#endif
#line 3667 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3668
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3680
::exit(___);}
#if 0
#line 3668
{ 
#line 3669
float tmp; 
#line 3670
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3671
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3673
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3674
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3676
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3677
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3679
(*retVal) = tmp; 
#line 3680
} 
#endif
#line 3682 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3683
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3695
::exit(___);}
#if 0
#line 3683
{ 
#line 3684
float1 tmp; 
#line 3685
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3686
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3688
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3689
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3691
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3692
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3694
(*retVal) = make_float1(tmp.x); 
#line 3695
} 
#endif
#line 3703 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3704
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3716
::exit(___);}
#if 0
#line 3704
{ 
#line 3705
int2 tmp; 
#line 3706
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3707
__asm suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3709
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3710
__asm suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3712
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3713
__asm suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3715
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3716
} 
#endif
#line 3718 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3719
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3731
::exit(___);}
#if 0
#line 3719
{ 
#line 3720
uint2 tmp; 
#line 3721
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3722
__asm suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3724
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3725
__asm suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3727
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3728
__asm suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3730
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3731
} 
#endif
#line 3733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3734
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3746
::exit(___);}
#if 0
#line 3734
{ 
#line 3735
short2 tmp; 
#line 3736
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3737
__asm suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3739
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3740
__asm suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3742
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3743
__asm suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3745
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3746
} 
#endif
#line 3748 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3749
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3761
::exit(___);}
#if 0
#line 3749
{ 
#line 3750
ushort2 tmp; 
#line 3751
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3752
__asm suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3754
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3755
__asm suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3757
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3758
__asm suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3760
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 3761
} 
#endif
#line 3763 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3764
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3776
::exit(___);}
#if 0
#line 3764
{ 
#line 3765
int2 tmp; 
#line 3766
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3767
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3769
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3770
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3772
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3773
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3775
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 3776
} 
#endif
#line 3778 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3779
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3791
::exit(___);}
#if 0
#line 3779
{ 
#line 3780
uint2 tmp; 
#line 3781
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3782
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3784
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3785
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3787
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3788
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3790
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3791
} 
#endif
#line 3793 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3794
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3806
::exit(___);}
#if 0
#line 3794
{ 
#line 3795
longlong2 tmp; 
#line 3796
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3797
__asm suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3799
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3800
__asm suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3802
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3803
__asm suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3805
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 3806
} 
#endif
#line 3808 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3809
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3821
::exit(___);}
#if 0
#line 3809
{ 
#line 3810
ulonglong2 tmp; 
#line 3811
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3812
__asm suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3814
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3815
__asm suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3817
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3818
__asm suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3820
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 3821
} 
#endif
#line 3823 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3824
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3836
::exit(___);}
#if 0
#line 3824
{ 
#line 3825
float2 tmp; 
#line 3826
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3827
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3829
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3830
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3832
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3833
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3835
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3836
} 
#endif
#line 3844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3845
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3857
::exit(___);}
#if 0
#line 3845
{ 
#line 3846
int4 tmp; 
#line 3847
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3848
__asm suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3850
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3851
__asm suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3853
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3854
__asm suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3856
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3857
} 
#endif
#line 3859 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3860
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3872
::exit(___);}
#if 0
#line 3860
{ 
#line 3861
uint4 tmp; 
#line 3862
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3863
__asm suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3865
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3866
__asm suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3868
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3869
__asm suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3871
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3872
} 
#endif
#line 3874 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3875
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3887
::exit(___);}
#if 0
#line 3875
{ 
#line 3876
short4 tmp; 
#line 3877
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3878
__asm suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3880
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3881
__asm suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3883
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3884
__asm suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3886
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3887
} 
#endif
#line 3889 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3890
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3902
::exit(___);}
#if 0
#line 3890
{ 
#line 3891
ushort4 tmp; 
#line 3892
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3893
__asm suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3895
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3896
__asm suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3898
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3899
__asm suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3901
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3902
} 
#endif
#line 3904 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3905
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3917
::exit(___);}
#if 0
#line 3905
{ 
#line 3906
int4 tmp; 
#line 3907
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3908
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3910
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3911
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3913
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3914
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3916
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3917
} 
#endif
#line 3919 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3920
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3932
::exit(___);}
#if 0
#line 3920
{ 
#line 3921
uint4 tmp; 
#line 3922
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3923
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3925
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3926
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3928
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3929
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3931
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3932
} 
#endif
#line 3934 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3935
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3947
::exit(___);}
#if 0
#line 3935
{ 
#line 3936
float4 tmp; 
#line 3937
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3938
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3940
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3941
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3943
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3944
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3946
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3947
} 
#endif
#line 3955 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 3956
surfCubemapLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3957
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3961
::exit(___);}
#if 0
#line 3957
{ 
#line 3958
T ret; 
#line 3959
surfCubemapLayeredread(&ret, surfObject, x, y, z, layerface, boundaryMode); 
#line 3960
return ret; 
#line 3961
} 
#endif
#line 3969 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3970
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3980
::exit(___);}
#if 0
#line 3970
{ 
#line 3971
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3972
__asm sust.b.1d.b8.trap  [%0, {%1}], {%2};
} else { 
#line 3974
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3975
__asm sust.b.1d.b8.clamp [%0, {%1}], {%2};
} else { 
#line 3977
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3978
__asm sust.b.1d.b8.zero  [%0, {%1}], {%2};
}  }  }  
#line 3980
} 
#endif
#line 3982 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3983
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3993
::exit(___);}
#if 0
#line 3983
{ 
#line 3984
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3985
__asm sust.b.1d.b8.trap  [%0, {%1}], {%2};
} else { 
#line 3987
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3988
__asm sust.b.1d.b8.clamp [%0, {%1}], {%2};
} else { 
#line 3990
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3991
__asm sust.b.1d.b8.zero  [%0, {%1}], {%2};
}  }  }  
#line 3993
} 
#endif
#line 3995 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3996
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4006
::exit(___);}
#if 0
#line 3996
{ 
#line 3997
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3998
__asm sust.b.1d.b8.trap  [%0, {%1}], {%2};
} else { 
#line 4000
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4001
__asm sust.b.1d.b8.clamp [%0, {%1}], {%2};
} else { 
#line 4003
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4004
__asm sust.b.1d.b8.zero  [%0, {%1}], {%2};
}  }  }  
#line 4006
} 
#endif
#line 4008 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4009
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4019
::exit(___);}
#if 0
#line 4009
{ 
#line 4010
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4011
__asm sust.b.1d.b8.trap  [%0, {%1}], {%2};
} else { 
#line 4013
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4014
__asm sust.b.1d.b8.clamp [%0, {%1}], {%2};
} else { 
#line 4016
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4017
__asm sust.b.1d.b8.zero  [%0, {%1}], {%2};
}  }  }  
#line 4019
} 
#endif
#line 4021 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4022
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4032
::exit(___);}
#if 0
#line 4022
{ 
#line 4023
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4024
__asm sust.b.1d.b8.trap  [%0, {%1}], {%2};
} else { 
#line 4026
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4027
__asm sust.b.1d.b8.clamp [%0, {%1}], {%2};
} else { 
#line 4029
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4030
__asm sust.b.1d.b8.zero  [%0, {%1}], {%2};
}  }  }  
#line 4032
} 
#endif
#line 4034 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4035
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4045
::exit(___);}
#if 0
#line 4035
{ 
#line 4036
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4037
__asm sust.b.1d.b16.trap  [%0, {%1}], {%2};
} else { 
#line 4039
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4040
__asm sust.b.1d.b16.clamp [%0, {%1}], {%2};
} else { 
#line 4042
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4043
__asm sust.b.1d.b16.zero  [%0, {%1}], {%2};
}  }  }  
#line 4045
} 
#endif
#line 4047 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4048
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4058
::exit(___);}
#if 0
#line 4048
{ 
#line 4049
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4050
__asm sust.b.1d.b16.trap  [%0, {%1}], {%2};
} else { 
#line 4052
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4053
__asm sust.b.1d.b16.clamp [%0, {%1}], {%2};
} else { 
#line 4055
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4056
__asm sust.b.1d.b16.zero  [%0, {%1}], {%2};
}  }  }  
#line 4058
} 
#endif
#line 4060 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4061
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4071
::exit(___);}
#if 0
#line 4061
{ 
#line 4062
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4063
__asm sust.b.1d.b16.trap  [%0, {%1}], {%2};
} else { 
#line 4065
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4066
__asm sust.b.1d.b16.clamp [%0, {%1}], {%2};
} else { 
#line 4068
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4069
__asm sust.b.1d.b16.zero  [%0, {%1}], {%2};
}  }  }  
#line 4071
} 
#endif
#line 4073 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4074
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4084
::exit(___);}
#if 0
#line 4074
{ 
#line 4075
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4076
__asm sust.b.1d.b16.trap  [%0, {%1}], {%2};
} else { 
#line 4078
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4079
__asm sust.b.1d.b16.clamp [%0, {%1}], {%2};
} else { 
#line 4081
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4082
__asm sust.b.1d.b16.zero  [%0, {%1}], {%2};
}  }  }  
#line 4084
} 
#endif
#line 4086 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4087
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4097
::exit(___);}
#if 0
#line 4087
{ 
#line 4088
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4089
__asm sust.b.1d.b32.trap  [%0, {%1}], {%2};
} else { 
#line 4091
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4092
__asm sust.b.1d.b32.clamp [%0, {%1}], {%2};
} else { 
#line 4094
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4095
__asm sust.b.1d.b32.zero  [%0, {%1}], {%2};
}  }  }  
#line 4097
} 
#endif
#line 4099 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4100
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4110
::exit(___);}
#if 0
#line 4100
{ 
#line 4101
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4102
__asm sust.b.1d.b32.trap  [%0, {%1}], {%2};
} else { 
#line 4104
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4105
__asm sust.b.1d.b32.clamp [%0, {%1}], {%2};
} else { 
#line 4107
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4108
__asm sust.b.1d.b32.zero  [%0, {%1}], {%2};
}  }  }  
#line 4110
} 
#endif
#line 4112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4113
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4123
::exit(___);}
#if 0
#line 4113
{ 
#line 4114
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4115
__asm sust.b.1d.b32.trap  [%0, {%1}], {%2};
} else { 
#line 4117
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4118
__asm sust.b.1d.b32.clamp [%0, {%1}], {%2};
} else { 
#line 4120
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4121
__asm sust.b.1d.b32.zero  [%0, {%1}], {%2};
}  }  }  
#line 4123
} 
#endif
#line 4125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4126
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4136
::exit(___);}
#if 0
#line 4126
{ 
#line 4127
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4128
__asm sust.b.1d.b32.trap  [%0, {%1}], {%2};
} else { 
#line 4130
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4131
__asm sust.b.1d.b32.clamp [%0, {%1}], {%2};
} else { 
#line 4133
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4134
__asm sust.b.1d.b32.zero  [%0, {%1}], {%2};
}  }  }  
#line 4136
} 
#endif
#line 4138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4139
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4149
::exit(___);}
#if 0
#line 4139
{ 
#line 4140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4141
__asm sust.b.1d.b64.trap  [%0, {%1}], {%2};
} else { 
#line 4143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4144
__asm sust.b.1d.b64.clamp [%0, {%1}], {%2};
} else { 
#line 4146
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4147
__asm sust.b.1d.b64.zero  [%0, {%1}], {%2};
}  }  }  
#line 4149
} 
#endif
#line 4151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4152
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4162
::exit(___);}
#if 0
#line 4152
{ 
#line 4153
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4154
__asm sust.b.1d.b64.trap  [%0, {%1}], {%2};
} else { 
#line 4156
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4157
__asm sust.b.1d.b64.clamp [%0, {%1}], {%2};
} else { 
#line 4159
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4160
__asm sust.b.1d.b64.zero  [%0, {%1}], {%2};
}  }  }  
#line 4162
} 
#endif
#line 4164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4165
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4175
::exit(___);}
#if 0
#line 4165
{ 
#line 4166
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4167
__asm sust.b.1d.b64.trap  [%0, {%1}], {%2};
} else { 
#line 4169
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4170
__asm sust.b.1d.b64.clamp [%0, {%1}], {%2};
} else { 
#line 4172
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4173
__asm sust.b.1d.b64.zero  [%0, {%1}], {%2};
}  }  }  
#line 4175
} 
#endif
#line 4177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4178
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4188
::exit(___);}
#if 0
#line 4178
{ 
#line 4179
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4180
__asm sust.b.1d.b64.trap  [%0, {%1}], {%2};
} else { 
#line 4182
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4183
__asm sust.b.1d.b64.clamp [%0, {%1}], {%2};
} else { 
#line 4185
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4186
__asm sust.b.1d.b64.zero  [%0, {%1}], {%2};
}  }  }  
#line 4188
} 
#endif
#line 4190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(float data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4191
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4201
::exit(___);}
#if 0
#line 4191
{ 
#line 4192
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4193
__asm sust.b.1d.b32.trap  [%0, {%1}], {%2};
} else { 
#line 4195
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4196
__asm sust.b.1d.b32.clamp [%0, {%1}], {%2};
} else { 
#line 4198
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4199
__asm sust.b.1d.b32.zero  [%0, {%1}], {%2};
}  }  }  
#line 4201
} 
#endif
#line 4203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4204
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4214
::exit(___);}
#if 0
#line 4204
{ 
#line 4205
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4206
__asm sust.b.1d.b32.trap  [%0, {%1}], {%2};
} else { 
#line 4208
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4209
__asm sust.b.1d.b32.clamp [%0, {%1}], {%2};
} else { 
#line 4211
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4212
__asm sust.b.1d.b32.zero  [%0, {%1}], {%2};
}  }  }  
#line 4214
} 
#endif
#line 4222 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4223
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4233
::exit(___);}
#if 0
#line 4223
{ 
#line 4224
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4225
__asm sust.b.1d.v2.b8.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4227
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4228
__asm sust.b.1d.v2.b8.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4230
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4231
__asm sust.b.1d.v2.b8.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4233
} 
#endif
#line 4235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4236
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4246
::exit(___);}
#if 0
#line 4236
{ 
#line 4237
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4238
__asm sust.b.1d.v2.b8.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4240
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4241
__asm sust.b.1d.v2.b8.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4243
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4244
__asm sust.b.1d.v2.b8.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4246
} 
#endif
#line 4248 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4249
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4259
::exit(___);}
#if 0
#line 4249
{ 
#line 4250
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4251
__asm sust.b.1d.v2.b16.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4253
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4254
__asm sust.b.1d.v2.b16.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4256
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4257
__asm sust.b.1d.v2.b16.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4259
} 
#endif
#line 4261 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4262
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4272
::exit(___);}
#if 0
#line 4262
{ 
#line 4263
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4264
__asm sust.b.1d.v2.b16.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4266
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4267
__asm sust.b.1d.v2.b16.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4269
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4270
__asm sust.b.1d.v2.b16.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4272
} 
#endif
#line 4274 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4275
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4285
::exit(___);}
#if 0
#line 4275
{ 
#line 4276
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4277
__asm sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4279
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4280
__asm sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4282
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4283
__asm sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4285
} 
#endif
#line 4287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4288
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4298
::exit(___);}
#if 0
#line 4288
{ 
#line 4289
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4290
__asm sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4292
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4293
__asm sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4295
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4296
__asm sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4298
} 
#endif
#line 4300 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4301
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4311
::exit(___);}
#if 0
#line 4301
{ 
#line 4302
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4303
__asm sust.b.1d.v2.b64.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4305
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4306
__asm sust.b.1d.v2.b64.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4308
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4309
__asm sust.b.1d.v2.b64.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4311
} 
#endif
#line 4313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4314
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4324
::exit(___);}
#if 0
#line 4314
{ 
#line 4315
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4316
__asm sust.b.1d.v2.b64.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4318
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4319
__asm sust.b.1d.v2.b64.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4321
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4322
__asm sust.b.1d.v2.b64.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4324
} 
#endif
#line 4326 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4327
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4337
::exit(___);}
#if 0
#line 4327
{ 
#line 4328
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4329
__asm sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4331
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4332
__asm sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4334
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4335
__asm sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4337
} 
#endif
#line 4345 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4346
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4356
::exit(___);}
#if 0
#line 4346
{ 
#line 4347
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4348
__asm sust.b.1d.v4.b8.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4350
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4351
__asm sust.b.1d.v4.b8.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4353
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4354
__asm sust.b.1d.v4.b8.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4356
} 
#endif
#line 4358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4359
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4369
::exit(___);}
#if 0
#line 4359
{ 
#line 4360
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4361
__asm sust.b.1d.v4.b8.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4363
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4364
__asm sust.b.1d.v4.b8.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4366
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4367
__asm sust.b.1d.v4.b8.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4369
} 
#endif
#line 4371 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4372
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4382
::exit(___);}
#if 0
#line 4372
{ 
#line 4373
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4374
__asm sust.b.1d.v4.b16.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4376
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4377
__asm sust.b.1d.v4.b16.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4379
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4380
__asm sust.b.1d.v4.b16.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4382
} 
#endif
#line 4384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4385
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4395
::exit(___);}
#if 0
#line 4385
{ 
#line 4386
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4387
__asm sust.b.1d.v4.b16.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4389
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4390
__asm sust.b.1d.v4.b16.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4392
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4393
__asm sust.b.1d.v4.b16.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4395
} 
#endif
#line 4397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4398
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4408
::exit(___);}
#if 0
#line 4398
{ 
#line 4399
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4400
__asm sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4402
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4403
__asm sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4405
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4406
__asm sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4408
} 
#endif
#line 4410 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4411
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4421
::exit(___);}
#if 0
#line 4411
{ 
#line 4412
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4413
__asm sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4415
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4416
__asm sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4418
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4419
__asm sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4421
} 
#endif
#line 4423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4424
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4434
::exit(___);}
#if 0
#line 4424
{ 
#line 4425
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4426
__asm sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4428
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4429
__asm sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4431
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4432
__asm sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4434
} 
#endif
#line 4442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4443
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4453
::exit(___);}
#if 0
#line 4443
{ 
#line 4444
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4445
__asm sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4447
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4448
__asm sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4450
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4451
__asm sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4453
} 
#endif
#line 4455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4456
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4466
::exit(___);}
#if 0
#line 4456
{ 
#line 4457
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4458
__asm sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4460
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4461
__asm sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4463
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4464
__asm sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4466
} 
#endif
#line 4468 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4469
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4479
::exit(___);}
#if 0
#line 4469
{ 
#line 4470
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4471
__asm sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4473
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4474
__asm sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4476
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4477
__asm sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4479
} 
#endif
#line 4481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4482
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4492
::exit(___);}
#if 0
#line 4482
{ 
#line 4483
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4484
__asm sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4486
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4487
__asm sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4489
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4490
__asm sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4492
} 
#endif
#line 4494 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4495
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4505
::exit(___);}
#if 0
#line 4495
{ 
#line 4496
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4497
__asm sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4499
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4500
__asm sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4502
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4503
__asm sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4505
} 
#endif
#line 4507 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4508
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4518
::exit(___);}
#if 0
#line 4508
{ 
#line 4509
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4510
__asm sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4512
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4513
__asm sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4515
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4516
__asm sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4518
} 
#endif
#line 4520 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4521
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4531
::exit(___);}
#if 0
#line 4521
{ 
#line 4522
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4523
__asm sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4525
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4526
__asm sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4528
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4529
__asm sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4531
} 
#endif
#line 4533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4534
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4544
::exit(___);}
#if 0
#line 4534
{ 
#line 4535
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4536
__asm sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4538
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4539
__asm sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4541
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4542
__asm sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4544
} 
#endif
#line 4546 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4547
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4557
::exit(___);}
#if 0
#line 4547
{ 
#line 4548
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4549
__asm sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4551
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4552
__asm sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4554
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4555
__asm sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4557
} 
#endif
#line 4559 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4560
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4570
::exit(___);}
#if 0
#line 4560
{ 
#line 4561
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4562
__asm sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4564
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4565
__asm sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4567
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4568
__asm sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4570
} 
#endif
#line 4572 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4573
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4583
::exit(___);}
#if 0
#line 4573
{ 
#line 4574
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4575
__asm sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4577
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4578
__asm sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4580
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4581
__asm sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4583
} 
#endif
#line 4585 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4586
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4596
::exit(___);}
#if 0
#line 4586
{ 
#line 4587
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4588
__asm sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4590
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4591
__asm sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4593
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4594
__asm sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4596
} 
#endif
#line 4598 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4599
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4609
::exit(___);}
#if 0
#line 4599
{ 
#line 4600
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4601
__asm sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4603
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4604
__asm sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4606
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4607
__asm sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4609
} 
#endif
#line 4611 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4612
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4622
::exit(___);}
#if 0
#line 4612
{ 
#line 4613
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4614
__asm sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4616
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4617
__asm sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4619
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4620
__asm sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4622
} 
#endif
#line 4624 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4625
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4635
::exit(___);}
#if 0
#line 4625
{ 
#line 4626
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4627
__asm sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4629
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4630
__asm sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4632
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4633
__asm sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4635
} 
#endif
#line 4637 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4638
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4648
::exit(___);}
#if 0
#line 4638
{ 
#line 4639
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4640
__asm sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4642
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4643
__asm sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4645
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4646
__asm sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4648
} 
#endif
#line 4650 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4651
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4661
::exit(___);}
#if 0
#line 4651
{ 
#line 4652
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4653
__asm sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4655
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4656
__asm sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4658
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4659
__asm sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4661
} 
#endif
#line 4663 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4664
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4674
::exit(___);}
#if 0
#line 4664
{ 
#line 4665
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4666
__asm sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4668
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4669
__asm sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4671
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4672
__asm sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4674
} 
#endif
#line 4676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4677
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4687
::exit(___);}
#if 0
#line 4677
{ 
#line 4678
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4679
__asm sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4681
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4682
__asm sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4684
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4685
__asm sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4687
} 
#endif
#line 4695 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4696
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4706
::exit(___);}
#if 0
#line 4696
{ 
#line 4697
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4698
__asm sust.b.2d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4700
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4701
__asm sust.b.2d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4703
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4704
__asm sust.b.2d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4706
} 
#endif
#line 4708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4709
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4719
::exit(___);}
#if 0
#line 4709
{ 
#line 4710
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4711
__asm sust.b.2d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4713
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4714
__asm sust.b.2d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4716
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4717
__asm sust.b.2d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4719
} 
#endif
#line 4721 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4722
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4732
::exit(___);}
#if 0
#line 4722
{ 
#line 4723
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4724
__asm sust.b.2d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4726
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4727
__asm sust.b.2d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4729
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4730
__asm sust.b.2d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4732
} 
#endif
#line 4734 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4735
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4745
::exit(___);}
#if 0
#line 4735
{ 
#line 4736
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4737
__asm sust.b.2d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4739
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4740
__asm sust.b.2d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4742
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4743
__asm sust.b.2d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4745
} 
#endif
#line 4747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4748
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4758
::exit(___);}
#if 0
#line 4748
{ 
#line 4749
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4750
__asm sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4752
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4753
__asm sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4755
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4756
__asm sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4758
} 
#endif
#line 4760 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4761
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4771
::exit(___);}
#if 0
#line 4761
{ 
#line 4762
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4763
__asm sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4765
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4766
__asm sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4768
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4769
__asm sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4771
} 
#endif
#line 4773 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4774
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4784
::exit(___);}
#if 0
#line 4774
{ 
#line 4775
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4776
__asm sust.b.2d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4778
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4779
__asm sust.b.2d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4781
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4782
__asm sust.b.2d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4784
} 
#endif
#line 4786 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4787
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4797
::exit(___);}
#if 0
#line 4787
{ 
#line 4788
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4789
__asm sust.b.2d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4791
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4792
__asm sust.b.2d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4794
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4795
__asm sust.b.2d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4797
} 
#endif
#line 4799 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4800
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4810
::exit(___);}
#if 0
#line 4800
{ 
#line 4801
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4802
__asm sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4804
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4805
__asm sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4807
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4808
__asm sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4810
} 
#endif
#line 4818 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4819
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4829
::exit(___);}
#if 0
#line 4819
{ 
#line 4820
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4821
__asm sust.b.2d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4823
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4824
__asm sust.b.2d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4826
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4827
__asm sust.b.2d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4829
} 
#endif
#line 4831 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4832
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4842
::exit(___);}
#if 0
#line 4832
{ 
#line 4833
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4834
__asm sust.b.2d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4836
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4837
__asm sust.b.2d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4839
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4840
__asm sust.b.2d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4842
} 
#endif
#line 4844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4845
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4855
::exit(___);}
#if 0
#line 4845
{ 
#line 4846
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4847
__asm sust.b.2d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4849
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4850
__asm sust.b.2d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4852
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4853
__asm sust.b.2d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4855
} 
#endif
#line 4857 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4858
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4868
::exit(___);}
#if 0
#line 4858
{ 
#line 4859
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4860
__asm sust.b.2d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4862
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4863
__asm sust.b.2d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4865
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4866
__asm sust.b.2d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4868
} 
#endif
#line 4870 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4871
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4881
::exit(___);}
#if 0
#line 4871
{ 
#line 4872
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4873
__asm sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4875
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4876
__asm sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4878
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4879
__asm sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4881
} 
#endif
#line 4883 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4884
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4894
::exit(___);}
#if 0
#line 4884
{ 
#line 4885
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4886
__asm sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4888
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4889
__asm sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4891
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4892
__asm sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4894
} 
#endif
#line 4896 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4897
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4907
::exit(___);}
#if 0
#line 4897
{ 
#line 4898
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4899
__asm sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4901
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4902
__asm sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4904
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4905
__asm sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4907
} 
#endif
#line 4915 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4916
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4926
::exit(___);}
#if 0
#line 4916
{ 
#line 4917
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4918
__asm sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4920
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4921
__asm sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4923
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4924
__asm sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 4926
} 
#endif
#line 4928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4929
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4939
::exit(___);}
#if 0
#line 4929
{ 
#line 4930
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4931
__asm sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4933
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4934
__asm sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4936
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4937
__asm sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 4939
} 
#endif
#line 4941 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4942
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4952
::exit(___);}
#if 0
#line 4942
{ 
#line 4943
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4944
__asm sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4946
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4947
__asm sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4949
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4950
__asm sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 4952
} 
#endif
#line 4954 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4955
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4965
::exit(___);}
#if 0
#line 4955
{ 
#line 4956
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4957
__asm sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4959
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4960
__asm sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4962
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4963
__asm sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 4965
} 
#endif
#line 4967 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4968
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4978
::exit(___);}
#if 0
#line 4968
{ 
#line 4969
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4970
__asm sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4972
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4973
__asm sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4975
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4976
__asm sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 4978
} 
#endif
#line 4980 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4981
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4991
::exit(___);}
#if 0
#line 4981
{ 
#line 4982
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4983
__asm sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4985
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4986
__asm sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4988
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4989
__asm sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 4991
} 
#endif
#line 4993 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4994
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5004
::exit(___);}
#if 0
#line 4994
{ 
#line 4995
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4996
__asm sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4998
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4999
__asm sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5001
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5002
__asm sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5004
} 
#endif
#line 5006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5007
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5017
::exit(___);}
#if 0
#line 5007
{ 
#line 5008
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5009
__asm sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5011
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5012
__asm sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5014
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5015
__asm sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5017
} 
#endif
#line 5019 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5020
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5030
::exit(___);}
#if 0
#line 5020
{ 
#line 5021
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5022
__asm sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5024
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5025
__asm sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5027
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5028
__asm sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5030
} 
#endif
#line 5032 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5033
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5043
::exit(___);}
#if 0
#line 5033
{ 
#line 5034
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5035
__asm sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5037
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5038
__asm sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5040
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5041
__asm sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5043
} 
#endif
#line 5045 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5046
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5056
::exit(___);}
#if 0
#line 5046
{ 
#line 5047
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5048
__asm sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5050
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5051
__asm sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5053
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5054
__asm sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5056
} 
#endif
#line 5058 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5059
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5069
::exit(___);}
#if 0
#line 5059
{ 
#line 5060
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5061
__asm sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5063
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5064
__asm sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5066
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5067
__asm sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5069
} 
#endif
#line 5071 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5072
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5082
::exit(___);}
#if 0
#line 5072
{ 
#line 5073
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5074
__asm sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5076
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5077
__asm sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5079
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5080
__asm sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5082
} 
#endif
#line 5084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5085
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5095
::exit(___);}
#if 0
#line 5085
{ 
#line 5086
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5087
__asm sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5089
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5090
__asm sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5092
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5093
__asm sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5095
} 
#endif
#line 5097 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5098
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5108
::exit(___);}
#if 0
#line 5098
{ 
#line 5099
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5100
__asm sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5102
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5103
__asm sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5105
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5106
__asm sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5108
} 
#endif
#line 5110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5111
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5121
::exit(___);}
#if 0
#line 5111
{ 
#line 5112
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5113
__asm sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5115
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5116
__asm sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5118
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5119
__asm sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5121
} 
#endif
#line 5123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5124
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5134
::exit(___);}
#if 0
#line 5124
{ 
#line 5125
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5126
__asm sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5128
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5129
__asm sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5131
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5132
__asm sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5134
} 
#endif
#line 5136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5137
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5147
::exit(___);}
#if 0
#line 5137
{ 
#line 5138
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5139
__asm sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5141
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5142
__asm sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5144
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5145
__asm sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5147
} 
#endif
#line 5149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5150
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5160
::exit(___);}
#if 0
#line 5150
{ 
#line 5151
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5152
__asm sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5154
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5155
__asm sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5157
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5158
__asm sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5160
} 
#endif
#line 5168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5169
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5179
::exit(___);}
#if 0
#line 5169
{ 
#line 5170
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5171
__asm sust.b.3d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5173
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5174
__asm sust.b.3d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5176
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5177
__asm sust.b.3d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5179
} 
#endif
#line 5181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5182
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5192
::exit(___);}
#if 0
#line 5182
{ 
#line 5183
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5184
__asm sust.b.3d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5186
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5187
__asm sust.b.3d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5189
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5190
__asm sust.b.3d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5192
} 
#endif
#line 5194 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5195
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5205
::exit(___);}
#if 0
#line 5195
{ 
#line 5196
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5197
__asm sust.b.3d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5199
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5200
__asm sust.b.3d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5202
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5203
__asm sust.b.3d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5205
} 
#endif
#line 5207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5208
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5218
::exit(___);}
#if 0
#line 5208
{ 
#line 5209
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5210
__asm sust.b.3d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5212
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5213
__asm sust.b.3d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5215
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5216
__asm sust.b.3d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5218
} 
#endif
#line 5220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5221
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5231
::exit(___);}
#if 0
#line 5221
{ 
#line 5222
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5223
__asm sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5225
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5226
__asm sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5228
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5229
__asm sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5231
} 
#endif
#line 5233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5234
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5244
::exit(___);}
#if 0
#line 5234
{ 
#line 5235
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5236
__asm sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5238
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5239
__asm sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5241
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5242
__asm sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5244
} 
#endif
#line 5246 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5247
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5257
::exit(___);}
#if 0
#line 5247
{ 
#line 5248
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5249
__asm sust.b.3d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5251
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5252
__asm sust.b.3d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5254
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5255
__asm sust.b.3d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5257
} 
#endif
#line 5259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5260
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5270
::exit(___);}
#if 0
#line 5260
{ 
#line 5261
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5262
__asm sust.b.3d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5264
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5265
__asm sust.b.3d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5267
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5268
__asm sust.b.3d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5270
} 
#endif
#line 5272 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5273
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5283
::exit(___);}
#if 0
#line 5273
{ 
#line 5274
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5275
__asm sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5277
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5278
__asm sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5280
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5281
__asm sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5283
} 
#endif
#line 5291 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5292
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5302
::exit(___);}
#if 0
#line 5292
{ 
#line 5293
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5294
__asm sust.b.3d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5296
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5297
__asm sust.b.3d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5299
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5300
__asm sust.b.3d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5302
} 
#endif
#line 5304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5305
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5315
::exit(___);}
#if 0
#line 5305
{ 
#line 5306
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5307
__asm sust.b.3d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5309
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5310
__asm sust.b.3d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5312
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5313
__asm sust.b.3d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5315
} 
#endif
#line 5317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5318
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5328
::exit(___);}
#if 0
#line 5318
{ 
#line 5319
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5320
__asm sust.b.3d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5322
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5323
__asm sust.b.3d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5325
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5326
__asm sust.b.3d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5328
} 
#endif
#line 5330 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5331
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5341
::exit(___);}
#if 0
#line 5331
{ 
#line 5332
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5333
__asm sust.b.3d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5335
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5336
__asm sust.b.3d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5338
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5339
__asm sust.b.3d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5341
} 
#endif
#line 5343 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5344
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5354
::exit(___);}
#if 0
#line 5344
{ 
#line 5345
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5346
__asm sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5348
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5349
__asm sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5351
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5352
__asm sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5354
} 
#endif
#line 5356 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5357
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5367
::exit(___);}
#if 0
#line 5357
{ 
#line 5358
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5359
__asm sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5361
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5362
__asm sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5364
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5365
__asm sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5367
} 
#endif
#line 5369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5370
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5380
::exit(___);}
#if 0
#line 5370
{ 
#line 5371
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5372
__asm sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5374
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5375
__asm sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5377
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5378
__asm sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5380
} 
#endif
#line 5388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5389
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5399
::exit(___);}
#if 0
#line 5389
{ 
#line 5390
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5391
__asm sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5393
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5394
__asm sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5396
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5397
__asm sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5399
} 
#endif
#line 5401 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5402
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5412
::exit(___);}
#if 0
#line 5402
{ 
#line 5403
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5404
__asm sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5406
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5407
__asm sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5409
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5410
__asm sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5412
} 
#endif
#line 5414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5415
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5425
::exit(___);}
#if 0
#line 5415
{ 
#line 5416
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5417
__asm sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5419
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5420
__asm sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5422
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5423
__asm sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5425
} 
#endif
#line 5427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5428
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5438
::exit(___);}
#if 0
#line 5428
{ 
#line 5429
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5430
__asm sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5432
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5433
__asm sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5435
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5436
__asm sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5438
} 
#endif
#line 5440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5441
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5451
::exit(___);}
#if 0
#line 5441
{ 
#line 5442
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5443
__asm sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5445
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5446
__asm sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5448
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5449
__asm sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5451
} 
#endif
#line 5453 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5454
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5464
::exit(___);}
#if 0
#line 5454
{ 
#line 5455
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5456
__asm sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5458
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5459
__asm sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5461
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5462
__asm sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5464
} 
#endif
#line 5466 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5467
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5477
::exit(___);}
#if 0
#line 5467
{ 
#line 5468
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5469
__asm sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5471
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5472
__asm sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5474
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5475
__asm sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5477
} 
#endif
#line 5479 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5480
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5490
::exit(___);}
#if 0
#line 5480
{ 
#line 5481
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5482
__asm sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5484
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5485
__asm sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5487
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5488
__asm sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5490
} 
#endif
#line 5492 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5493
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5503
::exit(___);}
#if 0
#line 5493
{ 
#line 5494
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5495
__asm sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5497
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5498
__asm sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5500
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5501
__asm sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5503
} 
#endif
#line 5505 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5506
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5516
::exit(___);}
#if 0
#line 5506
{ 
#line 5507
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5508
__asm sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5510
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5511
__asm sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5513
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5514
__asm sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5516
} 
#endif
#line 5518 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5519
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5529
::exit(___);}
#if 0
#line 5519
{ 
#line 5520
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5521
__asm sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5523
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5524
__asm sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5526
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5527
__asm sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5529
} 
#endif
#line 5531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5532
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5542
::exit(___);}
#if 0
#line 5532
{ 
#line 5533
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5534
__asm sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5536
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5537
__asm sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5539
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5540
__asm sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5542
} 
#endif
#line 5544 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5545
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5555
::exit(___);}
#if 0
#line 5545
{ 
#line 5546
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5547
__asm sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5549
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5550
__asm sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5552
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5553
__asm sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5555
} 
#endif
#line 5557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5558
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5568
::exit(___);}
#if 0
#line 5558
{ 
#line 5559
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5560
__asm sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5562
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5563
__asm sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5565
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5566
__asm sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5568
} 
#endif
#line 5570 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5571
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5581
::exit(___);}
#if 0
#line 5571
{ 
#line 5572
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5573
__asm sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5575
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5576
__asm sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5578
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5579
__asm sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5581
} 
#endif
#line 5583 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5584
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5594
::exit(___);}
#if 0
#line 5584
{ 
#line 5585
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5586
__asm sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5588
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5589
__asm sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5591
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5592
__asm sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5594
} 
#endif
#line 5596 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5597
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5607
::exit(___);}
#if 0
#line 5597
{ 
#line 5598
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5599
__asm sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5601
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5602
__asm sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5604
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5605
__asm sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5607
} 
#endif
#line 5609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5610
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5620
::exit(___);}
#if 0
#line 5610
{ 
#line 5611
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5612
__asm sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5614
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5615
__asm sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5617
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5618
__asm sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5620
} 
#endif
#line 5622 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5623
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5633
::exit(___);}
#if 0
#line 5623
{ 
#line 5624
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5625
__asm sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5627
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5628
__asm sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5630
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5631
__asm sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5633
} 
#endif
#line 5641 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5642
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5652
::exit(___);}
#if 0
#line 5642
{ 
#line 5643
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5644
__asm sust.b.a1d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5646
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5647
__asm sust.b.a1d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5649
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5650
__asm sust.b.a1d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5652
} 
#endif
#line 5654 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5655
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5665
::exit(___);}
#if 0
#line 5655
{ 
#line 5656
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5657
__asm sust.b.a1d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5659
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5660
__asm sust.b.a1d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5662
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5663
__asm sust.b.a1d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5665
} 
#endif
#line 5667 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5668
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5678
::exit(___);}
#if 0
#line 5668
{ 
#line 5669
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5670
__asm sust.b.a1d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5672
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5673
__asm sust.b.a1d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5675
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5676
__asm sust.b.a1d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5678
} 
#endif
#line 5680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5681
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5691
::exit(___);}
#if 0
#line 5681
{ 
#line 5682
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5683
__asm sust.b.a1d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5685
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5686
__asm sust.b.a1d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5688
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5689
__asm sust.b.a1d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5691
} 
#endif
#line 5693 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5694
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5704
::exit(___);}
#if 0
#line 5694
{ 
#line 5695
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5696
__asm sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5698
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5699
__asm sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5701
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5702
__asm sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5704
} 
#endif
#line 5706 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5707
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5717
::exit(___);}
#if 0
#line 5707
{ 
#line 5708
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5709
__asm sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5711
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5712
__asm sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5714
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5715
__asm sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5717
} 
#endif
#line 5719 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5720
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5730
::exit(___);}
#if 0
#line 5720
{ 
#line 5721
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5722
__asm sust.b.a1d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5724
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5725
__asm sust.b.a1d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5727
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5728
__asm sust.b.a1d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5730
} 
#endif
#line 5732 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5733
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5743
::exit(___);}
#if 0
#line 5733
{ 
#line 5734
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5735
__asm sust.b.a1d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5737
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5738
__asm sust.b.a1d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5740
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5741
__asm sust.b.a1d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5743
} 
#endif
#line 5745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5746
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5756
::exit(___);}
#if 0
#line 5746
{ 
#line 5747
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5748
__asm sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5750
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5751
__asm sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5753
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5754
__asm sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5756
} 
#endif
#line 5764 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5765
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5775
::exit(___);}
#if 0
#line 5765
{ 
#line 5766
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5767
__asm sust.b.a1d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5769
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5770
__asm sust.b.a1d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5772
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5773
__asm sust.b.a1d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5775
} 
#endif
#line 5777 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5778
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5788
::exit(___);}
#if 0
#line 5778
{ 
#line 5779
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5780
__asm sust.b.a1d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5782
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5783
__asm sust.b.a1d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5785
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5786
__asm sust.b.a1d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5788
} 
#endif
#line 5790 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5791
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5801
::exit(___);}
#if 0
#line 5791
{ 
#line 5792
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5793
__asm sust.b.a1d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5795
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5796
__asm sust.b.a1d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5798
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5799
__asm sust.b.a1d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5801
} 
#endif
#line 5803 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5804
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5814
::exit(___);}
#if 0
#line 5804
{ 
#line 5805
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5806
__asm sust.b.a1d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5808
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5809
__asm sust.b.a1d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5811
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5812
__asm sust.b.a1d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5814
} 
#endif
#line 5816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5817
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5827
::exit(___);}
#if 0
#line 5817
{ 
#line 5818
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5819
__asm sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5821
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5822
__asm sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5824
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5825
__asm sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5827
} 
#endif
#line 5829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5830
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5840
::exit(___);}
#if 0
#line 5830
{ 
#line 5831
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5832
__asm sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5834
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5835
__asm sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5837
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5838
__asm sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5840
} 
#endif
#line 5842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5843
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5853
::exit(___);}
#if 0
#line 5843
{ 
#line 5844
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5845
__asm sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5847
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5848
__asm sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5850
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5851
__asm sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5853
} 
#endif
#line 5861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5862
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5872
::exit(___);}
#if 0
#line 5862
{ 
#line 5863
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5864
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5866
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5867
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5869
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5870
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5872
} 
#endif
#line 5874 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5875
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5885
::exit(___);}
#if 0
#line 5875
{ 
#line 5876
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5877
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5879
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5880
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5882
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5883
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5885
} 
#endif
#line 5887 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5888
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5898
::exit(___);}
#if 0
#line 5888
{ 
#line 5889
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5890
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5892
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5893
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5895
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5896
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5898
} 
#endif
#line 5900 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5901
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5911
::exit(___);}
#if 0
#line 5901
{ 
#line 5902
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5903
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5905
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5906
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5908
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5909
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5911
} 
#endif
#line 5913 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5914
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5924
::exit(___);}
#if 0
#line 5914
{ 
#line 5915
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5916
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5918
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5919
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5921
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5922
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5924
} 
#endif
#line 5926 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5927
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5937
::exit(___);}
#if 0
#line 5927
{ 
#line 5928
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5929
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5931
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5932
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5934
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5935
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5937
} 
#endif
#line 5939 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5940
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5950
::exit(___);}
#if 0
#line 5940
{ 
#line 5941
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5942
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5944
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5945
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5947
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5948
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5950
} 
#endif
#line 5952 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5953
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5963
::exit(___);}
#if 0
#line 5953
{ 
#line 5954
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5955
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5957
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5958
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5960
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5961
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5963
} 
#endif
#line 5965 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5966
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5976
::exit(___);}
#if 0
#line 5966
{ 
#line 5967
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5968
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5970
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5971
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5973
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5974
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5976
} 
#endif
#line 5978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5979
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5989
::exit(___);}
#if 0
#line 5979
{ 
#line 5980
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5981
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5983
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5984
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5986
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5987
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5989
} 
#endif
#line 5991 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5992
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6002
::exit(___);}
#if 0
#line 5992
{ 
#line 5993
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5994
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5996
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5997
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5999
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6000
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6002
} 
#endif
#line 6004 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6005
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6015
::exit(___);}
#if 0
#line 6005
{ 
#line 6006
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6007
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6009
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6010
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6012
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6013
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6015
} 
#endif
#line 6017 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6018
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6028
::exit(___);}
#if 0
#line 6018
{ 
#line 6019
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6020
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6022
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6023
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6025
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6026
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6028
} 
#endif
#line 6030 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6031
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6041
::exit(___);}
#if 0
#line 6031
{ 
#line 6032
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6033
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6035
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6036
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6038
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6039
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6041
} 
#endif
#line 6043 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6044
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6054
::exit(___);}
#if 0
#line 6044
{ 
#line 6045
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6046
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6048
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6049
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6051
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6052
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6054
} 
#endif
#line 6056 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6057
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6067
::exit(___);}
#if 0
#line 6057
{ 
#line 6058
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6059
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6061
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6062
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6064
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6065
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6067
} 
#endif
#line 6069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6070
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6080
::exit(___);}
#if 0
#line 6070
{ 
#line 6071
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6072
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6074
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6075
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6077
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6078
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6080
} 
#endif
#line 6082 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6083
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6093
::exit(___);}
#if 0
#line 6083
{ 
#line 6084
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6085
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6087
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6088
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6090
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6091
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6093
} 
#endif
#line 6095 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6096
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6106
::exit(___);}
#if 0
#line 6096
{ 
#line 6097
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6098
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6100
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6101
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6103
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6104
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6106
} 
#endif
#line 6114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6115
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6125
::exit(___);}
#if 0
#line 6115
{ 
#line 6116
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6117
__asm sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6119
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6120
__asm sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6122
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6123
__asm sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6125
} 
#endif
#line 6127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6128
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6138
::exit(___);}
#if 0
#line 6128
{ 
#line 6129
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6130
__asm sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6132
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6133
__asm sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6135
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6136
__asm sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6138
} 
#endif
#line 6140 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6141
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6151
::exit(___);}
#if 0
#line 6141
{ 
#line 6142
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6143
__asm sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6145
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6146
__asm sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6148
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6149
__asm sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6151
} 
#endif
#line 6153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6154
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6164
::exit(___);}
#if 0
#line 6154
{ 
#line 6155
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6156
__asm sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6158
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6159
__asm sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6161
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6162
__asm sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6164
} 
#endif
#line 6166 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6167
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6177
::exit(___);}
#if 0
#line 6167
{ 
#line 6168
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6169
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6171
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6172
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6174
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6175
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6177
} 
#endif
#line 6179 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6180
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6190
::exit(___);}
#if 0
#line 6180
{ 
#line 6181
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6182
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6184
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6185
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6187
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6188
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6190
} 
#endif
#line 6192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6193
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6203
::exit(___);}
#if 0
#line 6193
{ 
#line 6194
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6195
__asm sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6197
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6198
__asm sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6200
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6201
__asm sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6203
} 
#endif
#line 6205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6206
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6216
::exit(___);}
#if 0
#line 6206
{ 
#line 6207
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6208
__asm sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6210
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6211
__asm sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6213
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6214
__asm sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6216
} 
#endif
#line 6218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6219
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6229
::exit(___);}
#if 0
#line 6219
{ 
#line 6220
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6221
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6223
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6224
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6226
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6227
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6229
} 
#endif
#line 6237 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6238
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6248
::exit(___);}
#if 0
#line 6238
{ 
#line 6239
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6240
__asm sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6242
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6243
__asm sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6245
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6246
__asm sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6248
} 
#endif
#line 6250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6251
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6261
::exit(___);}
#if 0
#line 6251
{ 
#line 6252
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6253
__asm sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6255
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6256
__asm sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6258
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6259
__asm sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6261
} 
#endif
#line 6263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6264
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6274
::exit(___);}
#if 0
#line 6264
{ 
#line 6265
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6266
__asm sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6268
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6269
__asm sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6271
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6272
__asm sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6274
} 
#endif
#line 6276 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6277
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6287
::exit(___);}
#if 0
#line 6277
{ 
#line 6278
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6279
__asm sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6281
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6282
__asm sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6284
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6285
__asm sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6287
} 
#endif
#line 6289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6290
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6300
::exit(___);}
#if 0
#line 6290
{ 
#line 6291
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6292
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6294
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6295
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6297
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6298
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6300
} 
#endif
#line 6302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6303
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6313
::exit(___);}
#if 0
#line 6303
{ 
#line 6304
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6305
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6307
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6308
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6310
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6311
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6313
} 
#endif
#line 6315 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6316
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6326
::exit(___);}
#if 0
#line 6316
{ 
#line 6317
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6318
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6320
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6321
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6323
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6324
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6326
} 
#endif
#line 6334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6335
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6345
::exit(___);}
#if 0
#line 6335
{ 
#line 6336
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6337
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6339
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6340
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6342
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6343
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6345
} 
#endif
#line 6347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6348
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6358
::exit(___);}
#if 0
#line 6348
{ 
#line 6349
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6350
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6352
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6353
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6355
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6356
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6358
} 
#endif
#line 6360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6361
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6371
::exit(___);}
#if 0
#line 6361
{ 
#line 6362
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6363
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6365
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6366
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6368
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6369
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6371
} 
#endif
#line 6373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6374
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6384
::exit(___);}
#if 0
#line 6374
{ 
#line 6375
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6376
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6378
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6379
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6381
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6382
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6384
} 
#endif
#line 6386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6387
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6397
::exit(___);}
#if 0
#line 6387
{ 
#line 6388
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6389
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6391
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6392
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6394
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6395
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6397
} 
#endif
#line 6399 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6400
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6410
::exit(___);}
#if 0
#line 6400
{ 
#line 6401
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6402
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6404
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6405
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6407
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6408
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6410
} 
#endif
#line 6412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6413
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6423
::exit(___);}
#if 0
#line 6413
{ 
#line 6414
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6415
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6417
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6418
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6420
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6421
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6423
} 
#endif
#line 6425 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6426
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6436
::exit(___);}
#if 0
#line 6426
{ 
#line 6427
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6428
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6430
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6431
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6433
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6434
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6436
} 
#endif
#line 6438 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6439
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6449
::exit(___);}
#if 0
#line 6439
{ 
#line 6440
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6441
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6443
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6444
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6446
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6447
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6449
} 
#endif
#line 6451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6452
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6462
::exit(___);}
#if 0
#line 6452
{ 
#line 6453
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6454
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6456
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6457
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6459
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6460
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6462
} 
#endif
#line 6464 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6465
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6475
::exit(___);}
#if 0
#line 6465
{ 
#line 6466
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6467
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6469
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6470
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6472
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6473
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6475
} 
#endif
#line 6477 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6478
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6488
::exit(___);}
#if 0
#line 6478
{ 
#line 6479
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6480
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6482
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6483
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6485
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6486
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6488
} 
#endif
#line 6490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6491
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6501
::exit(___);}
#if 0
#line 6491
{ 
#line 6492
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6493
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6495
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6496
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6498
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6499
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6501
} 
#endif
#line 6503 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6504
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6514
::exit(___);}
#if 0
#line 6504
{ 
#line 6505
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6506
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6508
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6509
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6511
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6512
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6514
} 
#endif
#line 6516 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6517
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6527
::exit(___);}
#if 0
#line 6517
{ 
#line 6518
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6519
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6521
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6522
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6524
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6525
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6527
} 
#endif
#line 6529 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6530
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6540
::exit(___);}
#if 0
#line 6530
{ 
#line 6531
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6532
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6534
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6535
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6537
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6538
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6540
} 
#endif
#line 6542 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6543
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6553
::exit(___);}
#if 0
#line 6543
{ 
#line 6544
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6545
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6547
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6548
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6550
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6551
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6553
} 
#endif
#line 6555 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6556
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6566
::exit(___);}
#if 0
#line 6556
{ 
#line 6557
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6558
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6560
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6561
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6563
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6564
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6566
} 
#endif
#line 6568 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6569
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6579
::exit(___);}
#if 0
#line 6569
{ 
#line 6570
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6571
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6573
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6574
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6576
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6577
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6579
} 
#endif
#line 6587 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6588
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6598
::exit(___);}
#if 0
#line 6588
{ 
#line 6589
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6590
__asm sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6592
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6593
__asm sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6595
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6596
__asm sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6598
} 
#endif
#line 6600 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6601
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6611
::exit(___);}
#if 0
#line 6601
{ 
#line 6602
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6603
__asm sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6605
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6606
__asm sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6608
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6609
__asm sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6611
} 
#endif
#line 6613 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6614
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6624
::exit(___);}
#if 0
#line 6614
{ 
#line 6615
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6616
__asm sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6618
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6619
__asm sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6621
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6622
__asm sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6624
} 
#endif
#line 6626 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6627
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6637
::exit(___);}
#if 0
#line 6627
{ 
#line 6628
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6629
__asm sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6631
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6632
__asm sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6634
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6635
__asm sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6637
} 
#endif
#line 6639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6640
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6650
::exit(___);}
#if 0
#line 6640
{ 
#line 6641
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6642
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6644
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6645
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6647
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6648
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6650
} 
#endif
#line 6652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6653
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6663
::exit(___);}
#if 0
#line 6653
{ 
#line 6654
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6655
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6657
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6658
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6660
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6661
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6663
} 
#endif
#line 6665 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6666
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6676
::exit(___);}
#if 0
#line 6666
{ 
#line 6667
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6668
__asm sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6670
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6671
__asm sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6673
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6674
__asm sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6676
} 
#endif
#line 6678 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6679
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6689
::exit(___);}
#if 0
#line 6679
{ 
#line 6680
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6681
__asm sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6683
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6684
__asm sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6686
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6687
__asm sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6689
} 
#endif
#line 6691 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6692
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6702
::exit(___);}
#if 0
#line 6692
{ 
#line 6693
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6694
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6696
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6697
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6699
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6700
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6702
} 
#endif
#line 6710 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6711
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6721
::exit(___);}
#if 0
#line 6711
{ 
#line 6712
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6713
__asm sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6715
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6716
__asm sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6718
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6719
__asm sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6721
} 
#endif
#line 6723 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6724
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6734
::exit(___);}
#if 0
#line 6724
{ 
#line 6725
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6726
__asm sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6728
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6729
__asm sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6731
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6732
__asm sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6734
} 
#endif
#line 6736 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6737
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6747
::exit(___);}
#if 0
#line 6737
{ 
#line 6738
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6739
__asm sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6741
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6742
__asm sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6744
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6745
__asm sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6747
} 
#endif
#line 6749 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6750
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6760
::exit(___);}
#if 0
#line 6750
{ 
#line 6751
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6752
__asm sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6754
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6755
__asm sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6757
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6758
__asm sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6760
} 
#endif
#line 6762 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6763
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6773
::exit(___);}
#if 0
#line 6763
{ 
#line 6764
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6765
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6767
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6768
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6770
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6771
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6773
} 
#endif
#line 6775 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6776
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6786
::exit(___);}
#if 0
#line 6776
{ 
#line 6777
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6778
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6780
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6781
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6783
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6784
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6786
} 
#endif
#line 6788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6789
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6799
::exit(___);}
#if 0
#line 6789
{ 
#line 6790
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6791
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6793
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6794
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6796
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6797
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6799
} 
#endif
#line 6807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6808
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6818
::exit(___);}
#if 0
#line 6808
{ 
#line 6809
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6810
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6812
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6813
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6815
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6816
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6818
} 
#endif
#line 6820 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6821
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6831
::exit(___);}
#if 0
#line 6821
{ 
#line 6822
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6823
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6825
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6826
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6828
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6829
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6831
} 
#endif
#line 6833 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6834
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6844
::exit(___);}
#if 0
#line 6834
{ 
#line 6835
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6836
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6838
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6839
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6841
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6842
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6844
} 
#endif
#line 6846 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6847
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6857
::exit(___);}
#if 0
#line 6847
{ 
#line 6848
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6849
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6851
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6852
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6854
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6855
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6857
} 
#endif
#line 6859 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6860
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6870
::exit(___);}
#if 0
#line 6860
{ 
#line 6861
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6862
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6864
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6865
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6867
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6868
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6870
} 
#endif
#line 6872 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6873
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6883
::exit(___);}
#if 0
#line 6873
{ 
#line 6874
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6875
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6877
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6878
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6880
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6881
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6883
} 
#endif
#line 6885 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6886
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6896
::exit(___);}
#if 0
#line 6886
{ 
#line 6887
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6888
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6890
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6891
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6893
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6894
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6896
} 
#endif
#line 6898 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6899
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6909
::exit(___);}
#if 0
#line 6899
{ 
#line 6900
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6901
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6903
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6904
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6906
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6907
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6909
} 
#endif
#line 6911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6912
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6922
::exit(___);}
#if 0
#line 6912
{ 
#line 6913
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6914
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6916
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6917
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6919
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6920
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6922
} 
#endif
#line 6924 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6925
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6935
::exit(___);}
#if 0
#line 6925
{ 
#line 6926
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6927
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6929
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6930
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6932
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6933
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6935
} 
#endif
#line 6937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6938
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6948
::exit(___);}
#if 0
#line 6938
{ 
#line 6939
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6940
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6942
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6943
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6945
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6946
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6948
} 
#endif
#line 6950 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6951
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6961
::exit(___);}
#if 0
#line 6951
{ 
#line 6952
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6953
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6955
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6956
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6958
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6959
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6961
} 
#endif
#line 6963 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6964
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6974
::exit(___);}
#if 0
#line 6964
{ 
#line 6965
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6966
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6968
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6969
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6971
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6972
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6974
} 
#endif
#line 6976 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6977
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6987
::exit(___);}
#if 0
#line 6977
{ 
#line 6978
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6979
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6981
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6982
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6984
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6985
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6987
} 
#endif
#line 6989 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6990
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7000
::exit(___);}
#if 0
#line 6990
{ 
#line 6991
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6992
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6994
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6995
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6997
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6998
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 7000
} 
#endif
#line 7002 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7003
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7013
::exit(___);}
#if 0
#line 7003
{ 
#line 7004
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7005
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7007
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7008
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7010
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7011
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 7013
} 
#endif
#line 7015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7016
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7026
::exit(___);}
#if 0
#line 7016
{ 
#line 7017
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7018
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7020
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7021
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7023
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7024
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 7026
} 
#endif
#line 7028 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7029
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7039
::exit(___);}
#if 0
#line 7029
{ 
#line 7030
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7031
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7033
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7034
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7036
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7037
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 7039
} 
#endif
#line 7041 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7042
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7052
::exit(___);}
#if 0
#line 7042
{ 
#line 7043
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7044
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7046
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7047
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7049
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7050
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 7052
} 
#endif
#line 7060 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7061
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7071
::exit(___);}
#if 0
#line 7061
{ 
#line 7062
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7063
__asm sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7065
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7066
__asm sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7068
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7069
__asm sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7071
} 
#endif
#line 7073 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7074
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7084
::exit(___);}
#if 0
#line 7074
{ 
#line 7075
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7076
__asm sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7078
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7079
__asm sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7081
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7082
__asm sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7084
} 
#endif
#line 7086 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7087
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7097
::exit(___);}
#if 0
#line 7087
{ 
#line 7088
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7089
__asm sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7091
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7092
__asm sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7094
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7095
__asm sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7097
} 
#endif
#line 7099 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7100
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7110
::exit(___);}
#if 0
#line 7100
{ 
#line 7101
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7102
__asm sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7104
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7105
__asm sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7107
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7108
__asm sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7110
} 
#endif
#line 7112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7113
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7123
::exit(___);}
#if 0
#line 7113
{ 
#line 7114
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7115
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7117
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7118
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7120
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7121
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7123
} 
#endif
#line 7125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7126
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7136
::exit(___);}
#if 0
#line 7126
{ 
#line 7127
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7128
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7130
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7131
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7133
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7134
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7136
} 
#endif
#line 7138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7139
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7149
::exit(___);}
#if 0
#line 7139
{ 
#line 7140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7141
__asm sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7144
__asm sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7146
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7147
__asm sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7149
} 
#endif
#line 7151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7152
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7162
::exit(___);}
#if 0
#line 7152
{ 
#line 7153
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7154
__asm sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7156
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7157
__asm sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7159
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7160
__asm sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7162
} 
#endif
#line 7164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7165
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7175
::exit(___);}
#if 0
#line 7165
{ 
#line 7166
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7167
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7169
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7170
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7172
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7173
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7175
} 
#endif
#line 7183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7184
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7194
::exit(___);}
#if 0
#line 7184
{ 
#line 7185
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7186
__asm sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7188
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7189
__asm sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7191
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7192
__asm sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7194
} 
#endif
#line 7196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7197
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7207
::exit(___);}
#if 0
#line 7197
{ 
#line 7198
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7199
__asm sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7201
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7202
__asm sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7204
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7205
__asm sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7207
} 
#endif
#line 7209 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7210
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7220
::exit(___);}
#if 0
#line 7210
{ 
#line 7211
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7212
__asm sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7214
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7215
__asm sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7217
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7218
__asm sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7220
} 
#endif
#line 7222 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7223
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7233
::exit(___);}
#if 0
#line 7223
{ 
#line 7224
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7225
__asm sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7227
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7228
__asm sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7230
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7231
__asm sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7233
} 
#endif
#line 7235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7236
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7246
::exit(___);}
#if 0
#line 7236
{ 
#line 7237
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7238
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7240
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7241
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7243
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7244
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7246
} 
#endif
#line 7248 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7249
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7259
::exit(___);}
#if 0
#line 7249
{ 
#line 7250
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7251
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7253
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7254
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7256
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7257
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7259
} 
#endif
#line 7261 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7262
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7272
::exit(___);}
#if 0
#line 7262
{ 
#line 7263
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7264
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7266
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7267
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7269
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7270
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7272
} 
#endif
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\device_launch_parameters.h"
extern "C" const uint3 threadIdx; 
#line 67
extern "C" const uint3 blockIdx; 
#line 68
extern "C" const dim3 blockDim; 
#line 69
extern "C" const dim3 gridDim; 
#line 70
extern "C" const int warpSize; 
#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v5.5\\include\\cuda_device_runtime_api.h"
namespace _GLOBAL__N__14_kernel_cpp1_ii_b614c5e6 { }; using namespace _GLOBAL__N__14_kernel_cpp1_ii_b614c5e6; namespace _GLOBAL__N__14_kernel_cpp1_ii_b614c5e6 { 
#line 123 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"
template< class T> __inline ::cudaError_t 
#line 124
cudaSetupArgument(T 
#line 125
arg, ::size_t 
#line 126
offset) 
#line 128
{ 
#line 129
return ::cudaSetupArgument((const void *)(&arg), sizeof(T), offset); 
#line 130
} 
#line 162
static __inline cudaError_t cudaEventCreate(cudaEvent_t *
#line 163
event, unsigned 
#line 164
flags) 
#line 166
{ 
#line 167
return ::cudaEventCreateWithFlags(event, flags); 
#line 168
} 
#line 225
__inline cudaError_t cudaMallocHost(void **
#line 226
ptr, size_t 
#line 227
size, unsigned 
#line 228
flags) 
#line 230
{ 
#line 231
return ::cudaHostAlloc(ptr, size, flags); 
#line 232
} 
#line 234
template< class T> __inline ::cudaError_t 
#line 235
cudaHostAlloc(T **
#line 236
ptr, ::size_t 
#line 237
size, unsigned 
#line 238
flags) 
#line 240
{ 
#line 241
return ::cudaHostAlloc((void **)((void *)ptr), size, flags); 
#line 242
} 
#line 244
template< class T> __inline ::cudaError_t 
#line 245
cudaHostGetDevicePointer(T **
#line 246
pDevice, void *
#line 247
pHost, unsigned 
#line 248
flags) 
#line 250
{ 
#line 251
return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
#line 252
} 
#line 254
template< class T> __inline ::cudaError_t 
#line 255
cudaMalloc(T **
#line 256
devPtr, ::size_t 
#line 257
size) 
#line 259
{ 
#line 260
return ::cudaMalloc((void **)((void *)devPtr), size); 
#line 261
} 
#line 263
template< class T> __inline ::cudaError_t 
#line 264
cudaMallocHost(T **
#line 265
ptr, ::size_t 
#line 266
size, unsigned 
#line 267
flags = 0) 
#line 269
{ 
#line 270
return cudaMallocHost((void **)((void *)ptr), size, flags); 
#line 271
} 
#line 273
template< class T> __inline ::cudaError_t 
#line 274
cudaMallocPitch(T **
#line 275
devPtr, ::size_t *
#line 276
pitch, ::size_t 
#line 277
width, ::size_t 
#line 278
height) 
#line 280
{ 
#line 281
return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
#line 282
} 
#line 319
template< class T> __inline ::cudaError_t 
#line 320
cudaMemcpyToSymbol(const T &
#line 321
symbol, const void *
#line 322
src, ::size_t 
#line 323
count, ::size_t 
#line 324
offset = 0, ::cudaMemcpyKind 
#line 325
kind = cudaMemcpyHostToDevice) 
#line 327
{ 
#line 328
return ::cudaMemcpyToSymbol((const void *)(&symbol), src, count, offset, kind); 
#line 329
} 
#line 371
template< class T> __inline ::cudaError_t 
#line 372
cudaMemcpyToSymbolAsync(const T &
#line 373
symbol, const void *
#line 374
src, ::size_t 
#line 375
count, ::size_t 
#line 376
offset = 0, ::cudaMemcpyKind 
#line 377
kind = cudaMemcpyHostToDevice, ::cudaStream_t 
#line 378
stream = 0) 
#line 380
{ 
#line 381
return ::cudaMemcpyToSymbolAsync((const void *)(&symbol), src, count, offset, kind, stream); 
#line 382
} 
#line 417
template< class T> __inline ::cudaError_t 
#line 418
cudaMemcpyFromSymbol(void *
#line 419
dst, const T &
#line 420
symbol, ::size_t 
#line 421
count, ::size_t 
#line 422
offset = 0, ::cudaMemcpyKind 
#line 423
kind = cudaMemcpyDeviceToHost) 
#line 425
{ 
#line 426
return ::cudaMemcpyFromSymbol(dst, (const void *)(&symbol), count, offset, kind); 
#line 427
} 
#line 469
template< class T> __inline ::cudaError_t 
#line 470
cudaMemcpyFromSymbolAsync(void *
#line 471
dst, const T &
#line 472
symbol, ::size_t 
#line 473
count, ::size_t 
#line 474
offset = 0, ::cudaMemcpyKind 
#line 475
kind = cudaMemcpyDeviceToHost, ::cudaStream_t 
#line 476
stream = 0) 
#line 478
{ 
#line 479
return ::cudaMemcpyFromSymbolAsync(dst, (const void *)(&symbol), count, offset, kind, stream); 
#line 480
} 
#line 502
template< class T> __inline ::cudaError_t 
#line 503
cudaGetSymbolAddress(void **
#line 504
devPtr, const T &
#line 505
symbol) 
#line 507
{ 
#line 508
return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol)); 
#line 509
} 
#line 531
template< class T> __inline ::cudaError_t 
#line 532
cudaGetSymbolSize(::size_t *
#line 533
size, const T &
#line 534
symbol) 
#line 536
{ 
#line 537
return ::cudaGetSymbolSize(size, (const void *)(&symbol)); 
#line 538
} 
#line 574
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 575
cudaBindTexture(::size_t *
#line 576
offset, const texture< T, dim, readMode>  &
#line 577
tex, const void *
#line 578
devPtr, const ::cudaChannelFormatDesc &
#line 579
desc, ::size_t 
#line 580
size = 4294967295U) 
#line 582
{ 
#line 583
return ::cudaBindTexture(offset, &tex, devPtr, &desc, size); 
#line 584
} 
#line 619
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 620
cudaBindTexture(::size_t *
#line 621
offset, const texture< T, dim, readMode>  &
#line 622
tex, const void *
#line 623
devPtr, ::size_t 
#line 624
size = 4294967295U) 
#line 626
{ 
#line 627
return cudaBindTexture(offset, tex, devPtr, (tex.channelDesc), size); 
#line 628
} 
#line 675
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 676
cudaBindTexture2D(::size_t *
#line 677
offset, const texture< T, dim, readMode>  &
#line 678
tex, const void *
#line 679
devPtr, const ::cudaChannelFormatDesc &
#line 680
desc, ::size_t 
#line 681
width, ::size_t 
#line 682
height, ::size_t 
#line 683
pitch) 
#line 685
{ 
#line 686
return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch); 
#line 687
} 
#line 733
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 734
cudaBindTexture2D(::size_t *
#line 735
offset, const texture< T, dim, readMode>  &
#line 736
tex, const void *
#line 737
devPtr, ::size_t 
#line 738
width, ::size_t 
#line 739
height, ::size_t 
#line 740
pitch) 
#line 742
{ 
#line 743
return ::cudaBindTexture2D(offset, &tex, devPtr, &(tex.channelDesc), width, height, pitch); 
#line 744
} 
#line 775
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 776
cudaBindTextureToArray(const texture< T, dim, readMode>  &
#line 777
tex, ::cudaArray_const_t 
#line 778
array, const ::cudaChannelFormatDesc &
#line 779
desc) 
#line 781
{ 
#line 782
return ::cudaBindTextureToArray(&tex, array, &desc); 
#line 783
} 
#line 813
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 814
cudaBindTextureToArray(const texture< T, dim, readMode>  &
#line 815
tex, ::cudaArray_const_t 
#line 816
array) 
#line 818
{ 
#line 819
::cudaChannelFormatDesc desc; 
#line 820
::cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
#line 822
return (err == (cudaSuccess)) ? cudaBindTextureToArray(tex, array, desc) : err; 
#line 823
} 
#line 854
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 855
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
#line 856
tex, ::cudaMipmappedArray_const_t 
#line 857
mipmappedArray, const ::cudaChannelFormatDesc &
#line 858
desc) 
#line 860
{ 
#line 861
return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc); 
#line 862
} 
#line 892
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 893
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
#line 894
tex, ::cudaMipmappedArray_const_t 
#line 895
mipmappedArray) 
#line 897
{ 
#line 898
::cudaChannelFormatDesc desc; 
#line 899
::cudaArray_t levelArray; 
#line 900
::cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0); 
#line 902
if (err != (cudaSuccess)) { 
#line 903
return err; 
#line 904
}  
#line 905
err = ::cudaGetChannelDesc(&desc, levelArray); 
#line 907
return (err == (cudaSuccess)) ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err; 
#line 908
} 
#line 931
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 932
cudaUnbindTexture(const texture< T, dim, readMode>  &
#line 933
tex) 
#line 935
{ 
#line 936
return ::cudaUnbindTexture(&tex); 
#line 937
} 
#line 965
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 966
cudaGetTextureAlignmentOffset(::size_t *
#line 967
offset, const texture< T, dim, readMode>  &
#line 968
tex) 
#line 970
{ 
#line 971
return ::cudaGetTextureAlignmentOffset(offset, &tex); 
#line 972
} 
#line 1018
template< class T> __inline ::cudaError_t 
#line 1019
cudaFuncSetCacheConfig(T *
#line 1020
func, ::cudaFuncCache 
#line 1021
cacheConfig) 
#line 1023
{ 
#line 1024
return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig); 
#line 1025
} 
#line 1027
template< class T> __inline ::cudaError_t 
#line 1028
cudaFuncSetSharedMemConfig(T *
#line 1029
func, ::cudaSharedMemConfig 
#line 1030
config) 
#line 1032
{ 
#line 1033
return ::cudaFuncSetSharedMemConfig((const void *)func, config); 
#line 1034
} 
#line 1070
template< class T> __inline ::cudaError_t 
#line 1071
cudaLaunch(T *
#line 1072
func) 
#line 1074
{ 
#line 1075
return ::cudaLaunch((const void *)func); 
#line 1076
} 
#line 1108
template< class T> __inline ::cudaError_t 
#line 1109
cudaFuncGetAttributes(::cudaFuncAttributes *
#line 1110
attr, T *
#line 1111
entry) 
#line 1113
{ 
#line 1114
return ::cudaFuncGetAttributes(attr, (const void *)entry); 
#line 1115
} 
#line 1137
template< class T, int dim> __inline ::cudaError_t 
#line 1138
cudaBindSurfaceToArray(const surface< T, dim>  &
#line 1139
surf, ::cudaArray_const_t 
#line 1140
array, const ::cudaChannelFormatDesc &
#line 1141
desc) 
#line 1143
{ 
#line 1144
return ::cudaBindSurfaceToArray(&surf, array, &desc); 
#line 1145
} 
#line 1166
template< class T, int dim> __inline ::cudaError_t 
#line 1167
cudaBindSurfaceToArray(const surface< T, dim>  &
#line 1168
surf, ::cudaArray_const_t 
#line 1169
array) 
#line 1171
{ 
#line 1172
::cudaChannelFormatDesc desc; 
#line 1173
::cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
#line 1175
return (err == (cudaSuccess)) ? cudaBindSurfaceToArray(surf, array, desc) : err; 
#line 1176
} 
#line 1182 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.5\\include\\cuda_runtime.h"
}
#line 26 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
#pragma pack ( push, 8 )
#line 56 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { struct _iobuf { 
#line 57
char *_ptr; 
#line 58
int _cnt; 
#line 59
char *_base; 
#line 60
int _flag; 
#line 61
int _file; 
#line 62
int _charbuf; 
#line 63
int _bufsiz; 
#line 64
char *_tmpfname; 
#line 65
}; }
#line 66
extern "C" { typedef _iobuf FILE; }
#line 129 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) FILE *__cdecl __iob_func(); } 
#line 136 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { typedef __int64 fpos_t; }
#line 170 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _filbuf(FILE * ); } 
#line 171
extern "C" { __declspec(dllimport) int __cdecl _flsbuf(int , FILE * ); } 
#line 176
extern "C" { __declspec(dllimport) FILE *__cdecl _fsopen(const char * , const char * , int ); } 
#line 179 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) void __cdecl clearerr(FILE * ); } 
#line 181
extern "C" { __declspec(dllimport) errno_t __cdecl clearerr_s(FILE * ); } 
#line 183 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fclose(FILE * ); } 
#line 184
extern "C" { __declspec(dllimport) int __cdecl _fcloseall(); } 
#line 189
extern "C" { __declspec(dllimport) FILE *__cdecl _fdopen(int , const char * ); } 
#line 192 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl feof(FILE * ); } 
#line 193
extern "C" { __declspec(dllimport) int __cdecl ferror(FILE * ); } 
#line 194
extern "C" { __declspec(dllimport) int __cdecl fflush(FILE * ); } 
#line 195
extern "C" { __declspec(dllimport) int __cdecl fgetc(FILE * ); } 
#line 196
extern "C" { __declspec(dllimport) int __cdecl _fgetchar(); } 
#line 197
extern "C" { __declspec(dllimport) int __cdecl fgetpos(FILE * , fpos_t * ); } 
#line 198
extern "C" { __declspec(dllimport) char *__cdecl fgets(char * , int , FILE * ); } 
#line 203
extern "C" { __declspec(dllimport) int __cdecl _fileno(FILE * ); } 
#line 211 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) char *__cdecl _tempnam(const char * , const char * ); } 
#line 217 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _flushall(); } 
#line 218
extern "C" { __declspec(dllimport) FILE *__cdecl fopen(const char * , const char * ); } 
#line 220
extern "C" { __declspec(dllimport) errno_t __cdecl fopen_s(FILE ** , const char * , const char * ); } 
#line 222 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fprintf(FILE * , const char * , ...); } 
#line 224
extern "C" { __declspec(dllimport) int __cdecl fprintf_s(FILE * , const char * , ...); } 
#line 226 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fputc(int , FILE * ); } 
#line 227
extern "C" { __declspec(dllimport) int __cdecl _fputchar(int ); } 
#line 228
extern "C" { __declspec(dllimport) int __cdecl fputs(const char * , FILE * ); } 
#line 229
extern "C" { __declspec(dllimport) size_t __cdecl fread(void * , size_t , size_t , FILE * ); } 
#line 231
extern "C" { __declspec(dllimport) size_t __cdecl fread_s(void * , size_t , size_t , size_t , FILE * ); } 
#line 233 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) FILE *__cdecl freopen(const char * , const char * , FILE * ); } 
#line 235
extern "C" { __declspec(dllimport) errno_t __cdecl freopen_s(FILE ** , const char * , const char * , FILE * ); } 
#line 237 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fscanf(FILE * , const char * , ...); } 
#line 238
extern "C" { __declspec(dllimport) int __cdecl _fscanf_l(FILE * , const char * , _locale_t , ...); } 
#pragma warning(push)
#pragma warning(disable:6530)
#line 242
extern "C" { __declspec(dllimport) int __cdecl fscanf_s(FILE * , const char * , ...); } 
#line 244 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _fscanf_s_l(FILE * , const char * , _locale_t , ...); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) int __cdecl fsetpos(FILE * , const fpos_t * ); } 
#line 247
extern "C" { __declspec(dllimport) int __cdecl fseek(FILE * , long , int ); } 
#line 248
extern "C" { __declspec(dllimport) long __cdecl ftell(FILE * ); } 
#line 250
extern "C" { __declspec(dllimport) int __cdecl _fseeki64(FILE * , __int64 , int ); } 
#line 251
extern "C" { __declspec(dllimport) __int64 __cdecl _ftelli64(FILE * ); } 
#line 253
extern "C" { __declspec(dllimport) size_t __cdecl fwrite(const void * , size_t , size_t , FILE * ); } 
#line 254
extern "C" { __declspec(dllimport) int __cdecl getc(FILE * ); } 
#line 255
extern "C" { __declspec(dllimport) int __cdecl getchar(); } 
#line 256
extern "C" { __declspec(dllimport) int __cdecl _getmaxstdio(); } 
#line 258
extern "C" { __declspec(dllimport) char *__cdecl gets_s(char * , rsize_t ); } 
#line 260 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
template < size_t _Size > inline char * __cdecl gets_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return gets_s ( _Buffer, _Size ); }
#line 261
extern "C" { __declspec(dllimport) char *__cdecl gets(char * ); } 
#line 262
extern "C" { int __cdecl _getw(FILE * ); } 
#line 268
extern "C" { __declspec(dllimport) int __cdecl _pclose(FILE * ); } 
#line 269
extern "C" { __declspec(dllimport) FILE *__cdecl _popen(const char * , const char * ); } 
#line 271 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl printf(const char * , ...); } 
#line 273
extern "C" { __declspec(dllimport) int __cdecl printf_s(const char * , ...); } 
#line 275 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl putc(int , FILE * ); } 
#line 276
extern "C" { __declspec(dllimport) int __cdecl putchar(int ); } 
#line 277
extern "C" { __declspec(dllimport) int __cdecl puts(const char * ); } 
#line 278
extern "C" { __declspec(dllimport) int __cdecl _putw(int , FILE * ); } 
#line 281
extern "C" { __declspec(dllimport) int __cdecl remove(const char * ); } 
#line 282
extern "C" { __declspec(dllimport) int __cdecl rename(const char * , const char * ); } 
#line 283
extern "C" { __declspec(dllimport) int __cdecl _unlink(const char * ); } 
#line 285
extern "C" { __declspec(dllimport) int __cdecl unlink(const char * ); } 
#line 288 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) void __cdecl rewind(FILE * ); } 
#line 289
extern "C" { __declspec(dllimport) int __cdecl _rmtmp(); } 
#line 290
extern "C" { __declspec(dllimport) int __cdecl scanf(const char * , ...); } 
#line 291
extern "C" { __declspec(dllimport) int __cdecl _scanf_l(const char * , _locale_t , ...); } 
#pragma warning(push)
#pragma warning(disable:6530)
#line 295
extern "C" { __declspec(dllimport) int __cdecl scanf_s(const char * , ...); } 
#line 297 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _scanf_s_l(const char * , _locale_t , ...); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) void __cdecl setbuf(FILE * , char * ); } 
#line 300
extern "C" { __declspec(dllimport) int __cdecl _setmaxstdio(int ); } 
#line 301
extern "C" { __declspec(dllimport) unsigned __cdecl _set_output_format(unsigned ); } 
#line 302
extern "C" { __declspec(dllimport) unsigned __cdecl _get_output_format(); } 
#line 303
extern "C" { __declspec(dllimport) int __cdecl setvbuf(FILE * , char * , int , size_t ); } 
#line 304
extern "C" { __declspec(dllimport) int __cdecl _snprintf_s(char * , size_t , size_t , const char * , ...); } 
#line 305
__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl _snprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, ... ) throw ( ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return _vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _ArgList ); }__pragma( warning(pop)) 
#line 307
extern "C" { __declspec(dllimport) int __cdecl sprintf_s(char * , size_t , const char * , ...); } 
#line 309 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl sprintf_s ( char ( & _Dest ) [ _Size ], const char * _Format, ... ) throw ( ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return vsprintf_s ( _Dest, _Size, _Format, _ArgList ); }__pragma( warning(pop)) 
#line 310
extern "C" { __declspec(dllimport) int __cdecl _scprintf(const char * , ...); } 
#line 311
extern "C" { __declspec(dllimport) int __cdecl sscanf(const char * , const char * , ...); } 
#line 312
extern "C" { __declspec(dllimport) int __cdecl _sscanf_l(const char * , const char * , _locale_t , ...); } 
#pragma warning(push)
#pragma warning(disable:6530)
#line 316
extern "C" { __declspec(dllimport) int __cdecl sscanf_s(const char * , const char * , ...); } 
#line 318 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _sscanf_s_l(const char * , const char * , _locale_t , ...); } 
#line 319
extern "C" { __declspec(dllimport) int __cdecl _snscanf(const char * , size_t , const char * , ...); } 
#line 320
extern "C" { __declspec(dllimport) int __cdecl _snscanf_l(const char * , size_t , const char * , _locale_t , ...); } 
#line 321
extern "C" { __declspec(dllimport) int __cdecl _snscanf_s(const char * , size_t , const char * , ...); } 
#line 322
extern "C" { __declspec(dllimport) int __cdecl _snscanf_s_l(const char * , size_t , const char * , _locale_t , ...); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) FILE *__cdecl tmpfile(); } 
#line 326
extern "C" { __declspec(dllimport) errno_t __cdecl tmpfile_s(FILE ** ); } 
#line 327
extern "C" { __declspec(dllimport) errno_t __cdecl tmpnam_s(char * , rsize_t ); } 
#line 329 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
template < size_t _Size > inline errno_t __cdecl tmpnam_s ( char ( & _Buf ) [ _Size ] ) throw ( ) { return tmpnam_s ( _Buf, _Size ); }
#line 330
extern "C" { __declspec(dllimport) char *__cdecl tmpnam(char * ); } 
#line 331
extern "C" { __declspec(dllimport) int __cdecl ungetc(int , FILE * ); } 
#line 332
extern "C" { __declspec(dllimport) int __cdecl vfprintf(FILE * , const char * , va_list ); } 
#line 334
extern "C" { __declspec(dllimport) int __cdecl vfprintf_s(FILE * , const char * , va_list ); } 
#line 336 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl vprintf(const char * , va_list ); } 
#line 338
extern "C" { __declspec(dllimport) int __cdecl vprintf_s(const char * , va_list ); } 
#line 340 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl vsnprintf(char * , size_t , const char * , va_list ); } 
#line 342
extern "C" { __declspec(dllimport) int __cdecl vsnprintf_s(char * , size_t , size_t , const char * , va_list ); } 
#line 343
template < size_t _Size > inline int __cdecl vsnprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, va_list _Args ) throw ( ) { return vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _Args ); }
#line 345 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_s(char * , size_t , size_t , const char * , va_list ); } 
#line 346
template < size_t _Size > inline int __cdecl _vsnprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, va_list _Args ) throw ( ) { return _vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _Args ); }
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { __declspec(dllimport) int __cdecl _snprintf(char * , size_t , const char * , ...); } extern "C" { __declspec(dllimport) int __cdecl _vsnprintf(char * , size_t , const char * , va_list ); } 
#pragma warning(pop)
#line 352
extern "C" { __declspec(dllimport) int __cdecl vsprintf_s(char * , size_t , const char * , va_list ); } 
#line 353
template < size_t _Size > inline int __cdecl vsprintf_s ( char ( & _Dest ) [ _Size ], const char * _Format, va_list _Args ) throw ( ) { return vsprintf_s ( _Dest, _Size, _Format, _Args ); }
#line 355 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { __declspec(dllimport) int __cdecl sprintf(char * , const char * , ...); } extern "C" { __declspec(dllimport) int __cdecl vsprintf(char * , const char * , va_list ); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) int __cdecl _vscprintf(const char * , va_list ); } 
#line 360
extern "C" { __declspec(dllimport) int __cdecl _snprintf_c(char * , size_t , const char * , ...); } 
#line 361
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_c(char * , size_t , const char * , va_list ); } 
#line 363
extern "C" { __declspec(dllimport) int __cdecl _fprintf_p(FILE * , const char * , ...); } 
#line 364
extern "C" { __declspec(dllimport) int __cdecl _printf_p(const char * , ...); } 
#line 365
extern "C" { __declspec(dllimport) int __cdecl _sprintf_p(char * , size_t , const char * , ...); } 
#line 366
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_p(FILE * , const char * , va_list ); } 
#line 367
extern "C" { __declspec(dllimport) int __cdecl _vprintf_p(const char * , va_list ); } 
#line 368
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_p(char * , size_t , const char * , va_list ); } 
#line 369
extern "C" { __declspec(dllimport) int __cdecl _scprintf_p(const char * , ...); } 
#line 370
extern "C" { __declspec(dllimport) int __cdecl _vscprintf_p(const char * , va_list ); } 
#line 371
extern "C" { __declspec(dllimport) int __cdecl _set_printf_count_output(int ); } 
#line 372
extern "C" { __declspec(dllimport) int __cdecl _get_printf_count_output(); } 
#line 374
extern "C" { __declspec(dllimport) int __cdecl _printf_l(const char * , _locale_t , ...); } 
#line 375
extern "C" { __declspec(dllimport) int __cdecl _printf_p_l(const char * , _locale_t , ...); } 
#line 376
extern "C" { __declspec(dllimport) int __cdecl _printf_s_l(const char * , _locale_t , ...); } 
#line 377
extern "C" { __declspec(dllimport) int __cdecl _vprintf_l(const char * , _locale_t , va_list ); } 
#line 378
extern "C" { __declspec(dllimport) int __cdecl _vprintf_p_l(const char * , _locale_t , va_list ); } 
#line 379
extern "C" { __declspec(dllimport) int __cdecl _vprintf_s_l(const char * , _locale_t , va_list ); } 
#line 381
extern "C" { __declspec(dllimport) int __cdecl _fprintf_l(FILE * , const char * , _locale_t , ...); } 
#line 382
extern "C" { __declspec(dllimport) int __cdecl _fprintf_p_l(FILE * , const char * , _locale_t , ...); } 
#line 383
extern "C" { __declspec(dllimport) int __cdecl _fprintf_s_l(FILE * , const char * , _locale_t , ...); } 
#line 384
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_l(FILE * , const char * , _locale_t , va_list ); } 
#line 385
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_p_l(FILE * , const char * , _locale_t , va_list ); } 
#line 386
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_s_l(FILE * , const char * , _locale_t , va_list ); } 
#line 388
extern "C" { __declspec(dllimport) int __cdecl _sprintf_l(char * , const char * , _locale_t , ...); } 
#line 389
extern "C" { __declspec(dllimport) int __cdecl _sprintf_p_l(char * , size_t , const char * , _locale_t , ...); } 
#line 390
extern "C" { __declspec(dllimport) int __cdecl _sprintf_s_l(char * , size_t , const char * , _locale_t , ...); } 
#line 391
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_l(char * , const char * , _locale_t, va_list ); } 
#line 392
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_p_l(char * , size_t , const char * , _locale_t , va_list ); } 
#line 393
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_s_l(char * , size_t , const char * , _locale_t , va_list ); } 
#line 395
extern "C" { __declspec(dllimport) int __cdecl _scprintf_l(const char * , _locale_t , ...); } 
#line 396
extern "C" { __declspec(dllimport) int __cdecl _scprintf_p_l(const char * , _locale_t , ...); } 
#line 397
extern "C" { __declspec(dllimport) int __cdecl _vscprintf_l(const char * , _locale_t , va_list ); } 
#line 398
extern "C" { __declspec(dllimport) int __cdecl _vscprintf_p_l(const char * , _locale_t , va_list ); } 
#line 400
extern "C" { __declspec(dllimport) int __cdecl _snprintf_l(char * , size_t , const char * , _locale_t , ...); } 
#line 401
extern "C" { __declspec(dllimport) int __cdecl _snprintf_c_l(char * , size_t , const char * , _locale_t , ...); } 
#line 402
extern "C" { __declspec(dllimport) int __cdecl _snprintf_s_l(char * , size_t , size_t , const char * , _locale_t , ...); } 
#line 403
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_l(char * , size_t , const char * , _locale_t , va_list ); } 
#line 404
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_c_l(char * , size_t , const char *, _locale_t , va_list ); } 
#line 405
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_s_l(char * , size_t , size_t , const char * , _locale_t , va_list ); } 
#line 418 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) FILE *__cdecl _wfsopen(const __wchar_t * , const __wchar_t * , int ); } 
#line 421 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) wint_t __cdecl fgetwc(FILE * ); } 
#line 422
extern "C" { __declspec(dllimport) wint_t __cdecl _fgetwchar(); } 
#line 423
extern "C" { __declspec(dllimport) wint_t __cdecl fputwc(__wchar_t , FILE * ); } 
#line 424
extern "C" { __declspec(dllimport) wint_t __cdecl _fputwchar(__wchar_t ); } 
#line 425
extern "C" { __declspec(dllimport) wint_t __cdecl getwc(FILE * ); } 
#line 426
extern "C" { __declspec(dllimport) inline wint_t __cdecl getwchar(); } 
#line 427
extern "C" { __declspec(dllimport) wint_t __cdecl putwc(__wchar_t , FILE * ); } 
#line 428
extern "C" { __declspec(dllimport) inline wint_t __cdecl putwchar(__wchar_t ); } 
#line 429
extern "C" { __declspec(dllimport) wint_t __cdecl ungetwc(wint_t , FILE * ); } 
#line 431
extern "C" { __declspec(dllimport) __wchar_t *__cdecl fgetws(__wchar_t * , int , FILE * ); } 
#line 432
extern "C" { __declspec(dllimport) int __cdecl fputws(const __wchar_t * , FILE * ); } 
#line 433
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _getws_s(__wchar_t * , size_t ); } 
#line 434
template < size_t _Size > inline wchar_t * __cdecl _getws_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _getws_s ( _String, _Size ); }
#line 435
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _getws(__wchar_t * ); } 
#line 436
extern "C" { __declspec(dllimport) int __cdecl _putws(const __wchar_t * ); } 
#line 438
extern "C" { __declspec(dllimport) int __cdecl fwprintf(FILE * , const __wchar_t * , ...); } 
#line 440
extern "C" { __declspec(dllimport) int __cdecl fwprintf_s(FILE * , const __wchar_t * , ...); } 
#line 442 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl wprintf(const __wchar_t * , ...); } 
#line 444
extern "C" { __declspec(dllimport) int __cdecl wprintf_s(const __wchar_t * , ...); } 
#line 446 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _scwprintf(const __wchar_t * , ...); } 
#line 447
extern "C" { __declspec(dllimport) int __cdecl vfwprintf(FILE * , const __wchar_t * , va_list ); } 
#line 449
extern "C" { __declspec(dllimport) int __cdecl vfwprintf_s(FILE * , const __wchar_t * , va_list ); } 
#line 451 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl vwprintf(const __wchar_t * , va_list ); } 
#line 453
extern "C" { __declspec(dllimport) int __cdecl vwprintf_s(const __wchar_t * , va_list ); } 
#line 457 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl swprintf_s(__wchar_t * , size_t , const __wchar_t * , ...); } 
#line 459 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl swprintf_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Format, ... ) throw ( ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return vswprintf_s ( _Dest, _Size, _Format, _ArgList ); }__pragma( warning(pop)) 
#line 461
extern "C" { __declspec(dllimport) int __cdecl vswprintf_s(__wchar_t * , size_t , const __wchar_t * , va_list ); } 
#line 463 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
template < size_t _Size > inline int __cdecl vswprintf_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Format, va_list _Args ) throw ( ) { return vswprintf_s ( _Dest, _Size, _Format, _Args ); }
#line 465
extern "C" { __declspec(dllimport) int __cdecl _swprintf_c(__wchar_t * , size_t , const __wchar_t * , ...); } 
#line 466
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_c(__wchar_t * , size_t , const __wchar_t * , va_list ); } 
#line 468
extern "C" { __declspec(dllimport) int __cdecl _snwprintf_s(__wchar_t * , size_t , size_t , const __wchar_t * , ...); } 
#line 469
__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl _snwprintf_s ( wchar_t ( & _Dest ) [ _Size ], size_t _Count, const wchar_t * _Format, ... ) throw ( ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return _vsnwprintf_s ( _Dest, _Size, _Count, _Format, _ArgList ); }__pragma( warning(pop)) 
#line 470
extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf_s(__wchar_t * , size_t , size_t , const __wchar_t * , va_list ); } 
#line 471
template < size_t _Size > inline int __cdecl _vsnwprintf_s ( wchar_t ( & _Dest ) [ _Size ], size_t _Count, const wchar_t * _Format, va_list _Args ) throw ( ) { return _vsnwprintf_s ( _Dest, _Size, _Count, _Format, _Args ); }
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { __declspec(dllimport) int __cdecl _snwprintf(__wchar_t * , size_t , const __wchar_t * , ...); } extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf(__wchar_t * , size_t , const __wchar_t * , va_list ); } 
#pragma warning(pop)
#line 477
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_p(FILE * , const __wchar_t * , ...); } 
#line 478
extern "C" { __declspec(dllimport) int __cdecl _wprintf_p(const __wchar_t * , ...); } 
#line 479
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_p(FILE * , const __wchar_t * , va_list ); } 
#line 480
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_p(const __wchar_t * , va_list ); } 
#line 481
extern "C" { __declspec(dllimport) int __cdecl _swprintf_p(__wchar_t * , size_t , const __wchar_t * , ...); } 
#line 482
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_p(__wchar_t * , size_t , const __wchar_t * , va_list ); } 
#line 483
extern "C" { __declspec(dllimport) int __cdecl _scwprintf_p(const __wchar_t * , ...); } 
#line 484
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf_p(const __wchar_t * , va_list ); } 
#line 486
extern "C" { __declspec(dllimport) int __cdecl _wprintf_l(const __wchar_t * , _locale_t , ...); } 
#line 487
extern "C" { __declspec(dllimport) int __cdecl _wprintf_p_l(const __wchar_t * , _locale_t , ...); } 
#line 488
extern "C" { __declspec(dllimport) int __cdecl _wprintf_s_l(const __wchar_t * , _locale_t , ...); } 
#line 489
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_l(const __wchar_t * , _locale_t , va_list ); } 
#line 490
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_p_l(const __wchar_t * , _locale_t , va_list ); } 
#line 491
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_s_l(const __wchar_t * , _locale_t , va_list ); } 
#line 493
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_l(FILE * , const __wchar_t * , _locale_t , ...); } 
#line 494
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_p_l(FILE * , const __wchar_t * , _locale_t , ...); } 
#line 495
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_s_l(FILE * , const __wchar_t * , _locale_t , ...); } 
#line 496
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_l(FILE * , const __wchar_t * , _locale_t , va_list ); } 
#line 497
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_p_l(FILE * , const __wchar_t * , _locale_t , va_list ); } 
#line 498
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_s_l(FILE * , const __wchar_t * , _locale_t , va_list ); } 
#line 500
extern "C" { __declspec(dllimport) int __cdecl _swprintf_c_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , ...); } 
#line 501
extern "C" { __declspec(dllimport) int __cdecl _swprintf_p_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , ...); } 
#line 502
extern "C" { __declspec(dllimport) int __cdecl _swprintf_s_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , ...); } 
#line 503
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_c_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , va_list ); } 
#line 504
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_p_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , va_list ); } 
#line 505
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_s_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , va_list ); } 
#line 507
extern "C" { __declspec(dllimport) int __cdecl _scwprintf_l(const __wchar_t * , _locale_t , ...); } 
#line 508
extern "C" { __declspec(dllimport) int __cdecl _scwprintf_p_l(const __wchar_t * , _locale_t , ...); } 
#line 509
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf_p_l(const __wchar_t * , _locale_t , va_list ); } 
#line 511
extern "C" { __declspec(dllimport) int __cdecl _snwprintf_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , ...); } 
#line 512
extern "C" { __declspec(dllimport) int __cdecl _snwprintf_s_l(__wchar_t * , size_t , size_t , const __wchar_t * , _locale_t , ...); } 
#line 513
extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , va_list ); } 
#line 514
extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf_s_l(__wchar_t * , size_t , size_t , const __wchar_t * , _locale_t , va_list ); } 
#line 528 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
#pragma warning(push)
#pragma warning(disable:4141 4996 4793)
extern "C" { __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _swprintf(__wchar_t * , const __wchar_t * , ...); } extern "C" { __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _vswprintf(__wchar_t * , const __wchar_t * , va_list ); } 
#line 531
extern "C" { __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __swprintf_l(__wchar_t * , const __wchar_t * , _locale_t , ...); } extern "C" { __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __vswprintf_l(__wchar_t * , const __wchar_t * , _locale_t , va_list ); } 
#pragma warning(pop)
#line 34 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"
#pragma warning( push )
#pragma warning( disable : 4793 4412 )
extern "C" { static __inline int swprintf(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, ...) 
#line 37
{ 
#line 38
va_list _Arglist; 
#line 39
int _Ret; 
#line 40
_Arglist = (((va_list)(&(reinterpret_cast< const char &>(_Format)))) + (((sizeof _Format + sizeof(int)) - (1)) & (~(sizeof(int) - (1))))); 
#line 41
_Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist); 
#line 42
_Arglist = ((va_list)0); 
#line 43
return _Ret; 
#line 44
} } 
#pragma warning( pop )
#line 47
#pragma warning( push )
#pragma warning( disable : 4412 )
extern "C" { static __inline int __cdecl vswprintf(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, va_list _Ap) 
#line 50
{ 
#line 51
return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap); 
#line 52
} } 
#pragma warning( pop )
#line 58 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"
#pragma warning( push )
#pragma warning( disable : 4793 4412 )
extern "C" { static __inline int _swprintf_l(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, _locale_t _Plocinfo, ...) 
#line 61
{ 
#line 62
va_list _Arglist; 
#line 63
int _Ret; 
#line 64
_Arglist = (((va_list)(&(reinterpret_cast< const char &>(_Plocinfo)))) + (((sizeof _Plocinfo + sizeof(int)) - (1)) & (~(sizeof(int) - (1))))); 
#line 65
_Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist); 
#line 66
_Arglist = ((va_list)0); 
#line 67
return _Ret; 
#line 68
} } 
#pragma warning( pop )
#line 71
#pragma warning( push )
#pragma warning( disable : 4412 )
extern "C" { static __inline int __cdecl _vswprintf_l(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, _locale_t _Plocinfo, va_list _Ap) 
#line 74
{ 
#line 75
return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap); 
#line 76
} } 
#pragma warning( pop )
#line 80
#pragma warning( push )
#pragma warning( disable : 4996 )
#line 83
#pragma warning( push )
#pragma warning( disable : 4793 4141 )
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __inline int swprintf(__wchar_t *_String, const __wchar_t *_Format, ...) 
#line 86
{ 
#line 87
va_list _Arglist; 
#line 88
_Arglist = (((va_list)(&(reinterpret_cast< const char &>(_Format)))) + (((sizeof _Format + sizeof(int)) - (1)) & (~(sizeof(int) - (1))))); 
#line 89
int _Ret = _vswprintf(_String, _Format, _Arglist); 
#line 90
_Arglist = ((va_list)0); 
#line 91
return _Ret; 
#line 92
} 
#pragma warning( pop )
#line 95
#pragma warning( push )
#pragma warning( disable : 4141 )
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __inline int __cdecl vswprintf(__wchar_t *_String, const __wchar_t *_Format, va_list _Ap) 
#line 98
{ 
#line 99
return _vswprintf(_String, _Format, _Ap); 
#line 100
} 
#pragma warning( pop )
#line 103
#pragma warning( push )
#pragma warning( disable : 4793 4141 )
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __inline int _swprintf_l(__wchar_t *_String, const __wchar_t *_Format, _locale_t _Plocinfo, ...) 
#line 106
{ 
#line 107
va_list _Arglist; 
#line 108
_Arglist = (((va_list)(&(reinterpret_cast< const char &>(_Plocinfo)))) + (((sizeof _Plocinfo + sizeof(int)) - (1)) & (~(sizeof(int) - (1))))); 
#line 109
int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist); 
#line 110
_Arglist = ((va_list)0); 
#line 111
return _Ret; 
#line 112
} 
#pragma warning( pop )
#line 115
#pragma warning( push )
#pragma warning( disable : 4141 )
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __inline int __cdecl _vswprintf_l(__wchar_t *_String, const __wchar_t *_Format, _locale_t _Plocinfo, va_list _Ap) 
#line 118
{ 
#line 119
return __vswprintf_l(_String, _Format, _Plocinfo, _Ap); 
#line 120
} 
#pragma warning( pop )
#line 123
#pragma warning( pop )
#line 552 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wtempnam(const __wchar_t * , const __wchar_t * ); } 
#line 558 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf(const __wchar_t * , va_list ); } 
#line 559
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf_l(const __wchar_t * , _locale_t , va_list ); } 
#line 560
extern "C" { __declspec(dllimport) int __cdecl fwscanf(FILE * , const __wchar_t * , ...); } 
#line 561
extern "C" { __declspec(dllimport) int __cdecl _fwscanf_l(FILE * , const __wchar_t * , _locale_t , ...); } 
#pragma warning(push)
#pragma warning(disable:6530)
#line 565
extern "C" { __declspec(dllimport) int __cdecl fwscanf_s(FILE * , const __wchar_t * , ...); } 
#line 567 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _fwscanf_s_l(FILE * , const __wchar_t * , _locale_t , ...); } 
#line 568
extern "C" { __declspec(dllimport) int __cdecl swscanf(const __wchar_t * , const __wchar_t * , ...); } 
#line 569
extern "C" { __declspec(dllimport) int __cdecl _swscanf_l(const __wchar_t * , const __wchar_t * , _locale_t , ...); } 
#line 571
extern "C" { __declspec(dllimport) int __cdecl swscanf_s(const __wchar_t * , const __wchar_t * , ...); } 
#line 573 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _swscanf_s_l(const __wchar_t * , const __wchar_t * , _locale_t , ...); } 
#line 574
extern "C" { __declspec(dllimport) int __cdecl _snwscanf(const __wchar_t * , size_t , const __wchar_t * , ...); } 
#line 575
extern "C" { __declspec(dllimport) int __cdecl _snwscanf_l(const __wchar_t * , size_t , const __wchar_t * , _locale_t , ...); } 
#line 576
extern "C" { __declspec(dllimport) int __cdecl _snwscanf_s(const __wchar_t * , size_t , const __wchar_t * , ...); } 
#line 577
extern "C" { __declspec(dllimport) int __cdecl _snwscanf_s_l(const __wchar_t * , size_t , const __wchar_t * , _locale_t , ...); } 
#line 578
extern "C" { __declspec(dllimport) int __cdecl wscanf(const __wchar_t * , ...); } 
#line 579
extern "C" { __declspec(dllimport) int __cdecl _wscanf_l(const __wchar_t * , _locale_t , ...); } 
#line 581
extern "C" { __declspec(dllimport) int __cdecl wscanf_s(const __wchar_t * , ...); } 
#line 583 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _wscanf_s_l(const __wchar_t * , _locale_t , ...); } 
#pragma warning(pop)
#line 586
extern "C" { __declspec(dllimport) FILE *__cdecl _wfdopen(int , const __wchar_t * ); } 
#line 587
extern "C" { __declspec(dllimport) FILE *__cdecl _wfopen(const __wchar_t * , const __wchar_t * ); } 
#line 588
extern "C" { __declspec(dllimport) errno_t __cdecl _wfopen_s(FILE ** , const __wchar_t * , const __wchar_t * ); } 
#line 589
extern "C" { __declspec(dllimport) FILE *__cdecl _wfreopen(const __wchar_t * , const __wchar_t * , FILE * ); } 
#line 590
extern "C" { __declspec(dllimport) errno_t __cdecl _wfreopen_s(FILE ** , const __wchar_t * , const __wchar_t * , FILE * ); } 
#line 597
extern "C" { __declspec(dllimport) FILE *__cdecl _wpopen(const __wchar_t * , const __wchar_t * ); } 
#line 599 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _wremove(const __wchar_t * ); } 
#line 600
extern "C" { __declspec(dllimport) errno_t __cdecl _wtmpnam_s(__wchar_t * , size_t ); } 
#line 601
template < size_t _Size > inline errno_t __cdecl _wtmpnam_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wtmpnam_s ( _Buffer, _Size ); }
#line 602
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wtmpnam(__wchar_t * ); } 
#line 604
extern "C" { __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(FILE * ); } 
#line 605
extern "C" { __declspec(dllimport) wint_t __cdecl _fputwc_nolock(__wchar_t , FILE * ); } 
#line 606
extern "C" { __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(wint_t , FILE * ); } 
#line 614 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { inline wint_t __cdecl getwchar() 
#line 615
{ return fgetwc(&(__iob_func()[0])); } } 
#line 616
extern "C" { inline wint_t __cdecl putwchar(__wchar_t _C) 
#line 617
{ return fputwc(_C, &(__iob_func()[1])); } } 
#line 663 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) void __cdecl _lock_file(FILE * ); } 
#line 664
extern "C" { __declspec(dllimport) void __cdecl _unlock_file(FILE * ); } 
#line 666
extern "C" { __declspec(dllimport) int __cdecl _fclose_nolock(FILE * ); } 
#line 667
extern "C" { __declspec(dllimport) int __cdecl _fflush_nolock(FILE * ); } 
#line 668
extern "C" { __declspec(dllimport) size_t __cdecl _fread_nolock(void * , size_t , size_t , FILE * ); } 
#line 669
extern "C" { __declspec(dllimport) size_t __cdecl _fread_nolock_s(void * , size_t , size_t , size_t , FILE * ); } 
#line 670
extern "C" { __declspec(dllimport) int __cdecl _fseek_nolock(FILE * , long , int ); } 
#line 671
extern "C" { __declspec(dllimport) long __cdecl _ftell_nolock(FILE * ); } 
#line 672
extern "C" { __declspec(dllimport) int __cdecl _fseeki64_nolock(FILE * , __int64 , int ); } 
#line 673
extern "C" { __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(FILE * ); } 
#line 674
extern "C" { __declspec(dllimport) size_t __cdecl _fwrite_nolock(const void * , size_t , size_t , FILE * ); } 
#line 675
extern "C" { __declspec(dllimport) int __cdecl _ungetc_nolock(int , FILE * ); } 
#line 702 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) char *__cdecl tempnam(const char * , const char * ); } 
#line 708 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fcloseall(); } 
#line 709
extern "C" { __declspec(dllimport) FILE *__cdecl fdopen(int , const char * ); } 
#line 710
extern "C" { __declspec(dllimport) int __cdecl fgetchar(); } 
#line 711
extern "C" { __declspec(dllimport) int __cdecl fileno(FILE * ); } 
#line 712
extern "C" { __declspec(dllimport) int __cdecl flushall(); } 
#line 713
extern "C" { __declspec(dllimport) int __cdecl fputchar(int ); } 
#line 714
extern "C" { __declspec(dllimport) int __cdecl getw(FILE * ); } 
#line 715
extern "C" { __declspec(dllimport) int __cdecl putw(int , FILE * ); } 
#line 716
extern "C" { __declspec(dllimport) int __cdecl rmtmp(); } 
#line 724 "C:\\Program Files\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
#pragma pack ( pop )
#line 4 "C:/Users/H8/Documents/Visual Studio 2012/Projects/AmpIdent/AmpIdentGPUkernel/AmpIdentGPUkernel/kernel.cu"
 __noinline__ void kernel(int a, int b, int *c) ;
#if 0
#line 5
{ 
#line 6
(*c) = ((a + b) * (a + b)); 
#line 7
} 
#endif
#line 9 "C:/Users/H8/Documents/Visual Studio 2012/Projects/AmpIdent/AmpIdentGPUkernel/AmpIdentGPUkernel/kernel.cu"
int main() 
#line 10
{ 
#line 11
return 0; 
#line 12
} 
#line 1 "kernel.cudafe1.stub.c"
#define _NV_ANON_NAMESPACE _GLOBAL__N__14_kernel_cpp1_ii_b614c5e6
#line 1 "kernel.cudafe1.stub.c"
#include "kernel.cudafe1.stub.c"
#line 1 "kernel.cudafe1.stub.c"
#undef _NV_ANON_NAMESPACE
